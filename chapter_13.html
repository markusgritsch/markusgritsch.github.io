<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="style.css" rel="stylesheet" type="text/css" /><title>Understanding Digital Signal Processing</title>
<style type="text/css">
body {
  font-family: "BookerlyLCD";
}
a {
  color: #005090;
  text-decoration: none;
}
a {font-variant-numeric: oldstyle-nums proportional-nums;}
p.caption {font-variant-numeric: oldstyle-nums proportional-nums;}
</style>
</head><body>


<div class="calibre" id="calibre_link-572">
<p class="calibre3"><a id="calibre_link-2482"></a></p>
<h2 class="calibre8"><a id="calibre_link-2483" class="calibre5"></a>Contents</h2>
<p class="toc-chapter1"><strong class="calibre9"><a href="#calibre_link-677">13 DIGITAL SIGNAL PROCESSING TRICKS</a></strong></p>
<p class="toc-section"><a href="#calibre_link-339">13.1 Frequency Translation without Multiplication</a></p>
<p class="toc-section"><a href="#calibre_link-678">13.2 High-Speed Vector Magnitude Approximation</a></p>
<p class="toc-section"><a href="#calibre_link-464">13.3 Frequency-Domain Windowing</a></p>
<p class="toc-section"><a href="#calibre_link-679">13.4 Fast Multiplication of Complex Numbers</a></p>
<p class="toc-section"><a href="#calibre_link-463">13.5 Efficiently Performing the FFT of Real Sequences</a></p>
<p class="toc-section"><a href="#calibre_link-680">13.6 Computing the Inverse FFT Using the Forward FFT</a></p>
<p class="toc-section"><a href="#calibre_link-148">13.7 Simplified FIR Filter Structure</a></p>
<p class="toc-section"><a href="#calibre_link-681">13.8 Reducing A/D Converter Quantization Noise</a></p>
<p class="toc-section"><a href="#calibre_link-682">13.9 A/D Converter Testing Techniques</a></p>
<p class="toc-section"><a href="#calibre_link-524">13.10 Fast FIR Filtering Using the FFT</a></p>
<p class="toc-section"><a href="#calibre_link-683">13.11 Generating Normally Distributed Random Data</a></p>
<p class="toc-section"><a href="#calibre_link-105">13.12 Zero-Phase Filtering</a></p>
<p class="toc-section"><a href="#calibre_link-684">13.13 Sharpened FIR Filters</a></p>
<p class="toc-section"><a href="#calibre_link-685">13.14 Interpolating a Bandpass Signal</a></p>
<p class="toc-section"><a href="#calibre_link-686">13.15 Spectral Peak Location Algorithm</a></p>
<p class="toc-section"><a id="calibre_link-2488"></a><a href="#calibre_link-687">13.16 Computing FFT Twiddle Factors</a></p>
<p class="toc-section"><a href="#calibre_link-688">13.17 Single Tone Detection</a></p>
<p class="toc-section"><a href="#calibre_link-689">13.18 The Sliding DFT</a></p>
<p class="toc-section"><a href="#calibre_link-690">13.19 The Zoom FFT</a></p>
<p class="toc-section"><a href="#calibre_link-691">13.20 A Practical Spectrum Analyzer</a></p>
<p class="toc-section"><a href="#calibre_link-692">13.21 An Efficient Arctangent Approximation</a></p>
<p class="toc-section"><a href="#calibre_link-314">13.22 Frequency Demodulation Algorithms</a></p>
<p class="toc-section"><a href="#calibre_link-693">13.23 DC Removal</a></p>
<p class="toc-section"><a href="#calibre_link-215">13.24 Improving Traditional CIC Filters</a></p>
<p class="toc-section"><a href="#calibre_link-694">13.25 Smoothing Impulsive Noise</a></p>
<p class="toc-section"><a href="#calibre_link-695">13.26 Efficient Polynomial Evaluation</a></p>
<p class="toc-section"><a href="#calibre_link-696">13.27 Designing Very High-Order FIR Filters</a></p>
<p class="toc-section"><a href="#calibre_link-697">13.28 Time-Domain Interpolation Using the FFT</a></p>
<p class="toc-section"><a href="#calibre_link-698">13.29 Frequency Translation Using Decimation</a></p>
<p class="toc-section"><a href="#calibre_link-699">13.30 Automatic Gain Control (AGC)</a></p>
<p class="toc-section"><a href="#calibre_link-700">13.31 Approximate Envelope Detection</a></p>
<p class="toc-section"><a href="#calibre_link-701">13.32 A Quadrature Oscillator</a></p>
<p class="toc-section"><a href="#calibre_link-702">13.33 Specialized Exponential Averaging</a></p>
<p class="toc-section"><a href="#calibre_link-703">13.34 Filtering Narrowband Noise Using Filter Nulls</a></p>
<p class="toc-section"><a href="#calibre_link-550">13.35 Efficient Computation of Signal Variance</a></p>
<p class="toc-section"><a href="#calibre_link-704">13.36 Real-time Computation of Signal Averages and Variances</a></p>
<p class="toc-section"><a href="#calibre_link-340">13.37 Building Hilbert Transformers from Half-band Filters</a></p>
<p class="toc-section"><a href="#calibre_link-705">13.38 Complex Vector Rotation with Arctangents</a></p>
<p class="toc-section"><a href="#calibre_link-706">13.39 An Efficient Differentiating Network</a></p>
<p class="toc-section"><a href="#calibre_link-707">13.40 Linear-Phase DC-Removal Filter</a></p>
<p class="toc-section"><a href="#calibre_link-708">13.41 Avoiding Overflow in Magnitude Computations</a></p>
<p class="toc-section"><a href="#calibre_link-709">13.42 Efficient Linear Interpolation</a></p>
<p class="toc-section"><a href="#calibre_link-710">13.43 Alternate Complex Down-conversion Schemes</a></p>
<p class="toc-section"><a href="#calibre_link-711">13.44 Signal Transition Detection</a></p>
<p class="toc-section"><a href="#calibre_link-712">13.45 Spectral Flipping around Signal Center Frequency</a></p>
<p class="toc-section"><a href="#calibre_link-713">13.46 Computing Missing Signal Samples</a></p>
<p class="toc-section"><a href="#calibre_link-714">13.47 Computing Large DFTs Using Small FFTs</a></p>
<p class="toc-section"><a href="#calibre_link-715">13.48 Computing Filter Group Delay without Arctangents</a></p>
<p class="toc-section"><a href="#calibre_link-716">13.49 Computing a Forward and Inverse FFT Using a Single FFT</a></p>
<p class="toc-section"><a href="#calibre_link-717">13.50 Improved Narrowband Lowpass IIR Filters</a></p>
<p class="toc-section"><a href="#calibre_link-718">13.51 A Stable Goertzel Algorithm</a></p>
<p class="toc-section1"><a href="#calibre_link-719">References</a></p>

</div>


<div class="calibre" id="calibre_link-677">
<p class="calibre3"><a id="calibre_link-160"></a></p>
<h2 class="calibre8"><a id="calibre_link-2283" class="calibre5"></a>13 Digital Signal Processing Tricks</h2>
<p class="image"><img src="images/000089.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">As we study the literature of digital signal processing, we’ll encounter some creative techniques that professionals use to make their algorithms more efficient. These practical techniques are straightforward examples of the philosophy “Don’t work hard, work smart,” and studying them will give us a deeper understanding of the underlying mathematical subtleties of DSP. In this chapter, we present a collection of these tricks of the trade, in no particular order, and explore several of them in detail because doing so reinforces the lessons we’ve learned in previous chapters.</p>
<p class="calibre3"><a id="calibre_link-339"></a></p>
<h3 class="calibre6">13.1 Frequency Translation without Multiplication</h3>
<p class="calibre3">Frequency translation is often called for in digital signal processing algorithms. There are simple schemes for inducing frequency translation by 1/2 and 1/4 of the signal sequence sample rate. Let’s take a look at these mixing schemes.</p>
<p class="calibre3"><a id="calibre_link-3210"></a></p>
<h4 class="calibre13">13.1.1 Frequency Translation by <em class="calibre7">f<sub class="calibre12">s</sub></em>/2</h4>
<p class="calibre3">First we’ll consider a technique for frequency translating an input sequence by <em class="calibre7">f<sub class="calibre12">s</sub></em>/2 by merely multiplying a sequence by (−1)<em class="calibre7"><sup class="calibre10">n</sup></em> = 1,−1,1,−1, ..., etc., where <em class="calibre7">f<sub class="calibre12">s</sub></em> is the signal sample rate in Hz. This process may seem a bit mysterious at first, but it can be explained in a straightforward way if we review <a href="#calibre_link-1238">Figure 13-1(a)</a>. There we see that multiplying a time-domain signal sequence by the (−1)<em class="calibre7"><sup class="calibre10">n</sup></em> mixing sequence is equivalent to multiplying the signal sequence by a sampled cosinusoid where the mixing sequence samples are shown as the <a id="calibre_link-3211"></a>dots in <a href="#calibre_link-1238">Figure 13-1(a)</a>. Because the mixing sequence’s cosine repeats every two sample values, its frequency is <em class="calibre7">f<sub class="calibre12">s</sub></em>/2. <a href="#calibre_link-1238">Figures 13-1(b)</a> and <a href="#calibre_link-1238">13-1(c)</a> show the discrete Fourier transform (DFT) magnitude and phase of a 32-sample (−1)<em class="calibre7"><sup class="calibre10">n</sup></em> sequence. As such, the right half of those figures represents the negative frequency range.</p>
<p class="caption"><a id="calibre_link-1238"></a><strong class="calibre9">Figure 13-1</strong> Mixing sequence comprising (−1)<em class="calibre7"><sup class="calibre10">n</sup></em> = 1,−1,1,−1, etc.: (a) time-domain sequence; (b) frequency-domain magnitudes for 32 samples; (c) frequency-domain phase.</p>
<p class="image"><img src="images/000816.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Let’s demonstrate this (−1)<em class="calibre7"><sup class="calibre10">n</sup></em> mixing with an example. Consider a real <em class="calibre7">x</em>(<em class="calibre7">n</em>) signal sequence having 32 samples of the sum of three sinusoids whose |<em class="calibre7">X</em>(<em class="calibre7">m</em>)| frequency magnitude and ϕ(<em class="calibre7">m</em>) phase spectra are as shown in <a href="#calibre_link-1239">Figures 13-2(a)</a> and <a href="#calibre_link-1239">13-2(b)</a>. If we multiply that time signal sequence by (−1)<em class="calibre7"><sup class="calibre10">n</sup>,</em> the resulting <em class="calibre7">x</em><sub class="calibre12">1,−1</sub>(<em class="calibre7">n</em>) time sequence will have the magnitude and phase spectra that are shown in <a href="#calibre_link-1239">Figures 13-2(c)</a> and <a href="#calibre_link-1239">13-2(d)</a>. Multiplying a time signal by our (−1)<em class="calibre7"><sup class="calibre10">n</sup></em> cosine shifts half its spectral energy up by <em class="calibre7">f<sub class="calibre12">s</sub></em>/2 and half its spectral energy down by −<em class="calibre7">f<sub class="calibre12">s</sub></em>/2. Notice in these non-circular frequency depictions that as we count up, or down, in frequency, we wrap around the end points.</p>
<p class="caption"><a id="calibre_link-1239"></a><strong class="calibre9">Figure 13-2</strong> A signal and its frequency translation by <em class="calibre7">f<sub class="calibre12">s</sub></em>/2: (a) original signal magnitude spectrum; (b) original phase; (c) the magnitude spectrum of the translated signal; (d) translated phase.</p>
<p class="image"><img src="images/001342.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Here’s a terrific opportunity for the DSP novice to convolve the (−1)<em class="calibre7"><sup class="calibre10">n</sup></em> spectrum in <a href="#calibre_link-1238">Figure 13-1</a> with the <em class="calibre7">X</em>(<em class="calibre7">m</em>) spectrum to obtain the frequency-translated <em class="calibre7">X</em><sub class="calibre12">1,−1</sub>(<em class="calibre7">m</em>) signal spectrum. Please do so; that exercise will help you comprehend the nature of discrete sequences and their time- and frequency-domain relationships by way of the convolution theorem.</p>
<p class="calibre3"><a id="calibre_link-3212"></a>Remember, now, we didn’t really perform any explicit multiplications&mdash;the whole idea here is to avoid multiplications; we merely changed the sign of alternating <em class="calibre7">x</em>(<em class="calibre7">n</em>) samples to get <em class="calibre7">x</em><sub class="calibre12">1,−1</sub>(<em class="calibre7">n</em>). One way to look at the <em class="calibre7">X</em><sub class="calibre12">1,−1</sub>(<em class="calibre7">m</em>) magnitudes in <a href="#calibre_link-1239">Figure 13-2(c)</a> is to see that multiplication by the (−1)<em class="calibre7"><sup class="calibre10">n</sup></em> mixing sequence flips the positive-frequency band of <em class="calibre7">X</em>(<em class="calibre7">m</em>) (<em class="calibre7">X</em>(0) to <em class="calibre7">X</em>(16)) about the <em class="calibre7">f<sub class="calibre12">s</sub></em>/4 Hz point and flips the negative-frequency band of <em class="calibre7">X</em>(<em class="calibre7">m</em>) (<em class="calibre7">X</em>(17) to <em class="calibre7">X</em>(31)) about the −<em class="calibre7">f<sub class="calibre12">s</sub></em>/4 Hz sample. This process can be used to invert the spectra of real signals when bandpass sampling is used as described in <a href="#calibre_link-586">Section 2.4</a>. By the way, in the DSP literature be aware that some clever authors may represent the (−1)<em class="calibre7"><sup class="calibre10">n</sup></em> sequence with its equivalent expressions of</p>
<p class="caption"><a id="calibre_link-3213"></a>(13-1)</p>
<p class="image"><img src="images/000832.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3214"></a></p>
<h4 class="calibre13"><a id="calibre_link-2284"></a>13.1.2 Frequency Translation by −<em class="calibre7">f<sub class="calibre12">s</sub></em>/4</h4>
<p class="calibre3">Two other simple mixing sequences form the real and imaginary parts of a complex −<em class="calibre7">f<sub class="calibre12">s</sub></em>/4 oscillator used for frequency down-conversion to obtain a quadrature version (complex and centered at 0 Hz) of a real bandpass signal originally centered at <em class="calibre7">f<sub class="calibre12">s</sub></em>/4. The real (in-phase) mixing sequence is cos(π<em class="calibre7">n</em>/2) = 1,0,−1,0, etc., shown in <a href="#calibre_link-1240">Figure 13-3(a)</a>. That mixing sequence’s quadrature companion is −sin(π<em class="calibre7">n</em>/2) = 0,−1,0,1, etc., as shown in <a href="#calibre_link-1240">Figure 13-3(b)</a>. The spectral magnitudes of those two sequences are identical as shown in <a href="#calibre_link-1240">Figure 13-3(c)</a>, but their phase spectrum has a 90-degree shift relationship (what we call <em class="calibre7">quadrature</em>).</p>
<p class="caption"><a id="calibre_link-1240"></a><strong class="calibre9">Figure 13-3</strong> Quadrature mixing sequences for down-conversion by <em class="calibre7">f<sub class="calibre12">s</sub></em>/4: (a) in-phase mixing sequence; (b) quadrature-phase mixing sequence; (c) the frequency magnitudes of both sequences for <em class="calibre7">N</em> = 32 samples; (d) the phase of the cosine sequence; (e) phase of the sine sequence.</p>
<p class="image"><img src="images/000159.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3215"></a>If we multiply the <em class="calibre7">x</em>(<em class="calibre7">n</em>) sequence whose spectrum is that shown in <a href="#calibre_link-1239">Figures 13-2(a)</a> and <a href="#calibre_link-1239">13-2(b)</a> by the in-phase (cosine) mixing sequence, the product will have the <em class="calibre7">I</em>(<em class="calibre7">m</em>) spectrum shown in <a href="#calibre_link-1241">Figures 13-4(a)</a> and <a href="#calibre_link-1241">13-4(b)</a>. Again, <em class="calibre7">X</em>(<em class="calibre7">m</em>)’s spectral energy is translated up and down in frequency, only this time the translation is by ±<em class="calibre7">f<sub class="calibre12">s</sub></em>/4. Multiplying <em class="calibre7">x</em>(<em class="calibre7">n</em>) by the quadrature-phase (sine) sequence yields the <em class="calibre7">Q</em>(<em class="calibre7">m</em>) spectrum in <a href="#calibre_link-1241">Figures 13-4(a)</a> and <a href="#calibre_link-1241">13-4(c)</a>.</p>
<p class="caption"><a id="calibre_link-1241"></a><strong class="calibre9">Figure 13-4</strong> Spectra after translation down by <em class="calibre7">f<sub class="calibre12">s</sub></em>/4: (a) <em class="calibre7">I</em>(<em class="calibre7">m</em>) and <em class="calibre7">Q</em>(<em class="calibre7">m</em>) spectral magnitudes; (b) phase of <em class="calibre7">I</em>(<em class="calibre7">m</em>) ; (c) phase of <em class="calibre7">Q</em>(<em class="calibre7">m</em>).</p>
<p class="image"><img src="images/000776.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Because their time sample values are merely 1, −1, and 0, the quadrature mixing sequences are useful because down-conversion by <em class="calibre7">f<sub class="calibre12">s</sub></em>/4 can be implemented without multiplication. That’s why these mixing sequences are of so much interest: down-conversion of an input time sequence is accomplished merely with data assignment, or signal routing.</p>
<p class="calibre3">To down-convert a general <em class="calibre7">x</em>(<em class="calibre7">n</em>) = <em class="calibre7">x</em><sub class="calibre12">real</sub>(<em class="calibre7">n</em>) + <em class="calibre7">jx</em><sub class="calibre12">imag</sub>(<em class="calibre7">n</em>) sequence by <em class="calibre7">f<sub class="calibre12">s</sub></em>/4, the value assignments are</p>
<p class="caption"><a id="calibre_link-3216"></a>(13-2)</p>
<p class="image"><img src="images/000170.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2110"></a>If your implementation is hardwired gates, the above data assignments are performed by means of routing signals (and their negatives). Although we’ve focused on down-conversion so far, it’s worth mentioning that up-conversion of a general <em class="calibre7">x</em>(<em class="calibre7">n</em>) sequence by <em class="calibre7">f<sub class="calibre12">s</sub></em>/4 can be performed with the following data assignments:</p>
<p class="caption"><a id="calibre_link-3217"></a>(13-3)</p>
<p class="image"><img src="images/000350.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">We notify the reader, at this point, that <a href="#calibre_link-698">Section 13.29</a> presents an interesting trick for performing frequency translation using decimation rather than multiplication.</p>
<p class="calibre3"><a id="calibre_link-3218"></a></p>
<h4 class="calibre13">13.1.3 Filtering and Decimation after <em class="calibre7">f<sub class="calibre12">s</sub></em>/4 Down-Conversion</h4>
<p class="calibre3">There’s an efficient way to perform the complex down-conversion, by <em class="calibre7">f<sub class="calibre12">s</sub></em>/4, and filtering of a real signal process that we discussed for the quadrature sampling scheme in <a href="#calibre_link-644">Section 8.9</a>. We can use a novel technique to greatly reduce the computational workload of the linear-phase lowpass filters[<a href="#calibre_link-1242">1</a>&ndash;<a href="#calibre_link-1243">3</a>]. In addition, decimation of the complex down-converted sequence by a factor of two is inherent, with no effort on our part, in this process.</p>
<p class="calibre3">Considering <a href="#calibre_link-1244">Figure 13-5(a)</a>, notice that if an original <em class="calibre7">x</em>(<em class="calibre7">n</em>) sequence was real-only, and its spectrum is centered at <em class="calibre7">f<sub class="calibre12">s</sub></em>/4, multiplying <em class="calibre7">x</em>(<em class="calibre7">n</em>) by cos(π<em class="calibre7">n</em>/2) = 1,0,−1,0, for the in-phase path and −sin(π<em class="calibre7">n</em>/2) = 0,−1,0,1, for the quadrature-phase path to down-convert <em class="calibre7">x</em>(<em class="calibre7">n</em>)’s spectrum to 0 Hz yields the new complex sequence <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">n</em>) = <em class="calibre7">x</em><sub class="calibre12">i</sub>(<em class="calibre7">n</em>) + <em class="calibre7">x</em><sub class="calibre12">q</sub>(<em class="calibre7">n</em>), or</p>
<p class="caption"><a id="calibre_link-3219"></a>(13-4)</p>
<p class="image"><img src="images/001538.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-1244"></a><strong class="calibre9">Figure 13-5</strong> Complex down-conversion by <em class="calibre7">f<sub class="calibre12">s</sub></em>/4 and filtering by a 5-tap LPF: (a) the process; (b) in-phase filter data; (c) quadrature-phase filter data.</p>
<p class="image"><img src="images/001404.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Next, we want to lowpass filter (LPF) both the <em class="calibre7">x</em><sub class="calibre12">i</sub>(<em class="calibre7">n</em>) and <em class="calibre7">x</em><sub class="calibre12">q</sub>(<em class="calibre7">n</em>) sequences followed by decimation by a factor of two.</p>
<p class="calibre3">Here’s the trick. Let’s say we’re using 5-tap FIR filters and at the <em class="calibre7">n</em> = 4 time index the data residing in the two lowpass filters would be that shown in <a href="#calibre_link-1244">Figures 13-5(b)</a> and <a href="#calibre_link-1244">13-5(c)</a>. Due to the alternating zero-valued samples in the <em class="calibre7">x</em><sub class="calibre12">i</sub>(<em class="calibre7">n</em>) and <em class="calibre7">x</em><sub class="calibre12">q</sub>(<em class="calibre7">n</em>) sequences, we see that only five nonzero multiplies are being performed at this time instant. Those computations, at time index <em class="calibre7">n</em> = 4, are shown in the third row of the rightmost column in <a href="#calibre_link-1245">Table 13-1</a>. Because <a id="calibre_link-3220"></a>we’re decimating by two, we ignore the time index <em class="calibre7">n</em> = 5 computations. The necessary computations during the next time index (<em class="calibre7">n</em> = 6) are given in the fourth row of <a href="#calibre_link-1245">Table 13-1</a>, where again only five nonzero multiplies are computed.</p>
<p class="caption"><a id="calibre_link-1245"></a><strong class="calibre9">Table 13-1</strong> Filter Data and Necessary Computations after Decimation by Two</p>
<p class="image"><img src="images/000266.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">A review of <a href="#calibre_link-1245">Table 13-1</a> tells us we can multiplex the real-valued <em class="calibre7">x</em>(<em class="calibre7">n</em>) sequence, multiply the multiplexed sequences by the repeating mixing sequence 1,−1, ..., etc., and apply the resulting <em class="calibre7">x</em><sub class="calibre12">i</sub>(<em class="calibre7">n</em>) and <em class="calibre7">x</em><sub class="calibre12">q</sub>(<em class="calibre7">n</em>) sequences to two filters, as shown in <a href="#calibre_link-1246">Figure 13-6(a)</a>. Those two filters have <em class="calibre7">decimated</em> coefficients in the sense that their coefficients are the alternating <em class="calibre7">h</em>(<em class="calibre7">k</em>) coefficients from the original lowpass filter in <a href="#calibre_link-1244">Figure 13-5</a>. The two new filters are depicted in <a href="#calibre_link-1246">Figure 13-6(b)</a>, showing the necessary computations at time index <em class="calibre7">n</em> = 4. Using this new process, we’ve reduced our multiplication workload by a factor of two. The original data multiplexing in <a href="#calibre_link-1246">Figure 13-6(a)</a> is what implemented our desired decimation by two.</p>
<p class="caption"><a id="calibre_link-1246"></a><strong class="calibre9">Figure 13-6</strong> Efficient down-conversion, filtering by a 5-tap LPF, and decimation: (a) process block diagram; (b) the modified filters and data at time <em class="calibre7">n</em> = 4; (c) process when a half-band filter is used.</p>
<p class="image"><img src="images/000220.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2266"></a>Here’s another feature of this efficient down-conversion structure. If half-band filters are used in <a href="#calibre_link-1244">Figure 13-5(a)</a>, then only one of the coefficients in the modified quadrature lowpass filter is nonzero. This means we can implement the quadrature-path filtering as <em class="calibre7">K</em> unit delays, a single multiply by the original half-band filter’s center coefficient, followed by another <em class="calibre7">K</em> delay as depicted in <a href="#calibre_link-1246">Figure 13-6(c)</a>. For an original <em class="calibre7">N</em>-tap half-band filter, <em class="calibre7">K</em> is the integer part of <em class="calibre7">N</em>/4. If the original half-band filter’s <em class="calibre7">h</em>(<em class="calibre7">N</em>−1)/2 center coefficient is 0.5, as is often the case, we can implement its multiply by an arithmetic right shift of the delayed <em class="calibre7">x</em><sub class="calibre12">q</sub>(<em class="calibre7">n</em>).</p>
<p class="calibre3">This down-conversion process is indeed slick. Here’s another attribute. If the original lowpass filter in <a href="#calibre_link-1244">Figure 13-5(a)</a> has an odd number of taps, the coefficients of the modified filters in <a href="#calibre_link-1246">Figure 13-6(b)</a> will be symmetrical, and we can use the <em class="calibre7">folded</em> FIR filter scheme (<a href="#calibre_link-148">Section 13.7</a>) to reduce the number of multipliers by almost another factor of two!</p>
<p class="calibre3">Finally, if we need to invert the output <em class="calibre7">x</em><sub class="calibre12">c</sub>(<em class="calibre7">n</em>′) spectrum, there are two ways to do so. We can negate the 1,−1, sequence driving the mixer in the quadrature path, or we can swap the order of the single unit delay and the mixer in the quadrature path.</p>
<p class="calibre3"><a id="calibre_link-678"></a></p>
<h3 class="calibre6"><a id="calibre_link-2369" class="calibre5"></a>13.2 High-Speed Vector Magnitude Approximation</h3>
<p class="calibre3">The quadrature processing techniques employed in spectrum analysis, computer graphics, and digital communications routinely require high-speed determination of the magnitude of a complex number (vector <em class="calibre7">V</em>) given its real and imaginary parts, i.e., the in-phase part <em class="calibre7">I</em> and the quadrature-phase part <em class="calibre7">Q</em>. This magnitude calculation requires a square root operation because the magnitude of <em class="calibre7">V</em> is</p>
<p class="caption"><a id="calibre_link-3221"></a>(13-5)</p>
<p class="image"><img src="images/001316.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Assuming that the sum <em class="calibre7">I</em><sup class="calibre10">2</sup> + <em class="calibre7">Q</em><sup class="calibre10">2</sup> is available, the problem is to efficiently perform the square root computation.</p>
<p class="calibre3"><a id="calibre_link-3222"></a>There are several ways to obtain square roots, but the optimum technique depends on the capabilities of the available hardware and software. For example, when performing a square root using a high-level software language, we employ whatever software square root function is available. Accurate software square root routines, however, require many floating-point arithmetic computations. In contrast, if a system must accomplish a square root operation in just a few system clock cycles, high-speed magnitude approximations are required[<a href="#calibre_link-1247">4</a>,<a href="#calibre_link-1248">5</a>]. Let’s look at a neat magnitude approximation scheme that avoids the dreaded square root operation.</p>
<p class="calibre3">There is a technique called the αMax+βMin (read as “alpha max plus beta min”) algorithm for estimating the magnitude of a complex vector.<sup class="calibre10"><a id="calibre_link-1250"></a><a href="#calibre_link-1249">†</a></sup> It’s a linear approximation to the vector magnitude problem that requires the determination of which orthogonal vector, <em class="calibre7">I</em> or <em class="calibre7">Q</em>, has the greater absolute value. If the maximum absolute value of <em class="calibre7">I</em> or <em class="calibre7">Q</em> is designated by Max, and the minimum absolute value of either <em class="calibre7">I</em> or <em class="calibre7">Q</em> is Min, an approximation of |<em class="calibre7">V</em>| using the αMax+βMin algorithm is expressed as</p>
<p class="footnotes"><a id="calibre_link-1249"></a><sup class="calibre11"><a href="#calibre_link-1250">†</a></sup>A “Max+βMin” algorithm had been in use, but in 1988 this author suggested expanding it to the αMax+βMin form where α could be a value other than unity<a href="#calibre_link-1251">[6]</a>.</p>
<p class="caption"><a id="calibre_link-1254"></a>(13-6)</p>
<p class="image"><img src="images/000068.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">There are several pairs for the α and β constants that provide varying degrees of vector magnitude approximation accuracy to within 0.1 dB[<a href="#calibre_link-1247">4</a>,<a href="#calibre_link-1252">7</a>]. The αMax+βMin algorithms in reference <a href="#calibre_link-1253">[8]</a> determine a vector magnitude at whatever speed it takes a system to perform a magnitude comparison, two multiplications, and one addition. But those algorithms require, as a minimum, a 16-bit multiplier to achieve reasonably accurate results. If, however, hardware multipliers are not available, all is not lost. By restricting the α and β constants to reciprocals of integer powers of two, <a href="#calibre_link-1254">Eq. (13-6)</a> lends itself well to implementation in binary integer arithmetic. A prevailing application of the αMax+βMin algorithm uses α = 1.0 and β = 0.5. The 0.5 multiplication operation is performed by shifting the value Min to the right by one bit. We can gauge the accuracy of any vector magnitude estimation algorithm by plotting its |<em class="calibre7">V</em>| as a function of vector phase angle. Let’s do that. The Max + 0.5Min estimate for a complex vector of unity magnitude, over the vector angular range of 0 to 90 degrees, is shown as the solid curve in <a href="#calibre_link-1255">Figure 13-7</a>. (The curves in <a href="#calibre_link-1255">Figure 13-7</a> repeat every 90 degrees.)</p>
<p class="caption"><a id="calibre_link-1255"></a><strong class="calibre9">Figure 13-7</strong> αMax+βMin estimation performance.</p>
<p class="image"><img src="images/000848.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">An ideal estimation curve for a unity magnitude vector would have a value of one, and we’ll use this ideal curve as a yardstick to measure the merit of various αMax+βMin algorithms. Let’s make sure we know what the solid curve in <a href="#calibre_link-1255">Figure 13-7</a> is telling us. That curve indicates that a unity magnitude vector oriented at an angle of approximately 26 degrees will be estimated by <a href="#calibre_link-1254">Eq. (13-6)</a> to have a magnitude of 1.118 instead of the correct magnitude of one. The error <a id="calibre_link-3223"></a>then, at 26 degrees, is 11.8 percent. For comparison, two other magnitude approximation curves for various values of α and β are shown in <a href="#calibre_link-1255">Figure 13-7</a>.</p>
<p class="calibre3">Although the values for α and β in <a href="#calibre_link-1255">Figure 13-7</a> yield somewhat accurate vector magnitude estimates, there are other values for α and β that deserve our attention because they result in smaller magnitude estimation errors. The α = 15/16 and β = 15/32 solid curve in <a href="#calibre_link-1256">Figure 13-8</a> is an example of a reduced-error algorithm. Multiplications by those values of α and β can be performed by multiplying by 15 and using binary right shifts to implement the divisions by 16 and 32. A mathematically simple, single-multiply, α = 1 and β = 0.4 algorithm is also shown as the dashed curve<a href="#calibre_link-1257">[9]</a>. For the interested reader, the performance of the optimum values for α and β is shown as the <a id="calibre_link-3224"></a>dotted curve in <a href="#calibre_link-1256">Figure 13-8</a>. (The word <em class="calibre7">optimum,</em> as used here, means minimizing the magnitude estimation error fluctuations both above and below the ideal unity line.)</p>
<p class="caption"><a id="calibre_link-1256"></a><strong class="calibre9">Figure 13-8</strong> Alternate αMax+βMin algorithm performance.</p>
<p class="image"><img src="images/001470.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">To add to our catalog of magnitude estimation algorithms, at the expense of an additional multiply/shift and a compare operation, an accurate magnitude estimation scheme is that defined by <a href="#calibre_link-1258">Eq. (13-7)</a><a href="#calibre_link-1259">[10]</a>:</p>
<p class="caption"><a id="calibre_link-1258"></a>(13-7)</p>
<p class="image"><img src="images/000431.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Again, the divisions in <a href="#calibre_link-1258">Eq. (13-7)</a> are implemented as binary right shifts. In a similar vein we mention an algorithm that exhibits a maximum error of a mere 1 percent, when floating-point arithmetic is used, as defined by <a href="#calibre_link-1260">Eq. (13-7′)</a><a href="#calibre_link-1261">[11]</a>:</p>
<p class="caption"><a id="calibre_link-1260"></a>(13-7′)</p>
<p class="image"><img src="images/000157.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The performance curves of the last two magnitude estimation algorithms are shown in <a href="#calibre_link-1262">Figure 13-9</a>.</p>
<p class="caption"><a id="calibre_link-1262"></a><strong class="calibre9">Figure 13-9</strong> Additional αMax+βMin algorithm performance.</p>
<p class="image"><img src="images/000294.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">To summarize the behavior of the magnitude estimation algorithms we just covered so far, the relative performances of the various algorithms are shown in <a href="#calibre_link-1263">Table 13-2</a>. The table lists the magnitude of the algorithms’ maximum error in both percent and decibels. The rightmost column of <a href="#calibre_link-1263">Table 13-2</a> is the mean squared error (MSE) of the algorithms. That MSE value indicates how much the algorithms’ results fluctuate about the ideal result of one, and we’d like to have that MSE value be as close to zero (a flat line) as possible.</p>
<p class="caption"><a id="calibre_link-1263"></a><strong class="calibre9">Table 13-2</strong> αMax+βMin Algorithm Performance Comparisons</p>
<p class="image"><img src="images/001109.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">So, the αMax+βMin algorithms enable high-speed vector magnitude computation without the need for performing square root operations. Of <a id="calibre_link-2277"></a>course, with the availability of floating-point multiplier integrated circuits&mdash;with their ability to multiply in one or two clock cycles&mdash;the α and β coefficients need not always be restricted to multiples of reciprocals of integer powers of two.</p>
<p class="calibre3"><a id="calibre_link-464"></a></p>
<h3 class="calibre6">13.3 Frequency-Domain Windowing</h3>
<p class="calibre3">There’s an interesting technique for minimizing the calculations necessary to implement windowing of FFT input data to reduce spectral leakage. There are times when we need the FFT of unwindowed time-domain data, while at the same time we also want the FFT of that same time-domain data with a window function applied. In this situation, we don’t have to perform two separate FFTs. We can perform the FFT of the unwindowed data, and then we can perform frequency-domain windowing on that FFT result to reduce leakage. Let’s see how.</p>
<p class="calibre3">Recall from <a href="#calibre_link-594">Section 3.9</a> that the expressions for the Hanning and the Hamming windows were <em class="calibre7">w</em><sub class="calibre12">Han</sub>(<em class="calibre7">n</em>) = 0.5 −0.5cos(2π<em class="calibre7">n</em>/<em class="calibre7">N</em>) and <em class="calibre7">w</em><sub class="calibre12">Ham</sub>(<em class="calibre7">n</em>) = 0.54 −0.46cos(2π<em class="calibre7">n</em>/<em class="calibre7">N</em>), respectively, where <em class="calibre7">N</em> is a window sequence length. They both have the general cosine function form of</p>
<p class="caption"><a id="calibre_link-1264"></a>(13-8)</p>
<p class="image"><img src="images/000998.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">for <em class="calibre7">n</em> = 0, 1, 2, ..., <em class="calibre7">N</em>−1. Looking at the frequency response of the general cosine window function, using the definition of the DFT, the transform of <a href="#calibre_link-1264">Eq. (13-8)</a> is</p>
<p class="caption"><a id="calibre_link-3225"></a><a id="calibre_link-1265"></a>(13-9)</p>
<p class="image"><img src="images/001789.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Because <img src="images/001331.jpg" alt="image" class="calibre2" />, <a href="#calibre_link-1265">Eq. (13-9)</a> can be written as</p>
<p class="caption"><a id="calibre_link-1266"></a>(13-10)</p>
<p class="image"><img src="images/000438.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a href="#calibre_link-1266">Equation (13-10)</a> looks pretty complicated, but using the derivation from <a href="#calibre_link-597">Section 3.13</a> for expressions like those summations, we find that <a href="#calibre_link-1266">Eq. (13-10)</a> merely results in the superposition of three sin(<em class="calibre7">x</em>)/<em class="calibre7">x</em> functions in the frequency domain. Their amplitudes are shown in <a href="#calibre_link-1267">Figure 13-10</a>.</p>
<p class="caption"><a id="calibre_link-1267"></a><strong class="calibre9">Figure 13-10</strong> General cosine window frequency response amplitude.</p>
<p class="image"><img src="images/000917.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Notice that the two translated sin(<em class="calibre7">x</em>)/<em class="calibre7">x</em> functions have sidelobes with opposite phase from that of the center sin(<em class="calibre7">x</em>)/<em class="calibre7">x</em> function. This means that <em class="calibre7">N</em>α times the <em class="calibre7">m</em>th bin output, minus <em class="calibre7">N</em>β/2 times the (<em class="calibre7">m</em>−1)th bin output, minus β/2 times the (<em class="calibre7">m</em>+1)th bin output will minimize the sidelobes of the <em class="calibre7">m</em>th bin. This frequency-domain convolution process is equivalent to multiplying the input time data sequence by the <em class="calibre7">N</em>-valued window function <em class="calibre7">w</em>(<em class="calibre7">n</em>) in <a href="#calibre_link-1264">Eq. (13-8)</a>[<a href="#calibre_link-1268">12</a>&ndash;<a href="#calibre_link-1269">14</a>].</p>
<p class="calibre3">For example, let’s say the output of the <em class="calibre7">m</em>th FFT bin is <em class="calibre7">X</em>(<em class="calibre7">m</em>) = <em class="calibre7">a</em><sub class="calibre12">m</sub> + <em class="calibre7">jb</em><sub class="calibre12">m</sub>, and the outputs of its two neighboring bins are <em class="calibre7">X</em>(<em class="calibre7">m</em>−1) = <em class="calibre7">a</em><sub class="calibre12">−1</sub> + <em class="calibre7">jb</em><sub class="calibre12">−1</sub> and <em class="calibre7">X</em>(<em class="calibre7">m</em>+1) = <em class="calibre7">a</em><sub class="calibre12">+1</sub> + <em class="calibre7">jb</em><sub class="calibre12">+1</sub>. Then frequency-domain windowing for the <em class="calibre7">m</em>th bin of the unwindowed <em class="calibre7">X</em>(<em class="calibre7">m</em>) is as follows:</p>
<p class="caption"><a id="calibre_link-1270"></a>(13-11)</p>
<p class="image"><img src="images/000720.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">To compute a windowed <em class="calibre7">N</em>-point FFT, <em class="calibre7">X</em><sub class="calibre12">three-term</sub>(<em class="calibre7">m</em>), we can apply <a href="#calibre_link-1270">Eq. (13-11)</a>, requiring 4<em class="calibre7">N</em> additions and 3<em class="calibre7">N</em> multiplications, to the unwindowed <em class="calibre7">N</em>-point FFT result <em class="calibre7">X</em>(<em class="calibre7">m</em>) and avoid having to perform the <em class="calibre7">N</em> multiplications of time-domain windowing and a second FFT with its <em class="calibre7">N</em>log<sub class="calibre12">2</sub>(<em class="calibre7">N</em>) additions and <a id="calibre_link-3226"></a>2<em class="calibre7">N</em>log<sub class="calibre12">2</sub>(<em class="calibre7">N</em>) multiplications. (In this case, we called our windowed results <em class="calibre7">X</em><sub class="calibre12">three-term</sub>(<em class="calibre7">m</em>) because we’re performing a convolution of a three-term <em class="calibre7">W</em>(<em class="calibre7">m</em>) sequence with the <em class="calibre7">X</em>(<em class="calibre7">m</em>) sequence.)</p>
<p class="calibre3">To accommodate the <em class="calibre7">m</em> = 0 beginning and the <em class="calibre7">m</em> = <em class="calibre7">N</em>−1 end of our <em class="calibre7">N</em>-point FFT, we effectively wrap the FFT samples back on themselves. That is, due to the circular nature of FFT samples based on real-valued time sequences, we use</p>
<p class="caption"><a id="calibre_link-1271"></a>(13-11′)</p>
<p class="image"><img src="images/000066.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">and</p>
<p class="caption"><a id="calibre_link-3227"></a>(13-11″)</p>
<p class="image"><img src="images/000910.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Now if the FFT’s <em class="calibre7">x</em>(<em class="calibre7">n</em>) input sequence is real-only, then <em class="calibre7">X</em>(0) = <em class="calibre7">a</em><sub class="calibre12">0</sub>, and <a href="#calibre_link-1271">Eq. (13-11′)</a> simplifies to a real-only <em class="calibre7">X</em><sub class="calibre12">three-term</sub> (0) = α<em class="calibre7">a</em><sub class="calibre12">0</sub> − β<em class="calibre7">a</em><sub class="calibre12">1</sub>.</p>
<p class="calibre3">The neat situation here is the frequency-domain coefficients, values, α and β, for the Hanning window. They’re both 0.5, and the multiplications in <a href="#calibre_link-1270">Eq. (13-11)</a> can be performed in hardware with two binary right shifts by a single bit for α = 0.5 and two shifts for each of the two β/2 = 0.25 factors, for a total of six binary shifts. If a gain of four is acceptable, we can get away with only two left shifts (one for the real and one for the imaginary parts of <em class="calibre7">X</em>(<em class="calibre7">m</em>)) using</p>
<p class="caption"><a id="calibre_link-3228"></a>(13-12)</p>
<p class="image"><img src="images/001773.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">In <em class="calibre7">application</em>-<em class="calibre7">specific integrated circuit</em> (ASIC) and <em class="calibre7">field-programmable gate array</em> (FPGA) hardware implementations, where multiplies are to be avoided, the binary shifts can be eliminated through hardwired data routing. Thus only additions are necessary to implement frequency-domain Hanning windowing. The issues we need to consider are which window function is best for the application, and the efficiency of available hardware in performing the <a id="calibre_link-2029"></a>frequency-domain multiplications. Frequency-domain Hamming windowing can be implemented but, unfortunately, not with simple binary shifts.</p>
<p class="calibre3">Along with the Hanning and Hamming windows, reference <a href="#calibre_link-1269">[14]</a> describes a family of windows known as <em class="calibre7">Blackman</em> windows that provide further FFT spectral leakage reduction when performing frequency-domain windowing. (Note: Reference <a href="#calibre_link-1269">[14]</a> reportedly has two typographical errors in the 4-Term (−74 dB) window coefficients column on its page 65. Reference <a href="#calibre_link-1272">[15]</a> specifies those coefficients to be 0.40217, 0.49703, 0.09892, and 0.00188.) Blackman windows have five nonzero frequency-domain coefficients, and their use requires the following five-term convolution:</p>
<p class="caption"><a id="calibre_link-3229"></a>(13-13)</p>
<p class="image"><img src="images/000180.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a href="#calibre_link-1273">Table 13-3</a> provides the frequency-domain coefficients for several common window functions.</p>
<p class="caption"><a id="calibre_link-1273"></a><strong class="calibre9">Table 13-3</strong> Frequency-Domain Windowing Coefficients</p>
<p class="image"><img src="images/000088.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Let’s end our discussion of the frequency-domain windowing trick by saying this scheme can be efficient because we don’t have to window the entire set of FFT data; windowing need only be performed on those FFT bin outputs of interest to us. An application of frequency-domain windowing is presented in <a href="#calibre_link-689">Section 13.18</a>.</p>
<p class="calibre3"><a id="calibre_link-679"></a></p>
<h3 class="calibre6">13.4 Fast Multiplication of Complex Numbers</h3>
<p class="calibre3">The multiplication of two complex numbers is one of the most common functions performed in digital signal processing. It’s mandatory in all discrete and fast Fourier transformation algorithms, necessary for graphics transformations, and used in processing digital communications signals. Be it in hardware or software, it’s always to our benefit to streamline the processing <a id="calibre_link-2196"></a>necessary to perform a complex multiply whenever we can. If the available hardware can perform three additions faster than a single multiplication, there’s a way to speed up a complex multiply operation<a href="#calibre_link-1274">[16]</a>.</p>
<p class="calibre3">The multiplication of two complex numbers, <em class="calibre7">a</em> + <em class="calibre7">jb</em> and <em class="calibre7">c</em> + <em class="calibre7">jd</em>, results in the complex product</p>
<p class="caption"><a id="calibre_link-1275"></a>(13-14)</p>
<p class="image"><img src="images/000881.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">We can see that <a href="#calibre_link-1275">Eq. (13-14)</a> requires four multiplications and two additions. (From a computational standpoint we’ll assume a subtraction is equivalent to an addition.) Instead of using <a href="#calibre_link-1275">Eq. (13-14)</a>, we can calculate the following intermediate values:</p>
<p class="caption"><a id="calibre_link-1276"></a>(13-15)</p>
<p class="image"><img src="images/001481.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">We then perform the following operations to get the final <em class="calibre7">R</em> and <em class="calibre7">I</em>:</p>
<p class="caption"><a id="calibre_link-1277"></a>(13-16)</p>
<p class="image"><img src="images/001676.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The reader is invited to plug the <em class="calibre7">k</em> values from <a href="#calibre_link-1276">Eq. (13-15)</a> into <a href="#calibre_link-1277">Eq. (13-16)</a> to verify that the expressions in <a href="#calibre_link-1277">Eq. (13-16)</a> are equivalent to <a href="#calibre_link-1275">Eq. (13-14)</a>. The intermediate values in <a href="#calibre_link-1276">Eq. (13-15)</a> required three additions and three multiplications, while the results in <a href="#calibre_link-1277">Eq. (13-16)</a> required two more additions. So we traded one of the multiplications required in <a href="#calibre_link-1275">Eq. (13-14)</a> for three addition operations needed by <a href="#calibre_link-1276">Eqs. (13-15)</a> and <a href="#calibre_link-1277">(13-16)</a>. If our hardware uses fewer clock cycles to perform three additions than a single multiplication, we may well gain overall processing speed by using <a href="#calibre_link-1276">Eqs. (13-15)</a> and <a href="#calibre_link-1277">(13-16)</a> instead of <a href="#calibre_link-1275">Eq. (13-14)</a> for complex multiplication.</p>
<p class="calibre3"><a id="calibre_link-463"></a></p>
<h3 class="calibre6">13.5 Efficiently Performing the FFT of Real Sequences</h3>
<p class="calibre3">Upon recognizing its linearity property and understanding the odd and even symmetries of the transform’s output, the early investigators of the fast Fourier transform (FFT) realized that two separate, real <em class="calibre7">N</em>-point input data sequences could be transformed using a single <em class="calibre7">N</em>-point complex FFT. They also developed a technique using a single <em class="calibre7">N</em>-point complex FFT to transform a 2<em class="calibre7">N</em>-point real input sequence. Let’s see how these two techniques work.</p>
<p class="calibre3"><a id="calibre_link-3230"></a></p>
<h4 class="calibre13">13.5.1 Performing Two <em class="calibre7">N</em>-Point Real FFTs</h4>
<p class="calibre3">The standard FFT algorithms were developed to accept complex inputs; that is, the FFT’s normal input <em class="calibre7">x</em>(<em class="calibre7">n</em>) sequence is assumed to comprise real and imaginary parts, such as</p>
<p class="caption"><a id="calibre_link-3231"></a><a id="calibre_link-3232"></a>(13-17)</p>
<p class="image"><img src="images/000997.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">In typical signal processing schemes, FFT input data sequences are usually real. The most common example of this is the FFT input samples coming from an A/D converter that provides real integer values of some continuous (analog) signal. In this case the FFT’s imaginary <em class="calibre7">x<sub class="calibre12">i</sub></em>(<em class="calibre7">n</em>)’s inputs are all zero. So initial FFT computations performed on the <em class="calibre7">x<sub class="calibre12">i</sub></em>(<em class="calibre7">n</em>) inputs represent wasted operations. Early FFT pioneers recognized this inefficiency, studied the problem, and developed a technique where two independent <em class="calibre7">N</em>-point, <em class="calibre7">real</em> input data sequences could be transformed by a single <em class="calibre7">N</em>-point complex FFT. We call this scheme the Two <em class="calibre7">N</em>-Point Real FFTs algorithm. The derivation of this technique is straightforward and described in the literature[<a href="#calibre_link-1278">17</a>&ndash;<a href="#calibre_link-1279">19</a>]. If two <em class="calibre7">N</em>-point, real input sequences are <em class="calibre7">a</em>(<em class="calibre7">n</em>) and <em class="calibre7">b</em>(<em class="calibre7">n</em>), they’ll have discrete Fourier transforms represented by <em class="calibre7">X<sub class="calibre12">a</sub></em>(<em class="calibre7">m</em>) and <em class="calibre7">X<sub class="calibre12">b</sub></em>(<em class="calibre7">m</em>). If we treat the <em class="calibre7">a</em>(<em class="calibre7">n</em>) sequence as the real part of an FFT input and the <em class="calibre7">b</em>(<em class="calibre7">n</em>) sequence as the imaginary part of the FFT input, then</p>
<p class="caption"><a id="calibre_link-1280"></a>(13-18)</p>
<p class="image"><img src="images/000281.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Applying the <em class="calibre7">x</em>(<em class="calibre7">n</em>) values from <a href="#calibre_link-1280">Eq. (13-18)</a> to the standard DFT,</p>
<p class="caption"><a id="calibre_link-3233"></a>(13-19)</p>
<p class="image"><img src="images/001123.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">we’ll get a DFT output <em class="calibre7">X</em>(<em class="calibre7">m</em>) where <em class="calibre7">m</em> goes from 0 to <em class="calibre7">N</em>−1. (We’re assuming, of course, that the DFT is implemented by way of an FFT algorithm.) Using the superscript “*” symbol to represent the complex conjugate, we can extract the two desired FFT outputs <em class="calibre7">X<sub class="calibre12">a</sub></em>(<em class="calibre7">m</em>) and <em class="calibre7">X<sub class="calibre12">b</sub></em>(<em class="calibre7">m</em>) from <em class="calibre7">X</em>(<em class="calibre7">m</em>) by using the following:</p>
<p class="caption"><a id="calibre_link-1281"></a>(13-20)</p>
<p class="image"><img src="images/001012.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">and</p>
<p class="caption"><a id="calibre_link-1282"></a>(13-21)</p>
<p class="image"><img src="images/000060.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3234"></a>Let’s break <a href="#calibre_link-1281">Eqs. (13-20)</a> and <a href="#calibre_link-1282">(13-21)</a> into their real and imaginary parts to get expressions for <em class="calibre7">X<sub class="calibre12">a</sub></em>(<em class="calibre7">m</em>) and <em class="calibre7">X<sub class="calibre12">b</sub></em>(<em class="calibre7">m</em>) that are easier to understand and implement. Using the notation showing <em class="calibre7">X</em>(<em class="calibre7">m</em>)’s real and imaginary parts, where <em class="calibre7">X</em>(<em class="calibre7">m</em>) = <em class="calibre7">X<sub class="calibre12">r</sub></em>(<em class="calibre7">m</em>) + <em class="calibre7">jX<sub class="calibre12">i</sub></em>(<em class="calibre7">m</em>), we can rewrite <a href="#calibre_link-1281">Eq. (13-20)</a> as</p>
<p class="caption"><a id="calibre_link-1287"></a>(13-22)</p>
<p class="image"><img src="images/000905.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where <em class="calibre7">m</em> = 1, 2, 3, . . ., <em class="calibre7">N</em>−1. What about the first <em class="calibre7">X<sub class="calibre12">a</sub></em>(<em class="calibre7">m</em>), when <em class="calibre7">m</em> = 0? Well, this is where we run into a bind if we actually try to implement <a href="#calibre_link-1281">Eq. (13-20)</a> directly. Letting <em class="calibre7">m</em> = 0 in <a href="#calibre_link-1281">Eq. (13-20)</a>, we quickly realize that the first term in the numerator, <em class="calibre7">X*</em>(<em class="calibre7">N</em>−0) = <em class="calibre7">X*</em>(<em class="calibre7">N</em>), isn’t available because the <em class="calibre7">X</em>(<em class="calibre7">N</em>) sample does not exist in the output of an <em class="calibre7">N</em>-point FFT! We resolve this problem by remembering that <em class="calibre7">X</em>(<em class="calibre7">m</em>) is periodic with a period <em class="calibre7">N</em>, so <em class="calibre7">X</em>(<em class="calibre7">N</em>) = <em class="calibre7">X</em>(0).<sup class="calibre10"><a id="calibre_link-1284"></a><a href="#calibre_link-1283">†</a></sup> When <em class="calibre7">m</em> = 0, <a href="#calibre_link-1281">Eq. (13-20)</a> becomes</p>
<p class="footnotes"><a id="calibre_link-1283"></a><sup class="calibre11"><a href="#calibre_link-1284">†</a></sup> This fact is illustrated in <a href="#calibre_link-461">Section 3.8</a> during the discussion of spectral leakage in DFTs.</p>
<p class="caption"><a id="calibre_link-1285"></a>(13-23)</p>
<p class="image"><img src="images/001424.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Next, simplifying <a href="#calibre_link-1282">Eq. (13-21)</a>,</p>
<p class="caption"><a id="calibre_link-1286"></a>(13-24)</p>
<p class="image"><img src="images/000790.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where, again, <em class="calibre7">m</em> = 1, 2, 3, . . ., <em class="calibre7">N</em>−1. By the same argument used for <a href="#calibre_link-1285">Eq. (13-23)</a>, when <em class="calibre7">m</em> = 0, <em class="calibre7">X<sub class="calibre12">b</sub></em>(0) in <a href="#calibre_link-1286">Eq. (13-24)</a> becomes</p>
<p class="caption"><a id="calibre_link-1288"></a>(13-25)</p>
<p class="image"><img src="images/001645.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">This discussion brings up a good point for beginners to keep in mind. In the literature <a href="#calibre_link-1281">Eqs. (13-20)</a> and <a href="#calibre_link-1282">(13-21)</a> are often presented without any discussion of the <em class="calibre7">m</em> = 0 problem. So, whenever you’re grinding through an algebraic derivation or have some equations tossed out at you, be a little skeptical. Try the equations out on an example&mdash;see if they’re true. (After all, both authors and book typesetters are human and sometimes make mistakes. We had an old saying in Ohio for this situation: “Trust everybody, but cut the cards.”) Following this advice, let’s prove that this Two <em class="calibre7">N</em>-Point Real FFTs algorithm really does work by applying the 8-point data sequences from <a href="#calibre_link-134">Chapter 3</a>’s <a id="calibre_link-3235"></a>DFT examples to <a href="#calibre_link-1287">Eqs. (13-22)</a> through <a href="#calibre_link-1288">(13-25)</a>. Taking the 8-point input data sequence from <a href="#calibre_link-457">Section 3.1</a>’s DFT Example 1 and denoting it <em class="calibre7">a</em>(<em class="calibre7">n</em>),</p>
<p class="caption"><a id="calibre_link-1289"></a>(13-26)</p>
<p class="image"><img src="images/000132.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Taking the 8-point input data sequence from <a href="#calibre_link-113">Section 3.6</a>’s DFT Example 2 and calling it <em class="calibre7">b</em>(<em class="calibre7">n</em>),</p>
<p class="caption"><a id="calibre_link-1290"></a>(13-27)</p>
<p class="image"><img src="images/001531.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Combining the sequences in <a href="#calibre_link-1289">Eqs. (13-26)</a> and <a href="#calibre_link-1290">(13-27)</a> into a single complex sequence <em class="calibre7">x</em>(<em class="calibre7">n</em>),</p>
<p class="caption"><a id="calibre_link-1291"></a>(13-28)</p>
<p class="image"><img src="images/000663.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Now, taking the 8-point FFT of the complex sequence in <a href="#calibre_link-1291">Eq. (13-28)</a>, we get</p>
<p class="caption"><a id="calibre_link-1294"></a>(13-29)</p>
<p class="image"><img src="images/001418.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">So from <a href="#calibre_link-1285">Eq. (13-23)</a>,</p>
<p class="center">X<em class="calibre7"><sub class="calibre12">a</sub></em>(0) = X<em class="calibre7"><sub class="calibre12">r</sub></em>(0) = 0.</p>
<p class="calibre3"><a id="calibre_link-3236"></a>To get the rest of <em class="calibre7">X<sub class="calibre12">a</sub></em>(<em class="calibre7">m</em>), we have to plug the FFT output’s <em class="calibre7">X</em>(<em class="calibre7">m</em>) and <em class="calibre7">X</em>(<em class="calibre7">N</em>−<em class="calibre7">m</em>) values into <a href="#calibre_link-1287">Eq. (13-22)</a>.<sup class="calibre10"><a id="calibre_link-1293"></a><a href="#calibre_link-1292">†</a></sup> Doing so,</p>
<p class="footnotes"><a id="calibre_link-1292"></a><sup class="calibre11"><a href="#calibre_link-1293">†</a></sup> Remember, when the FFT’s input is complex, the FFT outputs may not be conjugate symmetric; that is, we can’t assume that <em class="calibre7">F</em>(<em class="calibre7">m</em>) is equal to <em class="calibre7">F</em>*(<em class="calibre7">N−m</em>) when the FFT input sequence’s real and imaginary parts are both nonzero.</p>
<p class="image"><img src="images/000456.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">So <a href="#calibre_link-1287">Eq. (13-22)</a> really does extract <em class="calibre7">X<sub class="calibre12">a</sub></em>(<em class="calibre7">m</em>) from the <em class="calibre7">X</em>(<em class="calibre7">m</em>) sequence in <a href="#calibre_link-1294">Eq. (13-29)</a>. We can see that we need not solve <a href="#calibre_link-1287">Eq. (13-22)</a> when <em class="calibre7">m</em> is greater than 4 (or <em class="calibre7">N</em>/2) because <em class="calibre7">X<sub class="calibre12">a</sub></em>(<em class="calibre7">m</em>) will always be conjugate symmetric. Because <a id="calibre_link-3237"></a><em class="calibre7">X<sub class="calibre12">a</sub></em>(7) = <em class="calibre7">X<sub class="calibre12">a</sub></em>(1), <em class="calibre7">X<sub class="calibre12">a</sub></em>(6) = <em class="calibre7">X<sub class="calibre12">a</sub></em>(2), etc., only the first <em class="calibre7">N</em>/2 elements in <em class="calibre7">X<sub class="calibre12">a</sub></em>(<em class="calibre7">m</em>) are independent and need be calculated.</p>
<p class="calibre3">OK, let’s keep going and use <a href="#calibre_link-1286">Eqs. (13-24)</a> and <a href="#calibre_link-1288">(13-25)</a> to extract <em class="calibre7">X<sub class="calibre12">b</sub></em>(<em class="calibre7">m</em>) from the FFT output. From <a href="#calibre_link-1288">Eq. (13-25)</a>,</p>
<p class="center">X<em class="calibre7"><sub class="calibre12">b</sub></em>(0) = X<em class="calibre7"><sub class="calibre12">i</sub></em>(0) = 0.</p>
<p class="calibre3">Plugging the FFT’s output values into <a href="#calibre_link-1286">Eq. (13-24)</a> to get the next four <em class="calibre7">X<sub class="calibre12">b</sub></em>(<em class="calibre7">m</em>)s, we have</p>
<p class="image"><img src="images/001313.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The question arises “With the additional processing required by <a href="#calibre_link-1287">Eqs. (13-22)</a> and <a href="#calibre_link-1286">(13-24)</a> after the initial FFT, how much computational saving (or loss) is to be had by this Two <em class="calibre7">N</em>-Point Real FFTs algorithm?” We can estimate the efficiency of this algorithm by considering the number of arithmetic operations required relative to two separate <em class="calibre7">N</em>-point radix-2 FFTs. First, we estimate the number of arithmetic operations in two separate <em class="calibre7">N</em>-point complex FFTs.</p>
<p class="calibre3">From <a href="#calibre_link-604">Section 4.6</a>, we know that a standard radix-2 <em class="calibre7">N</em>-point complex FFT comprises (<em class="calibre7">N</em>/2) · log<sub class="calibre12">2</sub><em class="calibre7">N</em> butterfly operations. If we use the optimized butterfly structure, each butterfly requires one complex multiplication and two complex additions. Now, one complex multiplication requires two real additions and four real multiplications, and one complex addition requires two real additions.<sup class="calibre10"><a id="calibre_link-1296"></a><a href="#calibre_link-1295">†</a></sup> So a single FFT butterfly operation comprises four real multiplications <a id="calibre_link-3238"></a>and six real additions. This means that a single <em class="calibre7">N</em>-point complex FFT requires (4<em class="calibre7">N</em>/2) · log<sub class="calibre12">2</sub><em class="calibre7">N</em> real multiplications, and (6<em class="calibre7">N</em>/2) · log<sub class="calibre12">2</sub><em class="calibre7">N</em> real additions. Finally, we can say that two separate <em class="calibre7">N</em>-point complex radix-2 FFTs require</p>
<p class="footnotes"><a id="calibre_link-1295"></a><sup class="calibre11"><a href="#calibre_link-1296">†</a></sup> The complex addition (<em class="calibre7">a</em>+<em class="calibre7">jb</em>) + (<em class="calibre7">c</em>+<em class="calibre7">jd</em>) = (<em class="calibre7">a</em>+<em class="calibre7">c</em>) + <em class="calibre7">j</em>(<em class="calibre7">b</em>+<em class="calibre7">d</em>) requires two real additions. A complex multiplication (<em class="calibre7">a</em>+<em class="calibre7">jb</em>) · (<em class="calibre7">c</em>+<em class="calibre7">jd</em>) = <em class="calibre7">ac</em>−<em class="calibre7">bd</em> + <em class="calibre7">j</em>(<em class="calibre7">ad</em>+<em class="calibre7">bc</em>) requires two real additions and four real multiplications.</p>
<p class="caption"><a id="calibre_link-1299"></a>(13-30)</p>
<p class="image"><img src="images/001193.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-1302"></a>(13-30′)</p>
<p class="image"><img src="images/000234.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Next, we need to determine the computational workload of the Two <em class="calibre7">N</em>-Point Real FFTs algorithm. If we add up the number of real multiplications and real additions required by the algorithm’s <em class="calibre7">N</em>-point complex FFT, plus those required by <a href="#calibre_link-1287">Eq. (13-22)</a> to get <em class="calibre7">X<sub class="calibre12">a</sub></em>(<em class="calibre7">m</em>), and those required by <a href="#calibre_link-1286">Eq. (13-24)</a> to get <em class="calibre7">X<sub class="calibre12">b</sub></em>(<em class="calibre7">m</em>), the Two <em class="calibre7">N</em>-Point Real FFTs algorithm requires</p>
<p class="caption"><a id="calibre_link-1297"></a>(13-31)</p>
<p class="image"><img src="images/001657.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-1298"></a>(13-31′)</p>
<p class="image"><img src="images/001507.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a href="#calibre_link-1297">Equations (13-31)</a> and <a href="#calibre_link-1298">(13-31′)</a> assume that we’re calculating only the first <em class="calibre7">N</em>/2 independent elements of <em class="calibre7">X<sub class="calibre12">a</sub></em>(<em class="calibre7">m</em>) and <em class="calibre7">X<sub class="calibre12">b</sub></em>(<em class="calibre7">m</em>). The single <em class="calibre7">N</em> term in <a href="#calibre_link-1297">Eq. (13-31)</a> accounts for the <em class="calibre7">N</em>/2 divide by 2 operations in <a href="#calibre_link-1287">Eq. (13-22)</a> and the <em class="calibre7">N</em>/2 divide by 2 operations in <a href="#calibre_link-1286">Eq. (13-24)</a>.</p>
<p class="calibre3">OK, now we can find out how efficient the Two <em class="calibre7">N</em>-Point Real FFTs algorithm is compared to two separate complex <em class="calibre7">N</em>-point radix-2 FFTs. This comparison, however, depends on the hardware used for the calculations. If our arithmetic hardware takes many more clock cycles to perform a multiplication than an addition, then the difference between multiplications in <a href="#calibre_link-1299">Eqs. (13-30)</a> and <a href="#calibre_link-1297">(13-31)</a> is the most important comparison. In this case, the percentage gain in computational saving of the Two <em class="calibre7">N</em>-Point Real FFTs algorithm relative to two separate <em class="calibre7">N</em>-point complex FFTs is the difference in their necessary multiplications over the number of multiplications needed for two separate <em class="calibre7">N</em>-point complex FFTs, or</p>
<p class="caption"><a id="calibre_link-1300"></a>(13-32)</p>
<p class="image"><img src="images/000196.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The computational (multiplications only) saving from <a href="#calibre_link-1300">Eq. (13-32)</a> is plotted as the top curve of <a href="#calibre_link-1301">Figure 13-11</a>. In terms of multiplications, for <em class="calibre7">N</em>≥32, the Two <em class="calibre7">N</em>-Point Real FFTs algorithm saves us over 45 percent in computational workload compared to two separate <em class="calibre7">N</em>-point complex FFTs.</p>
<p class="caption"><a id="calibre_link-1301"></a><strong class="calibre9">Figure 13-11</strong> Computational saving of the Two <em class="calibre7">N</em>-Point Real FFTs algorithm over that of two separate <em class="calibre7">N</em>-point complex FFTs. The top curve indicates the saving when only multiplications are considered. The bottom curve is the saving when both additions and multiplications are used in the comparison.</p>
<p class="image"><img src="images/000240.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">For hardware using high-speed multiplier integrated circuits, multiplication and addition can take roughly equivalent clock cycles. This makes addition operations just as important and time consuming as multiplications. Thus the difference between those combined arithmetic operations in <a href="#calibre_link-1299">Eqs. (13-30)</a> <a id="calibre_link-3239"></a>plus <a href="#calibre_link-1302">(13-30′)</a> and <a href="#calibre_link-1297">Eqs. (13-31)</a> plus <a href="#calibre_link-1298">(13-31′)</a> is the appropriate comparison. In this case, the percentage gain in computational saving of our algorithm over two FFTs is their total arithmetic operational difference over the total arithmetic operations in two separate <em class="calibre7">N</em>-point complex FFTs, or</p>
<p class="caption"><a id="calibre_link-1303"></a>(13-33)</p>
<p class="image"><img src="images/000107.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The full computational (multiplications and additions) saving from <a href="#calibre_link-1303">Eq. (13-33)</a> is plotted as the bottom curve of <a href="#calibre_link-1301">Figure 13-11</a>. This concludes our discussion and illustration of how a single <em class="calibre7">N</em>-point complex FFT can be used to transform two separate <em class="calibre7">N</em>-point real input data sequences.</p>
<p class="calibre3"><a id="calibre_link-332"></a></p>
<h4 class="calibre13">13.5.2 Performing a 2<em class="calibre7">N</em>-Point Real FFT</h4>
<p class="calibre3">Similar to the scheme above where two separate <em class="calibre7">N</em>-point real data sequences are transformed using a single <em class="calibre7">N</em>-point FFT, a technique exists where a 2<em class="calibre7">N</em>-point real sequence can be transformed with a single complex <em class="calibre7">N</em>-point FFT. This 2<em class="calibre7">N</em>-Point Real FFT algorithm, whose derivation is also <a id="calibre_link-2195"></a>described in the literature, requires that the 2<em class="calibre7">N</em>-sample real input sequence be separated into two parts[<a href="#calibre_link-1279">19</a>,<a href="#calibre_link-1304">20</a>]&mdash;not broken in two, but unzipped&mdash;separating the even and odd sequence samples. The <em class="calibre7">N</em> even-indexed input samples are loaded into the real part of a complex <em class="calibre7">N</em>-point input sequence <em class="calibre7">x</em>(<em class="calibre7">n</em>). Likewise, the input’s <em class="calibre7">N</em> odd-indexed samples are loaded into <em class="calibre7">x</em>(<em class="calibre7">n</em>)’s imaginary parts. To illustrate this process, let’s say we have a 2<em class="calibre7">N</em>-sample real input data sequence <em class="calibre7">a</em>(<em class="calibre7">n</em>) where 0 ≤ <em class="calibre7">n</em> ≤ 2<em class="calibre7">N</em>−1. We want <em class="calibre7">a</em>(<em class="calibre7">n</em>)’s 2<em class="calibre7">N</em>-point transform <em class="calibre7">X<sub class="calibre12">a</sub></em>(<em class="calibre7">m</em>). Loading <em class="calibre7">a</em>(<em class="calibre7">n</em>)’s odd/even sequence values appropriately into an <em class="calibre7">N</em>-point complex FFT’s input sequence, <em class="calibre7">x</em>(<em class="calibre7">n</em>),</p>
<p class="caption"><a id="calibre_link-1305"></a>(13-34)</p>
<p class="image"><img src="images/000946.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Applying the <em class="calibre7">N</em> complex values in <a href="#calibre_link-1305">Eq. (13-34)</a> to an <em class="calibre7">N</em>-point complex FFT, we’ll get an FFT output <em class="calibre7">X</em>(<em class="calibre7">m</em>) = <em class="calibre7">X<sub class="calibre12">r</sub></em>(<em class="calibre7">m</em>) + <em class="calibre7">jX<sub class="calibre12">i</sub></em>(<em class="calibre7">m</em>), where <em class="calibre7">m</em> goes from 0 to <em class="calibre7">N</em>−1. To extract the desired 2<em class="calibre7">N</em>-Point Real FFT algorithm output <em class="calibre7">X<sub class="calibre12">a</sub></em>(<em class="calibre7">m</em>) = <em class="calibre7">X<sub class="calibre12">a</sub></em><sub class="calibre12">,real</sub>(<em class="calibre7">m</em>) + <em class="calibre7">jX<sub class="calibre12">a</sub></em><sub class="calibre12">,imag</sub>(<em class="calibre7">m</em>) from <em class="calibre7">X</em>(<em class="calibre7">m</em>), let’s define the following relationships:</p>
<p class="caption"><a id="calibre_link-1306"></a>(13-35)</p>
<p class="image"><img src="images/001810.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-3240"></a>(13-36)</p>
<p class="image"><img src="images/000897.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-3241"></a>(13-37)</p>
<p class="image"><img src="images/001696.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-1307"></a>(13-38)</p>
<p class="image"><img src="images/000717.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">For the reasons presented following <a href="#calibre_link-1287">Eq. (13-22)</a> in the last section, in the above expressions recall that <em class="calibre7">X<sub class="calibre12">r</sub></em>(<em class="calibre7">N</em>) = <em class="calibre7">X<sub class="calibre12">r</sub></em>(0), and <em class="calibre7">X<sub class="calibre12">i</sub></em>(<em class="calibre7">N</em>) = <em class="calibre7">X<sub class="calibre12">i</sub></em>(0). The values resulting from <a href="#calibre_link-1306">Eqs. (13-35)</a> through <a href="#calibre_link-1307">(13-38)</a> are, then, used as factors in the following expressions to obtain the real and imaginary parts of our final <em class="calibre7">X<sub class="calibre12">a</sub></em>(<em class="calibre7">m</em>):</p>
<p class="caption"><a id="calibre_link-1311"></a>(13-39)</p>
<p class="image"><img src="images/000958.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">and</p>
<p class="caption"><a id="calibre_link-1312"></a>(13-40)</p>
<p class="image"><img src="images/001459.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3242"></a>Remember, now, the original <em class="calibre7">a</em>(<em class="calibre7">n</em>) input index <em class="calibre7">n</em> goes from 0 to 2<em class="calibre7">N</em>−1, and our <em class="calibre7">N</em>-point FFT output index <em class="calibre7">m</em> goes from 0 to <em class="calibre7">N</em>−1. We apply 2<em class="calibre7">N</em> real input time-domain samples to this algorithm and get back <em class="calibre7">N</em> complex frequency-domain samples representing the first half of the equivalent 2<em class="calibre7">N</em>-point complex FFT, <em class="calibre7">X<sub class="calibre12">a</sub></em>(0) through <em class="calibre7">X<sub class="calibre12">a</sub></em>(<em class="calibre7">N</em>−1). Because this algorithm’s <em class="calibre7">a</em>(<em class="calibre7">n</em>) input is constrained to be real, <em class="calibre7">X<sub class="calibre12">a</sub></em>(<em class="calibre7">N</em>+1) through <em class="calibre7">X<sub class="calibre12">a</sub></em>(2<em class="calibre7">N</em>−1) are merely the complex conjugates of their <em class="calibre7">X<sub class="calibre12">a</sub></em>(1) through <em class="calibre7">X<sub class="calibre12">a</sub></em>(<em class="calibre7">N</em>−1) counterparts and need not be calculated.</p>
<p class="calibre3">The above process does not compute the <em class="calibre7">X<sub class="calibre12">a</sub></em>(<em class="calibre7">N</em>) sample. The <em class="calibre7">X<sub class="calibre12">a</sub></em>(<em class="calibre7">N</em>) sample, which is real-only, is</p>
<p class="caption"><a id="calibre_link-3243"></a>(13-40′)</p>
<p class="image"><img src="images/000499.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">To help us keep all of this straight, <a href="#calibre_link-1308">Figure 13-12</a> depicts the computational steps of the 2<em class="calibre7">N</em>-Point Real FFT algorithm.</p>
<p class="caption"><a id="calibre_link-1308"></a><strong class="calibre9">Figure 13-12</strong> Computational flow of the 2<em class="calibre7">N</em>-Point Real FFT algorithm.</p>
<p class="image"><img src="images/000524.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">To demonstrate this process by way of example, let’s apply the 8-point data sequence from <a href="#calibre_link-1289">Eq. (13-26)</a> to the 2<em class="calibre7">N</em>-Point Real FFT algorithm. Partitioning those <a href="#calibre_link-1289">Eq. (13-26)</a>, samples as dictated by <a href="#calibre_link-1305">Eq. (13-34)</a>, we have our new FFT input sequence:</p>
<p class="caption"><a id="calibre_link-1309"></a>(13-41)</p>
<p class="image"><img src="images/001361.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">With <em class="calibre7">N</em> = 4 in this example, taking the 4-point FFT of the complex sequence in <a href="#calibre_link-1309">Eq. (13-41)</a>, we get</p>
<p class="caption"><a id="calibre_link-3244"></a>(13-42)</p>
<p class="image"><img src="images/000392.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Using these values, we now get the intermediate factors from <a href="#calibre_link-1306">Eqs. (13-35)</a> through <a href="#calibre_link-1307">(13-38)</a>. Calculating our first <em class="calibre7">X<sub class="calibre12">r</sub><sup class="calibre10">+</sup></em>(0) value, again we’re reminded that <em class="calibre7">X</em>(<em class="calibre7">m</em>) is periodic with a period <em class="calibre7">N</em>, so <em class="calibre7">X</em>(4) = <em class="calibre7">X</em>(0), and <em class="calibre7">X<sub class="calibre12">r</sub><sup class="calibre10">+</sup></em>(0) = [<em class="calibre7">X<sub class="calibre12">r</sub></em> (0) + <em class="calibre7">X<sub class="calibre12">r</sub></em> (0)]/2 = 0. Continuing to use <a href="#calibre_link-1306">Eqs. (13-35)</a> through <a href="#calibre_link-1307">(13-38)</a>,</p>
<p class="caption"><a id="calibre_link-3245"></a><a id="calibre_link-1310"></a>(13-43)</p>
<p class="image"><img src="images/001243.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Using the intermediate values from <a href="#calibre_link-1310">Eq. (13-43)</a> in <a href="#calibre_link-1311">Eqs. (13-39)</a> and <a href="#calibre_link-1312">(13-40)</a>,</p>
<p class="caption"><a id="calibre_link-1313"></a>(13-44)</p>
<p class="image"><img src="images/000283.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Evaluating the sine and cosine terms in <a href="#calibre_link-1313">Eq. (13-44)</a>,</p>
<p class="caption"><a id="calibre_link-1314"></a>(13-45)</p>
<p class="image"><img src="images/001125.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Combining the results of the terms in <a href="#calibre_link-1314">Eq. (13-45)</a>, we have our final correct answer of</p>
<p class="caption"><a id="calibre_link-3246"></a>(13-46)</p>
<p class="image"><img src="images/000172.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3247"></a>After going through all the steps required by <a href="#calibre_link-1306">Eqs. (13-35)</a> through <a href="#calibre_link-1312">(13-40)</a>, the reader might question the efficiency of this 2<em class="calibre7">N</em>-Point Real FFT algorithm. Using the same process as the above Two <em class="calibre7">N</em>-Point Real FFTs algorithm analysis, let’s show that the 2<em class="calibre7">N</em>-Point Real FFT algorithm does provide some modest computational saving. First, we know that a single 2<em class="calibre7">N</em>-point radix-2 FFT has (2<em class="calibre7">N</em>/2) · log<sub class="calibre12">2</sub>2<em class="calibre7">N</em> = <em class="calibre7">N</em> · (log<sub class="calibre12">2</sub><em class="calibre7">N</em>+1) butterflies and requires</p>
<p class="caption"><a id="calibre_link-1317"></a>(13-47)</p>
<p class="image"><img src="images/001811.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">and</p>
<p class="caption"><a id="calibre_link-1318"></a>(13-47′)</p>
<p class="image"><img src="images/000598.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">If we add up the number of real multiplications and real additions required by the algorithm’s <em class="calibre7">N</em>-point complex FFT, plus those required by <a href="#calibre_link-1306">Eqs. (13-35)</a> through <a href="#calibre_link-1307">(13-38)</a> and those required by <a href="#calibre_link-1311">Eqs. (13-39)</a> and <a href="#calibre_link-1312">(13-40)</a>, the complete 2<em class="calibre7">N</em>-Point Real FFT algorithm requires</p>
<p class="caption"><a id="calibre_link-1319"></a>(13-48)</p>
<p class="image"><img src="images/000907.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">and</p>
<p class="caption"><a id="calibre_link-1320"></a>(13-48′)</p>
<p class="image"><img src="images/001767.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">OK, using the same hardware considerations (multiplications only) we used to arrive at <a href="#calibre_link-1300">Eq. (13-32)</a>, the percentage gain in multiplication saving of the 2<em class="calibre7">N</em>-Point Real FFT algorithm relative to a 2<em class="calibre7">N</em>-point complex FFT is</p>
<p class="caption"><a id="calibre_link-1315"></a>(13-49)</p>
<p class="image"><img src="images/000792.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The computational (multiplications only) saving from <a href="#calibre_link-1315">Eq. (13-49)</a> is plotted as the bottom curve of <a href="#calibre_link-1316">Figure 13-13</a>. In terms of multiplications, the 2<em class="calibre7">N</em>-Point Real FFT algorithm provides a saving of &gt;30 percent when <em class="calibre7">N</em> ≥ 128 or whenever we transform input data sequences whose lengths are ≥256.</p>
<p class="caption"><a id="calibre_link-1316"></a><strong class="calibre9">Figure 13-13</strong> Computational saving of the 2<em class="calibre7">N</em>-Point Real FFT algorithm over that of a single 2<em class="calibre7">N</em>-point complex FFT. The top curve is the saving when both additions and multiplications are used in the comparison. The bottom curve indicates the saving when only multiplications are considered.</p>
<p class="image"><img src="images/001274.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Again, for hardware using high-speed multipliers, we consider both multiplication and addition operations. The difference between those combined arithmetic operations in <a href="#calibre_link-1317">Eqs. (13-47)</a> plus <a href="#calibre_link-1318">(13-47′)</a> and <a href="#calibre_link-1319">Eqs. (13-48)</a> <a id="calibre_link-2187"></a>plus <a href="#calibre_link-1320">(13-48′)</a> is the appropriate comparison. In this case, the percentage gain in computational saving of our algorithm is</p>
<p class="caption"><a id="calibre_link-1321"></a>(13-50)</p>
<p class="image"><img src="images/000674.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The full computational (multiplications and additions) saving from <a href="#calibre_link-1321">Eq. (13-50)</a> is plotted as a function of <em class="calibre7">N</em> in the top curve of <a href="#calibre_link-1316">Figure 13-13</a>.</p>
<p class="calibre3"><a id="calibre_link-680"></a></p>
<h3 class="calibre6">13.6 Computing the Inverse FFT Using the Forward FFT</h3>
<p class="calibre3">There are many signal processing applications where the capability to perform the inverse FFT is necessary. This can be a problem if available hardware, or software routines, have only the capability to perform the <em class="calibre7">forward</em> FFT. Fortunately, there are two slick ways to perform the inverse FFT using the forward FFT algorithm.</p>
<p class="calibre3"><a id="calibre_link-3248"></a></p>
<h4 class="calibre13"><a id="calibre_link-3249"></a>13.6.1 Inverse FFT Method 1</h4>
<p class="calibre3">The first inverse FFT calculation scheme is implemented following the processes shown in <a href="#calibre_link-1322">Figure 13-14</a>.</p>
<p class="caption"><a id="calibre_link-1322"></a><strong class="calibre9">Figure 13-14</strong> Processing for first inverse FFT calculation method.</p>
<p class="image"><img src="images/000312.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">To see how this works, consider the expressions for the forward and inverse DFTs. They are</p>
<p class="caption"><a id="calibre_link-1323"></a>(13-51)</p>
<p class="image"><img src="images/000746.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-1324"></a>(13-52)</p>
<p class="image"><img src="images/000800.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">To reiterate our goal, we want to use the process in <a href="#calibre_link-1323">Eq. (13-51)</a> to implement <a href="#calibre_link-1324">Eq. (13-52)</a>. The first step of our approach is to use complex conjugation. Remember, conjugation (represented by the superscript “*” symbol) is the reversal of the sign of a complex number’s imaginary exponent&mdash;if <em class="calibre7">x</em> = <em class="calibre7">e<sup class="calibre10">j</sup></em><sup class="calibre10">ø</sup>, then <em class="calibre7">x</em>* = <em class="calibre7">e</em><sup class="calibre10">−<em class="calibre7">j</em>ø</sup>. So, as a first step we take the complex conjugate of both sides of <a href="#calibre_link-1324">Eq. (13-52)</a> to give us</p>
<p class="caption"><a id="calibre_link-1325"></a>(13-53)</p>
<p class="image"><img src="images/001422.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">One of the properties of complex numbers, discussed in <a href="#calibre_link-293">Appendix A</a>, is that the conjugate of a product is equal to the product of the conjugates. That is, if <em class="calibre7">c</em> = <em class="calibre7">ab,</em> then <em class="calibre7">c</em>* = (<em class="calibre7">ab</em>)* = <em class="calibre7">a</em>*<em class="calibre7">b</em>*. Using this, we can show the conjugate of the right side of <a href="#calibre_link-1325">Eq. (13-53)</a> to be</p>
<p class="caption"><a id="calibre_link-1326"></a>(13-54)</p>
<p class="image"><img src="images/000458.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Hold on; we’re almost there. Notice the similarity of <a href="#calibre_link-1326">Eq. (13-54)</a> to our original forward DFT expression, <a href="#calibre_link-1323">Eq. (13-51)</a>. If we perform a forward DFT <a id="calibre_link-3250"></a>on the conjugate of the <em class="calibre7">X</em>(<em class="calibre7">m</em>) in <a href="#calibre_link-1326">Eq. (13-54)</a>, and divide the results by <em class="calibre7">N</em>, we get the conjugate of our desired time samples <em class="calibre7">x</em>(<em class="calibre7">n</em>). Taking the conjugate of both sides of <a href="#calibre_link-1326">Eq. (13-54)</a>, we get a more straightforward expression for <em class="calibre7">x</em>(<em class="calibre7">n</em>):</p>
<p class="caption"><a id="calibre_link-3251"></a>(13-55)</p>
<p class="image"><img src="images/001315.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3252"></a></p>
<h4 class="calibre13">13.6.2 Inverse FFT Method 2</h4>
<p class="calibre3">The second inverse FFT calculation technique is implemented following the interesting data flow shown in <a href="#calibre_link-1327">Figure 13-15</a>.</p>
<p class="caption"><a id="calibre_link-1327"></a><strong class="calibre9">Figure 13-15</strong> Processing for second inverse FFT calculation method.</p>
<p class="image"><img src="images/001153.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">In this clever inverse FFT scheme we don’t bother with conjugation. Instead, we merely swap the real and imaginary parts of sequences of complex data<a href="#calibre_link-1328">[21]</a>. To see why this process works, let’s look at the inverse DFT equation again while separating the input <em class="calibre7">X</em>(<em class="calibre7">m</em>) term into its real and imaginary parts and remembering that <em class="calibre7">e<sup class="calibre10">j</sup></em><sup class="calibre10">ø</sup> = cos(ø) + <em class="calibre7">j</em>sin(ø).</p>
<p class="caption"><a id="calibre_link-1329"></a>(13-56)</p>
<p class="image"><img src="images/000352.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Multiplying the complex terms in <a href="#calibre_link-1329">Eq. (13-56)</a> gives us</p>
<p class="caption"><a id="calibre_link-1330"></a>(13-57)</p>
<p class="image"><img src="images/001196.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a href="#calibre_link-1330">Equation (13-57)</a> is the general expression for the inverse DFT, and we’ll now quickly show that the process in <a href="#calibre_link-1327">Figure 13-15</a> implements this equation. With <em class="calibre7">X</em>(<em class="calibre7">m</em>) = <em class="calibre7">X</em><sub class="calibre12">real</sub>(<em class="calibre7">m</em>) + <em class="calibre7">jX</em><sub class="calibre12">imag</sub>(<em class="calibre7">m</em>), then swapping these terms gives us</p>
<p class="caption"><a id="calibre_link-3253"></a>(13-58)</p>
<p class="image"><img src="images/000863.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The forward DFT of our <em class="calibre7">X</em><sub class="calibre12">swap</sub>(<em class="calibre7">m</em>) is</p>
<p class="caption"><a id="calibre_link-1331"></a>(13-59)</p>
<p class="image"><img src="images/000267.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2268"></a>Multiplying the complex terms in <a href="#calibre_link-1331">Eq. (13-59)</a> gives us</p>
<p class="caption"><a id="calibre_link-3254"></a>(13-60)</p>
<p class="image"><img src="images/001602.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Swapping the real and imaginary parts of the results of this forward DFT gives us what we’re after:</p>
<p class="caption"><a id="calibre_link-1332"></a>(13-61)</p>
<p class="image"><img src="images/000622.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">If we divided <a href="#calibre_link-1332">Eq. (13-61)</a> by <em class="calibre7">N,</em> it would be exactly equal to the inverse DFT expression in <a href="#calibre_link-1330">Eq. (13-57)</a>, and that’s what we set out to show.</p>
<p class="calibre3"><a id="calibre_link-148"></a></p>
<h3 class="calibre6">13.7 Simplified FIR Filter Structure</h3>
<p class="calibre3">If we implement a linear-phase FIR digital filter using the standard structure in <a href="#calibre_link-1333">Figure 13-16(a)</a>, there’s a way to reduce the number of multipliers when the filter has an odd number of taps. Let’s look at the top of <a href="#calibre_link-1333">Figure 13-16(a)</a> where the 5-tap FIR filter coefficients are <em class="calibre7">h</em>(0) through <em class="calibre7">h</em>(4) and the <em class="calibre7">y</em>(<em class="calibre7">n</em>) output is</p>
<p class="caption"><a id="calibre_link-1334"></a>(13-62)</p>
<p class="image"><img src="images/001482.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-1333"></a><strong class="calibre9">Figure 13-16</strong> Conventional and simplified structures of an FIR filter: (a) with an odd number of taps; (b) with an even number of taps.</p>
<p class="image"><img src="images/000200.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">If the FIR filter’s coefficients are symmetrical, we can reduce the number of necessary multipliers. That is, if <em class="calibre7">h</em>(4) = <em class="calibre7">h</em>(0), and <em class="calibre7">h</em>(3) = <em class="calibre7">h</em>(1), we can implement <a href="#calibre_link-1334">Eq. (13-62)</a> by</p>
<p class="caption"><a id="calibre_link-3255"></a>(13-63)</p>
<p class="image"><img src="images/000516.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where only three multiplications are necessary as shown at the bottom of <a href="#calibre_link-1333">Figure 13-16(a)</a>. In our 5-tap filter case, we’ve eliminated two multipliers. This minimum-multiplier structure is called a <em class="calibre7">folded</em> FIR filter.</p>
<p class="calibre3"><a id="calibre_link-3256"></a>So in the case of an odd number of taps, we need only perform (<em class="calibre7">S</em>−1)/2 + 1 multiplications for each filter output sample. For an even number of symmetrical taps as shown in <a href="#calibre_link-1333">Figure 13-16(b)</a>, the saving afforded by this technique reduces the necessary number of multiplications to <em class="calibre7">S</em>/2. Some commercial programmable DSP chips have specialized instructions, and dual <a id="calibre_link-1949"></a>multiply-and-accumulate (MAC) units, that take advantage of the folded FIR filter implementation.</p>
<p class="calibre3"><a id="calibre_link-681"></a></p>
<h3 class="calibre6">13.8 Reducing A/D Converter Quantization Noise</h3>
<p class="calibre3">In <a href="#calibre_link-516">Section 12.3</a> we discussed the mathematical details, and ill effects, of quantization noise in analog-to-digital (A/D) converters. DSP practitioners commonly use two tricks to reduce converter quantization noise. Those schemes are called <em class="calibre7">oversampling</em> and <em class="calibre7">dithering</em>.</p>
<p class="calibre3"><a id="calibre_link-3257"></a></p>
<h4 class="calibre13">13.8.1 Oversampling</h4>
<p class="calibre3">The process of oversampling to reduce A/D converter quantization noise is straightforward. We merely sample an analog signal at an <em class="calibre7">f<sub class="calibre12">s</sub></em> sample rate higher than the minimum rate needed to satisfy the Nyquist criterion (twice the analog signal’s bandwidth), and then lowpass filter. What could be simpler? The theory behind oversampling is based on the assumption that an A/D converter’s total quantization noise power (variance) is the converter’s least significant bit (lsb) value squared over 12, or</p>
<p class="caption"><a id="calibre_link-3258"></a>(13-64)</p>
<p class="image"><img src="images/001286.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">We derived that expression in <a href="#calibre_link-516">Section 12.3</a>. The next assumptions are: The quantization noise values are truly random, and in the frequency domain the quantization noise has a flat spectrum. (These assumptions are valid if the A/D converter is being driven by an analog signal that covers most of the converter’s analog input voltage range and is not highly periodic.) Next we consider the notion of quantization noise power spectral density (PSD), a frequency-domain characterization of quantization noise measured in noise power per hertz as shown in <a href="#calibre_link-1335">Figure 13-17</a>. Thus we can consider the idea that quantization noise can be represented as a certain amount of power (watts, if we wish) per unit bandwidth.</p>
<p class="caption"><a id="calibre_link-1335"></a><strong class="calibre9">Figure 13-17</strong> Frequency-domain power spectral density of an ideal A/D converter.</p>
<p class="image"><img src="images/001042.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">In our world of discrete systems, the flat noise spectrum assumption results in the total quantization noise (a fixed value based on the converter’s lsb voltage) being distributed equally in the frequency domain, from −<em class="calibre7">f<sub class="calibre12">s</sub></em>/2 to +<em class="calibre7">f<sub class="calibre12">s</sub></em>/2 as indicated in <a href="#calibre_link-1335">Figure 13-17</a>. The amplitude of this quantization noise PSD is the rectangle area (total quantization noise power) divided by the rectangle width (<em class="calibre7">f<sub class="calibre12">s</sub></em>), or</p>
<p class="caption"><a id="calibre_link-1336"></a>(13-65)</p>
<p class="image"><img src="images/000418.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">measured in watts/Hz.</p>
<p class="calibre3"><a id="calibre_link-3259"></a>The next question is: “How can we reduce the <em class="calibre7">PSD</em><sub class="calibre12">noise</sub> level defined by <a href="#calibre_link-1336">Eq. (13-65)</a>?” We could reduce the lsb value (volts) in the numerator by using an A/D converter with additional bits. That would make the lsb value smaller and certainly reduce <em class="calibre7">PSD</em><sub class="calibre12">noise</sub>, but that’s an expensive solution. Extra converter bits cost money. Better yet, let’s increase the denominator of <a href="#calibre_link-1336">Eq. (13-65)</a> by increasing the sample rate <em class="calibre7">f<sub class="calibre12">s</sub></em>.</p>
<p class="calibre3">Consider a low-level discrete signal of interest whose spectrum is depicted in <a href="#calibre_link-1337">Figure 13-18(a)</a>. By increasing the <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,old</sub> sample rate to some larger value <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,new</sub> (oversampling), we spread the total noise power (a fixed value) over a wider frequency range as shown in <a href="#calibre_link-1337">Figure 13-18(b)</a>. The areas under the shaded curves in <a href="#calibre_link-1337">Figures 13-18(a)</a> and <a href="#calibre_link-1337">13-18(b)</a> are equal. Next we lowpass filter the converter’s output samples. At the output of the filter, the quantization noise level contaminating our signal will be reduced from that at the input of the filter.</p>
<p class="caption"><a id="calibre_link-1337"></a><strong class="calibre9">Figure 13-18</strong> Oversampling example: (a) noise PSD at an <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,old</sub> samples rate; (b) noise PSD at the higher <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,new</sub> samples rate; (c) processing steps.</p>
<p class="image"><img src="images/000098.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The improvement in signal-to-quantization-noise ratio, measured in dB, achieved by oversampling is</p>
<p class="caption"><a id="calibre_link-3260"></a>(13-66)</p>
<p class="image"><img src="images/001267.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">For example, if <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,old</sub> = 100 kHz, and <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,new</sub> = 400 kHz, the <em class="calibre7">SNR</em><sub class="calibre12">A/D-gain</sub> = 10log<sub class="calibre12">10</sub>(4) = 6.02 dB. Thus oversampling by a factor of four (and filtering), we gain a single bit’s worth of quantization noise reduction. Consequently we can achieve <em class="calibre7">N</em>+1-bit performance from an <em class="calibre7">N</em>-bit A/D converter, because we gain signal amplitude resolution at the expense of higher sampling speed. After digital filtering, we can decimate to the lower <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,old</sub> without degrading the improved SNR. Of course, the number of bits used for the lowpass filter’s coefficients and registers must exceed the original number of A/D converter bits, or this oversampling scheme doesn’t work.</p>
<p class="calibre3">With the use of a digital lowpass filter, depending on the interfering analog noise in <em class="calibre7">x</em>(<em class="calibre7">t</em>), it’s possible to use a lower-performance (simpler) analog anti-aliasing filter relative to the analog filter necessary at the lower sampling rate.</p>
<p class="calibre3"><a id="calibre_link-3261"></a></p>
<h4 class="calibre13"><a id="calibre_link-1945"></a>13.8.2 Dithering</h4>
<p class="calibre3">Dithering, another technique used to minimize the effects of A/D quantization noise, is the process of adding noise to our analog signal prior to A/D conversion. This scheme, which doesn’t seem at all like a good idea, can indeed be useful and is easily illustrated with an example. Consider digitizing the low-level analog sinusoid shown in <a href="#calibre_link-1338">Figure 13-19(a)</a>, whose peak voltage just exceeds a single A/D converter least significant bit (lsb) voltage level, yielding the converter output <em class="calibre7">x</em><sub class="calibre12">1</sub>(<em class="calibre7">n</em>) samples in <a href="#calibre_link-1338">Figure 13-19(b)</a>. The <em class="calibre7">x</em><sub class="calibre12">1</sub>(<em class="calibre7">n</em>) output sequence is <em class="calibre7">clipped.</em> This generates all sorts of spectral harmonics. Another way to explain the spectral harmonics is to recognize the periodicity of the quantization noise in <a href="#calibre_link-1338">Figure 13-19(c)</a>.</p>
<p class="caption"><a id="calibre_link-1338"></a><strong class="calibre9">Figure 13-19</strong> Dithering: (a) a low-level analog signal; (b) the A/D converter output sequence; (c) the quantization error in the converter’s output.</p>
<p class="image"><img src="images/000936.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">We show the spectrum of <em class="calibre7">x</em><sub class="calibre12">1</sub>(<em class="calibre7">n</em>) in <a href="#calibre_link-1339">Figure 13-20(a)</a> where the spurious quantization noise harmonics are apparent. It’s worthwhile to note that averaging multiple spectra will not enable us to pull some spectral component of interest up above those spurious harmonics in <a href="#calibre_link-1339">Figure 13-20(a)</a>. Because the quantization noise is highly correlated with our input sinewave&mdash;the quantization noise has the same time period as the input sinewave&mdash;spectral averaging will also raise the noise harmonic levels. Dithering to the rescue.</p>
<p class="caption"><a id="calibre_link-1339"></a><strong class="calibre9">Figure 13-20</strong> Spectra of a low-level discrete sinusoid: (a) with no dithering; (b) with dithering.</p>
<p class="image"><img src="images/001800.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3262"></a>Dithering is the technique where random analog noise is added to the analog input sinusoid before it is digitized. This technique results in a noisy analog signal that crosses additional converter lsb boundaries and yields a quantization noise that’s much more random, with a reduced level of undesirable spectral harmonics as shown in <a href="#calibre_link-1339">Figure 13-20(b)</a>. Dithering raises the average spectral noise floor but increases our signal-to-noise ratio SNR<sub class="calibre12">2</sub>. Dithering forces the quantization noise to lose its coherence with the original input signal, and we could then perform signal averaging if desired.</p>
<p class="calibre3">Dithering is indeed useful when we’re digitizing</p>
<p class="indenthangingb">• low-amplitude analog signals,</p>
<p class="indenthangingb">• highly periodic analog signals (like a sinewave with an even number of cycles in the sample time interval), and</p>
<p class="indenthangingb">• slowly varying (very low frequency, including DC) analog signals.</p>
<p class="calibre3"><a id="calibre_link-1952"></a>The standard implementation of dithering is shown in <a href="#calibre_link-1340">Figure 13-21(a)</a>. The typical amount of random wideband analog noise used in this process, provided by a noise diode or noise generator ICs, has an rms (root mean squared) level equivalent to 1/3 to 1 lsb voltage level. The system-level effect of adding the analog dithering signal is to linearize the undithered <em class="calibre7">stair-step</em> transfer function of an A/D converter as shown in <a href="#calibre_link-1340">Figure 13-21(c)</a>.</p>
<p class="caption"><a id="calibre_link-1340"></a><strong class="calibre9">Figure 13-21</strong> Dithering implementations: (a) standard dithering process; (b) advanced dithering with noise subtraction; (c) improved transfer function due to dithering.</p>
<p class="image"><img src="images/000825.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">For high-performance audio applications, engineers have found that adding dither noise from two separate noise generators improves background audio low-level noise suppression. The probability density function (PDF) of the sum of two noise sources (having rectangular PDFs) is the convolution of their individual PDFs. Because the convolution of two rectangular functions is triangular, this dual-noise-source dithering scheme is called <em class="calibre7">triangular dither</em>. Typical triangular dither noise has rms levels equivalent to, roughly, 2 lsb voltage levels.</p>
<p class="calibre3">In the situation where our signal of interest occupies some well-defined portion of the full frequency band, injecting narrowband dither noise having an rms level equivalent to 4 to 6 lsb voltage levels, whose spectral energy is outside that signal band, would be advantageous. (Remember, though: the dither signal can’t be too narrowband, like a sinewave. Quantization noise from a sinewave signal would generate more spurious harmonics!) That narrowband dither noise can then be removed by follow-on digital filtering.</p>
<p class="calibre3">One last note about dithering: To improve our ability to detect low-level signals, we could add the analog dither noise and then subtract that noise from the digitized data, as shown in <a href="#calibre_link-1340">Figure 13-21(b)</a>. This way, we randomize the quantization noise but reduce the amount of total noise power injected in the analog signal. This scheme is used in commercial analog test equipment[<a href="#calibre_link-1341">22</a>,<a href="#calibre_link-1342">23</a>].</p>
<p class="calibre3"><a id="calibre_link-682"></a></p>
<h3 class="calibre6"><a id="calibre_link-1955" class="calibre5"></a>13.9 A/D Converter Testing Techniques</h3>
<p class="calibre3">We can take advantage of digital signal processing techniques to facilitate the testing of A/D converters. In this section we present two schemes for measuring converter performance: first, a technique using the FFT to estimate overall converter noise, and second, a histogram analysis scheme to detect missing converter output codes.</p>
<p class="calibre3"><a id="calibre_link-3263"></a></p>
<h4 class="calibre13">13.9.1 Estimating A/D Quantization Noise with the FFT</h4>
<p class="calibre3">The combination of A/D converter quantization noise, missing bits, harmonic distortion, and other nonlinearities can be characterized by analyzing the spectral content of the converter’s output. Converter performance degradation caused by these nonlinearities is not difficult to recognize because they show up as spurious spectral components and increased background noise levels in the A/D converter’s output samples. The traditional test method involves applying a sinusoidal analog voltage to an A/D converter’s input and examining the spectrum of the converter’s digitized time-domain output samples. We can use the FFT to compute the spectrum of an A/D converter’s <a id="calibre_link-2441"></a>output samples, but we have to minimize FFT spectral leakage to improve the sensitivity of our spectral measurements. Traditional time-domain windowing, however, often provides insufficient FFT leakage reduction for high-performance A/D converter testing.</p>
<p class="calibre3">The trick to circumvent this FFT leakage problem is to use a sinusoidal analog input voltage whose frequency is a rational factor of the A/D converter’s clock frequency as shown in <a href="#calibre_link-1343">Figure 13-22(a)</a>. That frequency is <em class="calibre7">mf<sub class="calibre12">s</sub></em>/<em class="calibre7">N</em> where <em class="calibre7">m</em> is an integer, <em class="calibre7">f<sub class="calibre12">s</sub></em> is the clock frequency (sample rate), and <em class="calibre7">N</em> is the FFT size. <a href="#calibre_link-1343">Figure 13-22(a)</a> shows the <em class="calibre7">x</em>(<em class="calibre7">n</em>) time-domain output of an ideal 5-bit A/D converter when its analog input is a sinewave having exactly <em class="calibre7">m</em> = 4 cycles over <em class="calibre7">N</em> = 64 converter output samples. In this case, the analog input frequency is 4<em class="calibre7">f<sub class="calibre12">s</sub></em>/64 Hz. Recall from <a href="#calibre_link-134">Chapter 3</a> that the expression <em class="calibre7">mf<sub class="calibre12">s</sub></em>/<em class="calibre7">N</em> defined the analysis frequencies, or bin centers, of the DFT, and a DFT input sinusoid whose frequency is at a bin center causes no spectral leakage.</p>
<p class="caption"><a id="calibre_link-1343"></a><strong class="calibre9">Figure 13-22</strong> A/D converter (5-bit) output with an analog 4<em class="calibre7">f<sub class="calibre12">s</sub></em>/64 Hz sinewave input: (a) <em class="calibre7">m</em> = 4-cycle sinusoidal time samples; (b) spectral magnitude in dB.</p>
<p class="image"><img src="images/001684.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The magnitudes of the first half of an <em class="calibre7">N</em> = 64-point FFT of <em class="calibre7">x</em>(<em class="calibre7">n</em>) are shown in the logarithmic plot in <a href="#calibre_link-1343">Figure 13-22(b)</a> where the analog input spectral component lies exactly at the <em class="calibre7">m</em> = 4 bin center. (The additional nonzero spectral samples are not due to FFT leakage; they represent A/D converter quantization noise.) Specifically, if the sample rate were 1 MHz, then the A/D’s input analog sinewave’s frequency is 4(10<sup class="calibre10">6</sup>/64) = 62.5 kHz. In order to <a id="calibre_link-1951"></a>implement this A/D testing scheme we must ensure that the analog test-signal generator is synchronized, exactly, with the A/D converter’s clock frequency of <em class="calibre7">f<sub class="calibre12">s</sub></em> Hz. Achieving this synchronization is why this A/D converter testing procedure is referred to as <em class="calibre7">coherent sampling</em>[<a href="#calibre_link-1344">24</a>&ndash;<a href="#calibre_link-1345">26</a>]. That is, the analog signal generator and the A/D clock generator providing <em class="calibre7">f<sub class="calibre12">s</sub></em> must not drift in frequency relative to each other&mdash;they must remain coherent. (Here we must take care from a semantic viewpoint because the quadrature sampling schemes described in <a href="#calibre_link-235">Chapter 8</a> are also sometimes called <em class="calibre7">coherent sampling</em>, and they are unrelated to this A/D converter testing procedure.)</p>
<p class="calibre3">As it turns out, some values of <em class="calibre7">m</em> are more advantageous than others. Notice in <a href="#calibre_link-1343">Figure 13-22(a)</a>, that when <em class="calibre7">m</em> = 4, only ten different binary output values, output codes, are output by the A/D converter. Those values are repeated over and over, and the quantization noise is far from being random. As shown in <a href="#calibre_link-1346">Figure 13-23(a)</a>, when <em class="calibre7">m</em> = 5, we exercise more than ten different A/D output codes, and the quantization noise in <a href="#calibre_link-1346">Figure 13-23(b)</a> is much more random than when <em class="calibre7">m</em> = 4.</p>
<p class="caption"><a id="calibre_link-1346"></a><strong class="calibre9">Figure 13-23</strong> A/D converter (5-bit) output with an analog 5<em class="calibre7">f<sub class="calibre12">s</sub></em>/64 Hz sinewave input: (a) <em class="calibre7">m</em> = 5-cycle time samples; (b) spectral magnitude in dB; (c) FFT results interpretation.</p>
<p class="image"><img src="images/000708.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Because it’s best to test as many A/D output codes as possible, while keeping the quantization noise sufficiently random, users of this A/D testing scheme have discovered another trick; they found making <em class="calibre7">m</em> an odd prime number (3, 5, 7, 11, etc.) minimizes the number of redundant A/D output code values and makes the quantization noise more random, which is what we want. The larger <em class="calibre7">m</em> is, the more codes that are exercised. (We can use <em class="calibre7">histogram testing</em>, discussed in the next section, to determine how many of a <em class="calibre7">b</em>-bit A/D converter’s 2<em class="calibre7"><sup class="calibre10">b</sup></em> possible output codes have been exercised.)</p>
<p class="calibre3">While examining the quantization noise level in <a href="#calibre_link-1346">Figure 13-23(b)</a>, we might be tempted to say the A/D converter has a signal-to-quantization-noise ratio of 40 to 50 dB. As it turns out, the true A/D converter noise levels will be higher than those indicated by <a href="#calibre_link-1346">Figure 13-23(b)</a>. That’s because the inherent processing gain of the FFT (discussed in <a href="#calibre_link-1347">Section 3.12.1</a>) will <em class="calibre7">pull</em> the high-level <em class="calibre7">m</em> = 5 signal spectral component up out of the background converter noise, making that <em class="calibre7">m</em> = 5 spectral magnitude sample appear higher above the background noise than is correct. Consequently, when viewing <a href="#calibre_link-1346">Figure 13-23(b)</a>, we must keep in mind an <em class="calibre7">N</em> = 64-point FFT’s processing gain of 10log<sub class="calibre12">10</sub>(64/2). Our interpretation of A/D performance based on the FFT magnitude results is given in <a href="#calibre_link-1346">Figure 13-23(c)</a>.</p>
<p class="calibre3">There is a technique used to characterize an A/D converter’s true signal-to-noise ratio (including quantization noise, harmonic distortion, and other nonlinearities). That testing technique measures what is commonly called an A/D converter’s SINAD&mdash;for signal-to-noise-and-distortion&mdash;and does not require us to consider FFT processing gain. The SINAD value for an A/D converter, based on spectral power samples, is</p>
<p class="caption"><a id="calibre_link-1348"></a>(13-66′)</p>
<p class="image"><img src="images/000000.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3264"></a>The SINAD value for an A/D converter is a good quantitative indicator of a converter’s overall dynamic performance. The steps to compute SINAD are:</p>
<p class="indenthangingn1"><strong class="calibre9">1.</strong> Compute an <em class="calibre7">N</em>-point FFT of an A/D converter’s output sequence. Discard the negative-frequency samples of the FFT results.</p>
<p class="indenthangingn1"><strong class="calibre9">2.</strong> Over the positive-frequency range of the FFT results, compute the total signal spectral power by summing the squares of all signal-only spectral magnitude samples. For our <a href="#calibre_link-1346">Figure 13-23</a> example that’s simply squaring the FFT’s |X(5)| magnitude value. (We square the linear |X(5)| value and not the value of |X(5)| in dB!)</p>
<p class="indenthangingn1"><a id="calibre_link-3265"></a><strong class="calibre9">3.</strong> Over the positive-frequency range of the FFT results, sum the squares of all noise-only spectral magnitude samples, including any signal harmonics, but excluding the zero-Hz <em class="calibre7">X</em>(0) sample. This summation result represents total noise power, which includes harmonic distortion.</p>
<p class="indenthangingn1"><strong class="calibre9">4.</strong> Perform the computation given in <a href="#calibre_link-1348">Eq. (13-66′)</a>.</p>
<p class="calibre3">Performing those steps on the spectrum in <a href="#calibre_link-1346">Figure 13-23(b)</a> yields a SINAD value of 31.6 dB. This result is reasonable for our simulated 5-bit A/D converter because its signal-to-quantization-noise ratio would ideally be 6·5 + 1.7 = 31.7 dB.</p>
<p class="calibre3"><a href="#calibre_link-1349">Figure 13-24(a)</a> illustrates an extreme example of nonlinear A/D converter operation with several binary output codes (words) having dropped bits in the time-domain <em class="calibre7">x</em>(<em class="calibre7">n</em>) sequence with <em class="calibre7">m</em> = 5. The FFT magnitudes, provided in <a href="#calibre_link-1349">Figure 13-24(b)</a>, indicate severe A/D converter nonlinear distortion because we can see the increased background noise level compared to <a href="#calibre_link-1346">Figure 13-23(b)</a>. Performing <a href="#calibre_link-1348">Eq. (13-66′)</a> for this noisy A/D gives us a measured SINAD value of 15.2 dB, which is drastically smaller than the ideal 5-bit A/D converter’s SINAD = 31.6 dB. The point here is that we can quickly measure an A/D converter’s performance using FFTs and <a href="#calibre_link-1348">Eq. (13-66′)</a>.</p>
<p class="caption"><a id="calibre_link-1349"></a><strong class="calibre9">Figure 13-24</strong> Nonideal A/D converter output showing several dropped bits: (a) time samples; (b) spectral magnitude in dB.</p>
<p class="image"><img src="images/001565.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-1953"></a>To fully characterize the dynamic performance of an A/D converter we’d need to perform this SINAD testing technique at many different input frequencies and amplitudes. (The analog sinewave applied to an A/D converter must, of course, be as <em class="calibre7">pure</em> as possible. Any distortion inherent in the analog signal will show up in the final FFT output and could be mistaken for A/D nonlinearity.) The key issue here is that when any input frequency is <em class="calibre7">mf<sub class="calibre12">s</sub></em>/<em class="calibre7">N</em>, where <em class="calibre7">m</em> is less than <em class="calibre7">N</em>/2 to satisfy the Nyquist sampling criterion, we can take full advantage of the FFT’s processing capability while minimizing spectral leakage.</p>
<p class="calibre3">For completeness, we mention that what we called SINAD in <a href="#calibre_link-1348">Eq. (13-66′)</a> is sometimes called SNDR. In addition, there is a measurement scheme called SINAD used by RF engineers to quantify the sensitivity of radio receivers. That receiver SINAD concept is quite different from our <a href="#calibre_link-1348">Eq. (13-66′)</a> A/D converter SINAD estimation process and will not be discussed here.</p>
<p class="calibre3"><a id="calibre_link-3266"></a></p>
<h4 class="calibre13">13.9.2 Estimating A/D Dynamic Range</h4>
<p class="calibre3">In this section we describe a technique of applying the sum of two analog sinewaves to an A/D converter’s input to quantify the intermodulation distortion performance of a converter, which in turn measures the converter’s dynamic range. That dynamic range is called the converter’s <em class="calibre7">spurious free dynamic range</em> (SFDR). In this testing scheme both input sinewaves must comply with the <em class="calibre7">mf<sub class="calibre12">s</sub></em>/<em class="calibre7">N</em> restriction. <a href="#calibre_link-1350">Figure 13-25(a)</a> shows the test configuration.</p>
<p class="caption"><a id="calibre_link-1350"></a><strong class="calibre9">Figure 13-25</strong> A/D converter SFDR testing: (a) hardware test configuration; (b) example test results.</p>
<p class="image"><img src="images/001344.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The SFDR test starts by applying the sum of two equal-amplitude analog sinewaves to an A/D converter and monitoring the spectrum of the converter’s output samples. Next we increase both analog sinewaves’ amplitudes until we see a spurious spectral component rising above the converter’s background spectral noise as shown in <a href="#calibre_link-1350">Figure 13-25(b)</a>. Finally we measure the converter’s SFDR as the dB difference between a high-level signal spectral magnitude sample and the spurious signal’s spectral magnitude.</p>
<p class="calibre3">For this SFDR testing it’s prudent to use bandpass filters (BPFs) to improve the spectral purity of the sinewave generators’ outputs, and small-valued fixed attenuators (pads) are used to keep the generators from adversely interacting with each other. (I recommend 3 dB fixed attenuators for this.) The power combiner is typically an analog power splitter driven backward, and the A/D clock generator output is a squarewave. The dashed lines in <a href="#calibre_link-1350">Figure 13-25(a)</a> indicate that all three generators are synchronized to the same reference frequency source.</p>
<p class="calibre3"><a id="calibre_link-3267"></a></p>
<h4 class="calibre13"><a id="calibre_link-1954"></a>13.9.3 Detecting Missing Codes</h4>
<p class="calibre3">One problem that can plague A/D converters is <em class="calibre7">missing codes</em>. This defect occurs when a converter is incapable of outputting a specific binary word (a code). Think about driving an eight-bit converter with an analog sinusoid and the effect when its output should be the binary word 00100001 (decimal 33); its output is actually the word 00100000 (decimal 32) as shown in <a href="#calibre_link-1351">Figure 13-26(a)</a>. The binary word representing decimal 33 is a missing code. This subtle nonlinearity is very difficult to detect by examining time-domain samples or performing spectrum analysis. Fortunately there is a simple, reliable way to detect the missing 33 using histogram analysis.</p>
<p class="caption"><a id="calibre_link-1351"></a><strong class="calibre9">Figure 13-26</strong> Eight-bit converter missing codes: (a) missing code of binary 00100001, decimal 33; (b) histogram plot.</p>
<p class="image"><img src="images/000702.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The histogram testing technique merely involves collecting many A/D converter output samples and plotting the number of occurrences of each sample value versus that sample value as shown in <a href="#calibre_link-1351">Figure 13-26(b)</a>. Any missing code (like our missing 33) would show up in the histogram as a zero value. That is, there were zero occurrences of the binary code representing a decimal 33.</p>
<p class="calibre3">Additional useful information can be obtained from our histogram results. That is, counting the number of nonzero samples in <a href="#calibre_link-1351">Figure 13-26(b)</a> tells us how many actual different A/D converter output codes (out of a possible 2<em class="calibre7"><sup class="calibre10">b</sup></em> codes) have been exercised.</p>
<p class="calibre3"><a id="calibre_link-2084"></a>In practice, the input analog sinewave must have an amplitude that’s somewhat greater than the analog signal that we intend to digitize in an actual application, and a frequency that is unrelated to (incoherent with) the <em class="calibre7">f<sub class="calibre12">s</sub></em> sampling rate. In an effort to exercise (test) all of the converter’s output codes, we digitize as many cycles of the input sinewave as possible for our histogram test.</p>
<p class="calibre3"><a id="calibre_link-524"></a></p>
<h3 class="calibre6">13.10 Fast FIR Filtering Using the FFT</h3>
<p class="calibre3">In the late 1960s, while contemplating the notion of time-domain convolution, DSP pioneer Thomas Stockham (digital audio expert and inventor of the compact disc) realized that time-domain convolution could sometimes be performed much more efficiently using fast Fourier transform (FFT) algorithms rather than using the direct convolution implemented with tapped-delay line FIR filters. The principle behind this FFT-based convolution scheme, called <a id="calibre_link-3268"></a><em class="calibre7">fast convolution</em> (also called <em class="calibre7">block convolution</em> or <em class="calibre7">FFT convolution</em>), is diagrammed in <a href="#calibre_link-1352">Figure 13-27(a)</a>. In that figure <em class="calibre7">x</em>(<em class="calibre7">n</em>) is an input signal sequence and <em class="calibre7">h</em>(<em class="calibre7">k</em>) is the <em class="calibre7">Q</em>-length impulse response (coefficients) of a tapped-delay line FIR filter. <a href="#calibre_link-1352">Figure 13-27(a)</a> is a graphical depiction of one form of the convolution theorem: Multiplication in the frequency domain is equivalent to convolution in the time domain.</p>
<p class="caption"><a id="calibre_link-1352"></a><strong class="calibre9">Figure 13-27</strong> Fast convolution: (a) basic process; (b) computational workloads for various FIR filter tap lengths <em class="calibre7">Q</em>.</p>
<p class="image"><img src="images/000487.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The standard convolution equation, for a <em class="calibre7">Q</em>-tap FIR filter, given in <a href="#calibre_link-1063">Eq. (5-6)</a> is repeated here for reference as</p>
<p class="caption"><a id="calibre_link-1353"></a>(13-67)</p>
<p class="image"><img src="images/001145.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where the symbol “*” means convolution. When the filter’s <em class="calibre7">h</em>(<em class="calibre7">k</em>) impulse response has a length greater than 40 to 80 (depending on the hardware and <a id="calibre_link-2087"></a>software being used), the process in <a href="#calibre_link-1352">Figure 13-27(a)</a> requires fewer computations than directly implementing the convolution expression in <a href="#calibre_link-1353">Eq. (13-67)</a>. Consequently, this fast convolution technique is a computationally efficient signal processing tool, particularly when used for digital filtering. Fast convolution’s gain in computational efficiency becomes quite significant when the lengths of <em class="calibre7">h</em>(<em class="calibre7">k</em>) and <em class="calibre7">x</em>(<em class="calibre7">n</em>) are large.</p>
<p class="calibre3"><a href="#calibre_link-1352">Figure 13-27(b)</a> indicates the reduction in the fast convolution algorithm’s computational workload relative to the standard (tapped-delay line) time-domain convolution method, <a href="#calibre_link-1353">Eq. (13-67)</a>, versus the length of the <em class="calibre7">x</em>(<em class="calibre7">n</em>) sequence for various filter impulse response lengths <em class="calibre7">Q</em>. (Please do not view <a href="#calibre_link-1352">Figure 13-27(b)</a> as any sort of <em class="calibre7">gospel truth</em>. That figure is merely an indicator of fast convolution’s computational efficiency.)</p>
<p class="calibre3">The necessary forward and inverse FFT sizes, <em class="calibre7">N</em>, in <a href="#calibre_link-1352">Figure 13-27(a)</a> must of course be equal and are dependent upon the length of the original <em class="calibre7">h</em>(<em class="calibre7">k</em>) and <em class="calibre7">x</em>(<em class="calibre7">n</em>) sequences. Recall from <a href="#calibre_link-1354">Eq. (5-29)</a> that if <em class="calibre7">h</em>(<em class="calibre7">k</em>) is of length <em class="calibre7">Q</em> and <em class="calibre7">x</em>(<em class="calibre7">n</em>) is of length <em class="calibre7">P</em>, the length of the final <em class="calibre7">y</em>(<em class="calibre7">n</em>) sequence will be <em class="calibre7">L</em> where</p>
<p class="caption"><a id="calibre_link-3269"></a>(13-67′)</p>
<p class="image"><img src="images/000323.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">For this fast convolution technique to yield valid results, the forward and inverse FFT sizes <em class="calibre7">must</em> be equal to or greater than <em class="calibre7">L</em>. So, to implement fast convolution we must choose an <em class="calibre7">N</em>-point FFT size such that <em class="calibre7">N</em> ≥ <em class="calibre7">L</em>, and zero-pad <em class="calibre7">h</em>(<em class="calibre7">k</em>) and <em class="calibre7">x</em>(<em class="calibre7">n</em>) so they have new lengths equal to <em class="calibre7">N</em>. The desired <em class="calibre7">y</em>(<em class="calibre7">n</em>) output is the real part of the first <em class="calibre7">L</em> samples of the inverse FFT. Note that the <em class="calibre7">H</em>(<em class="calibre7">m</em>) sequence, the FFT of the FIR filter’s <em class="calibre7">h</em>(<em class="calibre7">k</em>) impulse response, need only be computed once and stored in memory.</p>
<p class="calibre3">Now if the <em class="calibre7">x</em>(<em class="calibre7">n</em>) input sequence length <em class="calibre7">P</em> is so large that FFT processing becomes impractical, or your hardware memory buffer can only hold small segments of the <em class="calibre7">x</em>(<em class="calibre7">n</em>) time samples, then <em class="calibre7">x</em>(<em class="calibre7">n</em>) must be partitioned into multiple blocks of samples and each sample block processed individually. If the partitioned-<em class="calibre7">x</em>(<em class="calibre7">n</em>) block lengths are <em class="calibre7">N</em>, a straightforward implementation of <a href="#calibre_link-1352">Figure 13-27(a)</a> leads to time-domain aliasing errors in <em class="calibre7">y</em>(<em class="calibre7">n</em>) due to the circular nature (spectral wraparound) of the discrete Fourier transform (and the FFT). Two techniques are used to avoid that time-domain aliasing problem, the <em class="calibre7">overlap</em>-<em class="calibre7">and</em>-<em class="calibre7">save</em> method and the <em class="calibre7">overlap</em>-<em class="calibre7">and</em>-<em class="calibre7">add</em> method. Of these two methods, let’s first have a look at the overlap-and-save fast convolution filtering technique shown in <a href="#calibre_link-1355">Figure 13-28(a)</a>.</p>
<p class="caption"><a id="calibre_link-1355"></a><strong class="calibre9">Figure 13-28</strong> Fast convolution block processing (continues).</p>
<p class="image"><img src="images/000106.jpg" alt="image" class="calibre2" /></p>
<p class="image"><img src="images/000945.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Given that the desired FIR filter’s <em class="calibre7">h</em>(<em class="calibre7">k</em>) impulse response length is <em class="calibre7">Q</em> and the <em class="calibre7">x</em>(<em class="calibre7">n</em>) filter input sequence is of length <em class="calibre7">P</em>, the steps to perform overlap-and-save fast convolution filtering are as follows:</p>
<p class="indenthangingn1"><strong class="calibre9">1.</strong> Choose an FFT size of <em class="calibre7">N</em>, where <em class="calibre7">N</em> is an integer power of two equal to roughly four times <em class="calibre7">Q</em>.</p>
<p class="indenthangingn1"><a id="calibre_link-3270"></a><strong class="calibre9">2.</strong> Append (<em class="calibre7">N</em>−<em class="calibre7">Q</em>) zero-valued samples to the end of the <em class="calibre7">h</em>(<em class="calibre7">k</em>) impulse response and perform an <em class="calibre7">N</em>-point FFT on the extended sequence, producing the complex <em class="calibre7">H</em>(<em class="calibre7">m</em>) sequence.</p>
<p class="indenthangingn1"><strong class="calibre9">3.</strong> Compute integer <em class="calibre7">M</em> using <em class="calibre7">M</em> = <em class="calibre7">N</em>−(<em class="calibre7">Q</em>−1).</p>
<p class="indenthangingn1"><strong class="calibre9">4.</strong> Insert (<em class="calibre7">Q</em>−1) zero-valued samples prior to the first <em class="calibre7">M</em> samples of <em class="calibre7">x</em>(<em class="calibre7">n</em>), creating the first <em class="calibre7">N</em>-point FFT input sequence <em class="calibre7">x</em><sub class="calibre12">1</sub>(<em class="calibre7">n</em>).</p>
<p class="indenthangingn1"><strong class="calibre9">5.</strong> Perform an <em class="calibre7">N</em>-point FFT on <em class="calibre7">x</em><sub class="calibre12">1</sub>(<em class="calibre7">n</em>), multiply that FFT result by the <em class="calibre7">H</em>(<em class="calibre7">m</em>) sequence, and perform an <em class="calibre7">N</em>-point inverse FFT on the product. Discard the first (<em class="calibre7">Q</em>−1) samples of the inverse FFT results to generate the first <em class="calibre7">M</em>-point output block of data <em class="calibre7">y</em><sub class="calibre12">1</sub>(<em class="calibre7">n</em>).</p>
<p class="indenthangingn1"><strong class="calibre9">6.</strong> Attach the last (<em class="calibre7">Q</em>−1) samples of <em class="calibre7">x</em><sub class="calibre12">1</sub>(<em class="calibre7">n</em>) to the beginning of the second <em class="calibre7">M</em>-length block of the original <em class="calibre7">x</em>(<em class="calibre7">n</em>) sequence, creating the second <em class="calibre7">N</em>-point FFT input sequence <em class="calibre7">x</em><sub class="calibre12">2</sub>(<em class="calibre7">n</em>) as shown in <a href="#calibre_link-1355">Figure 13-28(a)</a>.</p>
<p class="indenthangingn1"><strong class="calibre9">7.</strong> Perform an <em class="calibre7">N</em>-point FFT on <em class="calibre7">x</em><sub class="calibre12">2</sub>(<em class="calibre7">n</em>), multiply that FFT result by the <em class="calibre7">H</em>(<em class="calibre7">m</em>) sequence, and perform an <em class="calibre7">N</em>-point inverse FFT on the product. Discard the first (<em class="calibre7">Q</em>−1) samples of the inverse FFT results to generate the second <em class="calibre7">M</em>-point output block of data <em class="calibre7">y</em><sub class="calibre12">2</sub>(<em class="calibre7">n</em>).</p>
<p class="indenthangingn1"><strong class="calibre9">8.</strong> Repeat Steps 6 and 7 until we have gone through the entire original <em class="calibre7">x</em>(<em class="calibre7">n</em>) filter input sequence. Depending on the length <em class="calibre7">P</em> of the original <em class="calibre7">x</em>(<em class="calibre7">n</em>) <a id="calibre_link-2086"></a>input sequence and the chosen value for <em class="calibre7">N,</em> we must append anywhere from <em class="calibre7">Q</em>−1 to <em class="calibre7">N</em>−1 zero-valued samples to the end of the original <em class="calibre7">x</em>(<em class="calibre7">n</em>) input samples in order to accommodate the final block of forward and inverse FFT processing.</p>
<p class="indenthangingn1"><strong class="calibre9">9.</strong> Concatenate the <em class="calibre7">y</em><sub class="calibre12">1</sub>(<em class="calibre7">n</em>), <em class="calibre7">y</em><sub class="calibre12">2</sub>(<em class="calibre7">n</em>), <em class="calibre7">y</em><sub class="calibre12">3</sub>(<em class="calibre7">n</em>), . . . sequences shown in <a href="#calibre_link-1355">Figure 13-28(a)</a>, discarding any unnecessary trailing zero-valued samples, to generate your final linear-convolution filter output <em class="calibre7">y</em>(<em class="calibre7">n</em>) sequence.</p>
<p class="indenthangingn1"><strong class="calibre9">10.</strong> Finally, experiment with different values of <em class="calibre7">N</em> to see if there exists an <em class="calibre7">optimum N</em> that minimizes the computational workload for your hardware and software implementation. In any case, <em class="calibre7">N</em> must not be less than (<em class="calibre7">M</em>+<em class="calibre7">Q</em>−1). (Smaller <em class="calibre7">N</em> means many small-sized FFTs are needed, and large <em class="calibre7">N</em> means fewer, but larger-sized, FFTs are necessary. Pick your poison.)</p>
<p class="calibre3">The second fast convolution method, the <em class="calibre7">overlap</em>-<em class="calibre7">and</em>-<em class="calibre7">add</em> technique, is shown in <a href="#calibre_link-1355">Figure 13-28(b)</a>. In this method, the <em class="calibre7">x</em>(<em class="calibre7">n</em>) input sequence is partitioned (segmented) into data blocks of length <em class="calibre7">M</em>, and our data overlapping takes place in the inverse FFT time-domain sequences. Given that the desired FIR filter’s <em class="calibre7">h</em>(<em class="calibre7">k</em>) impulse response length is <em class="calibre7">Q</em> and the <em class="calibre7">x</em>(<em class="calibre7">n</em>) filter input sequence <a id="calibre_link-3271"></a>is of length <em class="calibre7">P</em>, the steps to perform overlap-and-add fast convolution filtering are as follows:</p>
<p class="indenthangingn1"><strong class="calibre9">1.</strong> Choose an FFT size of <em class="calibre7">N</em>, where <em class="calibre7">N</em> is an integer power of two equal to roughly two times <em class="calibre7">Q</em>.</p>
<p class="indenthangingn1"><strong class="calibre9">2.</strong> Append (<em class="calibre7">N</em>−<em class="calibre7">Q</em>) zero-valued samples to the end of the <em class="calibre7">h</em>(<em class="calibre7">k</em>) impulse response and perform an <em class="calibre7">N</em>-point FFT on the extended sequence, producing the complex <em class="calibre7">H</em>(<em class="calibre7">m</em>) sequence.</p>
<p class="indenthangingn1"><strong class="calibre9">3.</strong> Compute integer <em class="calibre7">M</em> using <em class="calibre7">M</em> = <em class="calibre7">N</em>−(<em class="calibre7">Q</em>−1).</p>
<p class="indenthangingn1"><strong class="calibre9">4.</strong> Append (<em class="calibre7">Q</em>−1) zero-valued samples to the end of the first <em class="calibre7">M</em> samples, <em class="calibre7">x</em><sub class="calibre12">1</sub>(<em class="calibre7">n</em>), of the original <em class="calibre7">x</em>(<em class="calibre7">n</em>) sequence, creating the first <em class="calibre7">N</em>-point FFT input sequence.</p>
<p class="indenthangingn1"><strong class="calibre9">5.</strong> Perform an <em class="calibre7">N</em>-point FFT on the first <em class="calibre7">N</em>-point FFT input sequence, multiply that FFT result by the <em class="calibre7">H</em>(<em class="calibre7">m</em>) sequence, and perform an <em class="calibre7">N</em>-point inverse FFT on the product. Retain the first <em class="calibre7">M</em> samples of the inverse FFT sequence, generating the first <em class="calibre7">M</em>-point output block of data <em class="calibre7">y</em><sub class="calibre12">1</sub>(<em class="calibre7">n</em>).</p>
<p class="indenthangingn1"><strong class="calibre9">6.</strong> Append (<em class="calibre7">Q</em>−1) zero-valued samples to the end of the second <em class="calibre7">M</em> samples, <em class="calibre7">x</em><sub class="calibre12">2</sub>(<em class="calibre7">n</em>), of the original <em class="calibre7">x</em>(<em class="calibre7">n</em>) sequence, creating the second <em class="calibre7">N</em>-point FFT input sequence.</p>
<p class="indenthangingn1"><strong class="calibre9">7.</strong> Perform an <em class="calibre7">N</em>-point FFT on the second <em class="calibre7">N</em>-point FFT input sequence, multiply that FFT result by the <em class="calibre7">H</em>(<em class="calibre7">m</em>) sequence, and perform an <em class="calibre7">N</em>-point inverse FFT on the product. Add the last (<em class="calibre7">Q</em>−1) samples from the previous inverse FFT to the first (<em class="calibre7">Q</em>−1) samples of the current inverse FFT sequence. Retain the first <em class="calibre7">M</em> samples of the sequence resulting from the (<em class="calibre7">Q</em>−1)-element addition process, generating the second <em class="calibre7">M</em>-point output block of data <em class="calibre7">y</em><sub class="calibre12">2</sub>(<em class="calibre7">n</em>).</p>
<p class="indenthangingn1"><strong class="calibre9">8.</strong> Repeat Steps 6 and 7 until we have gone through the entire original <em class="calibre7">x</em>(<em class="calibre7">n</em>) filter input sequence. Depending on the length <em class="calibre7">P</em> of the original <em class="calibre7">x</em>(<em class="calibre7">n</em>) input sequence and the chosen value for <em class="calibre7">N,</em> we must append anywhere from <em class="calibre7">Q</em>−1 to <em class="calibre7">N</em>−1 zero-valued samples to the end of the original <em class="calibre7">x</em>(<em class="calibre7">n</em>) input samples in order to accommodate the final block of forward and inverse FFT processing.</p>
<p class="indenthangingn1"><strong class="calibre9">9.</strong> Concatenate the <em class="calibre7">y</em><sub class="calibre12">1</sub>(<em class="calibre7">n</em>), <em class="calibre7">y</em><sub class="calibre12">2</sub>(<em class="calibre7">n</em>), <em class="calibre7">y</em><sub class="calibre12">3</sub>(<em class="calibre7">n</em>), . . . sequences shown in <a href="#calibre_link-1355">Figure 13-28(b)</a>, discarding any unnecessary trailing zero-valued samples, to generate your final linear-convolution filter output <em class="calibre7">y</em>(<em class="calibre7">n</em>) sequence.</p>
<p class="indenthangingn1"><strong class="calibre9">10.</strong> Finally, experiment with different values of <em class="calibre7">N</em> to see if there exists an <em class="calibre7">optimum N</em> that minimizes the computational workload for your hardware and software implementation. <em class="calibre7">N</em> must not be less than (<em class="calibre7">M</em>+<em class="calibre7">Q</em>−1). (Again, smaller <em class="calibre7">N</em> means many small-sized FFTs are needed, and large <em class="calibre7">N</em> means fewer, but larger-sized, FFTs are necessary.)</p>
<p class="calibre3"><a id="calibre_link-2391"></a>It’s useful to realize that the computational workload of these fast convolution filtering schemes does not change as <em class="calibre7">Q</em> increases in length up to a value of <em class="calibre7">N</em>. Another interesting aspect of fast convolution, from a hardware standpoint, is that the FFT indexing bit-reversal problem discussed in <a href="#calibre_link-603">Sections 4.5</a> and <a href="#calibre_link-604">4.6</a> is not an issue here. If the FFTs result in <em class="calibre7">X</em>(<em class="calibre7">m</em>) and <em class="calibre7">H</em>(<em class="calibre7">m</em>) having bit-reversed output sample indices, the multiplication can still be performed directly on the scrambled <em class="calibre7">H</em>(<em class="calibre7">m</em>) and <em class="calibre7">X</em>(<em class="calibre7">m</em>) sequences. Then an appropriate inverse FFT structure can be used that expects bit-reversed input data. That inverse FFT then provides an output sequence whose time-domain indexing is in the correct order. Neat!</p>
<p class="calibre3">By the way, it’s worth knowing that there are no restrictions on the filter’s finite-length <em class="calibre7">h</em>(<em class="calibre7">k</em>) impulse response&mdash;<em class="calibre7">h</em>(<em class="calibre7">k</em>) is not limited to being real-valued and symmetrical as is traditional with tapped-delay line FIR filters. Sequence <em class="calibre7">h</em>(<em class="calibre7">k</em>) can be complex-valued, asymmetrical (to achieve nonlinear-phase filtering), or whatever you choose.</p>
<p class="calibre3">One last issue to bear in mind: the complex amplitudes of the standard radix-2 FFT’s output samples are proportional to the FFT sizes, <em class="calibre7">N</em>, so the product of two FFT outputs will have a gain proportional to <em class="calibre7">N</em><sup class="calibre10">2</sup>. The inverse FFT has a normalizing gain reduction of only 1/<em class="calibre7">N</em>. As such, our fast convolution filtering methods will have an overall gain that is not unity. We suggest that practitioners give this gain normalization topic some thought during the design of their fast convolution system.</p>
<p class="calibre3">To summarize this frequency-domain filtering discussion, the two fast convolution filtering schemes can be computationally efficient, compared to standard tapped-delay line FIR convolution filtering, particularly when the <em class="calibre7">x</em>(<em class="calibre7">n</em>) input sequence is large and high-performance filtering is needed (requiring many filter taps, i.e., <em class="calibre7">Q</em> = 40 to 80). As for which method, overlap-and-save or overlap-and-add, should be used in any given situation, there is no simple answer. Choosing a fast convolution method depends on many factors: the fixed/floating-point arithmetic used, memory size and access latency, computational hardware architecture, and specialized built-in filtering instructions, etc.</p>
<p class="calibre3"><a id="calibre_link-683"></a></p>
<h3 class="calibre6">13.11 Generating Normally Distributed Random Data</h3>
<p class="calibre3"><a href="#calibre_link-728">Section D.7</a> in <a href="#calibre_link-27">Appendix D</a> discusses the normal distribution curve as it relates to random data. A problem we may encounter is how actually to generate random data samples whose distribution follows that normal (Gaussian) curve. There’s a straightforward way to solve this problem using any software package that can generate uniformly distributed random data, as most of them do<a href="#calibre_link-1356">[27]</a>. <a href="#calibre_link-1357">Figure 13-29</a> shows our situation pictorially where we require <a id="calibre_link-2047"></a>random data that’s distributed normally with a mean (average) of μ′ and a standard deviation of σ′, as in <a href="#calibre_link-1357">Figure 13-29(a)</a>, and all we have available is a software routine that generates random data that’s uniformly distributed between zero and one as in <a href="#calibre_link-1357">Figure 13-29(b)</a>.</p>
<p class="caption"><a id="calibre_link-1357"></a><strong class="calibre9">Figure 13-29</strong> Probability distribution functions: (a) normal distribution with mean = μ′ and standard deviation σ′; (b) uniform distribution between zero and one.</p>
<p class="image"><img src="images/001809.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">As it turns out, there’s a principle in advanced probability theory, known as the <em class="calibre7">Central Limit Theorem</em>, that says when random data from an arbitrary distribution is summed over <em class="calibre7">M</em> samples, the probability distribution of the sum begins to approach a normal distribution as <em class="calibre7">M</em> increases[<a href="#calibre_link-1358">28</a>&ndash;<a href="#calibre_link-1359">30</a>]. In other words, if we generate a set of <em class="calibre7">N</em> random samples that are uniformly distributed between zero and one, we can begin adding other sets of <em class="calibre7">N</em> samples to the first set. As we continue summing additional sets, the distribution of the <em class="calibre7">N</em>-element set of sums becomes more and more <em class="calibre7">normal</em>. We can sound impressive and state that “the sum becomes asymptotically normal.” Experience has shown that for practical purposes, if we sum <em class="calibre7">M</em> ≥ 30 times, the summed data distribution is essentially normal. With this rule in mind, we’re halfway to solving our problem.</p>
<p class="calibre3">After summing <em class="calibre7">M</em> sets of uniformly distributed samples, the summed set <em class="calibre7">y</em><sub class="calibre12">sum</sub> will have a distribution as shown in <a href="#calibre_link-1360">Figure 13-30</a>.</p>
<p class="caption"><a id="calibre_link-1360"></a><strong class="calibre9">Figure 13-30</strong> Probability distribution of the summed set of random data derived from uniformly distributed data.</p>
<p class="image"><img src="images/000811.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Because we’ve summed <em class="calibre7">M</em> data sets whose mean values were all 0.5, the mean of <em class="calibre7">y</em><sub class="calibre12">sum</sub> is the sum of those <em class="calibre7">M</em> means, or μ = <em class="calibre7">M</em>/2. From <a href="#calibre_link-556">Section D.6</a> of <a id="calibre_link-2356"></a><a href="#calibre_link-27">Appendix D</a> we know the variance of a single data sample set, having the probability distribution in <a href="#calibre_link-1357">Figure 13-29(b)</a>, is 1/12. Because the variance of the sum of <em class="calibre7">M</em> data sets is equal to the sum of their individual variances, we can say</p>
<p class="caption"><a id="calibre_link-3272"></a>(13-68)</p>
<p class="image"><img src="images/001035.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">and</p>
<p class="caption"><a id="calibre_link-3273"></a>(13-69)</p>
<p class="image"><img src="images/000086.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">So, here’s the trick: To convert the <em class="calibre7">y</em><sub class="calibre12">sum</sub> data set to our desired data set having a mean of μ′ and a standard deviation of σ′, we</p>
<p class="indenthangingn1"><strong class="calibre9">1.</strong> subtract <em class="calibre7">M</em>/2 from each element of <em class="calibre7">y</em><sub class="calibre12">sum</sub> to shift its mean to zero;</p>
<p class="indenthangingn1"><strong class="calibre9">2.</strong> scale <em class="calibre7">y</em><sub class="calibre12">sum</sub> so that its standard deviation is the desired σ′, by multiplying each sample in the shifted data set by σ′/σ; and</p>
<p class="indenthangingn1"><strong class="calibre9">3.</strong> finally, center the new data set at the desired μ′ value by adding μ′ to each sample of the scaled data set.</p>
<p class="calibre3">If we call our desired normally distributed random data set <em class="calibre7">y</em><sub class="calibre12">desired</sub>, then the <em class="calibre7">n</em>th element of that set is described mathematically as</p>
<p class="caption"><a id="calibre_link-3274"></a>(13-70)</p>
<p class="image"><img src="images/001794.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Our discussion thus far has had a decidedly software algorithm flavor, but hardware designers also occasionally need to generate normally distributed random data at high speeds in their designs. For you hardware designers, reference <a href="#calibre_link-1359">[30]</a> presents an efficient hardware design technique to generate normally distributed random data using fixed-point arithmetic integrated circuits.</p>
<p class="calibre3">The above method for generating normally distributed random numbers works reasonably well, but its results are not perfect because the tails of the probability distribution curve in <a href="#calibre_link-1360">Figure 13-30</a> are not perfectly Gaussian.<sup class="calibre10"><a id="calibre_link-1364"></a><a href="#calibre_link-1361">†</a></sup> An advanced, and more statistically correct (improved randomness), technique that you may want to explore is called the Ziggurat method[<a href="#calibre_link-1362">31</a>&ndash;<a href="#calibre_link-1363">33</a>].</p>
<p class="footnotes"><a id="calibre_link-1361"></a><sup class="calibre11"><a href="#calibre_link-1364">†</a></sup> I thank my DSP pal Dr. Peter Kootsookos, of UTC Fire and Security, Farmington, Connecticut, for his advice on this issue.</p>
<p class="calibre3"><a id="calibre_link-105"></a></p>
<h3 class="calibre6"><a id="calibre_link-2217" class="calibre5"></a>13.12 Zero-Phase Filtering</h3>
<p class="calibre3">You can cancel the nonlinear phase effects of an IIR filter by following the process shown in <a href="#calibre_link-1365">Figure 13-31(a)</a>. The <em class="calibre7">y</em>(<em class="calibre7">n</em>) output will be a filtered version of <em class="calibre7">x</em>(<em class="calibre7">n</em>) with no filter-induced phase distortion. The same IIR filter is used twice in this scheme, and the time reversal step is a straight left-right flipping of a time-domain sequence. Consider the following. If some spectral component in <em class="calibre7">x</em>(<em class="calibre7">n</em>) has an arbitrary phase of α degrees, and the first filter induces a phase shift of −β degrees, that spectral component’s phase at node A will be α−β degrees. The first time reversal step will conjugate that phase and induce an additional phase shift of −θ degrees. (<a href="#calibre_link-295">Appendix C</a> explains this effect.) Consequently, the component’s phase at node B will be −α+β−θ degrees. The second filter’s phase shift of −β degrees yields a phase of −α−θ degrees at node C. The final time reversal step (often omitted in literary descriptions of this zero-phase filtering process) will conjugate that phase and again induce an additional phase shift of −θ degrees. Thankfully, the spectral component’s phase in <em class="calibre7">y</em>(<em class="calibre7">n</em>) will be α+θ−θ = α degrees, the same phase as in <em class="calibre7">x</em>(<em class="calibre7">n</em>). This property yields an overall filter whose phase response is zero degrees over the entire frequency range.</p>
<p class="caption"><a id="calibre_link-1365"></a><strong class="calibre9">Figure 13-31</strong> Two equivalent zero-phase filtering techniques.</p>
<p class="image"><img src="images/001694.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">An equivalent zero-phase filter is presented in <a href="#calibre_link-1365">Figure 13-31(b)</a>. Of course, these methods of zero-phase filtering cannot be performed in real time because we can’t reverse the flow of time (at least not in our universe). This filtering is a <em class="calibre7">block processing</em>, or <em class="calibre7">off-line,</em> process, such as filtering an audio file stored in a computer. We must have all the time samples available before we start processing. The initial time reversal in <a href="#calibre_link-1365">Figure 13-31(b)</a> illustrates this restriction.</p>
<p class="calibre3">There will be filter transient effects at the beginning and end of the filtered sequences. If transient effects are bothersome in a given application, consider discarding <em class="calibre7">L</em> samples from the beginning and end of the final <em class="calibre7">y</em>(<em class="calibre7">n</em>) time sequence, where <em class="calibre7">L</em> is four (or five) times the order of the IIR filter.</p>
<p class="calibre3">By the way, the final peak-to-peak passband ripple (in dB) of this zero-phase filtering process will be twice the peak-to-peak passband ripple of the single IIR filter. The final stopband attenuation will also be double that of the single filter.</p>
<p class="calibre3"><a id="calibre_link-684"></a></p>
<h3 class="calibre6"><a id="calibre_link-2214" class="calibre5"></a>13.13 Sharpened FIR Filters</h3>
<p class="calibre3">Here’s an interesting technique for improving the stopband attenuation of a digital filter under the condition that we’re unable, for whatever reason, to modify that filter’s coefficients. Actually, we can double a filter’s stopband attenuation by cascading the filter with itself. This works, as shown in <a href="#calibre_link-1366">Figure 13-32(a)</a>, where the frequency magnitude response of a single filter is a dashed curve |<em class="calibre7">H</em>(<em class="calibre7">m</em>)| and the response of the filter cascaded with itself is represented by the solid curve |<em class="calibre7">H</em><sup class="calibre10">2</sup>(<em class="calibre7">m</em>)|. The problem with this simple cascade idea is that it also doubles the passband peak-to-peak ripple as shown in <a href="#calibre_link-1366">Figure 13-32(b)</a>. The frequency axis in <a href="#calibre_link-1366">Figure 13-32</a> is normalized such that a value of 0.5 represents half the signal sample rate.</p>
<p class="caption"><a id="calibre_link-1366"></a><strong class="calibre9">Figure 13-32</strong> Frequency magnitude responses of a single filter and that filter cascaded with itself: (a) full response; (b) passband detail.</p>
<p class="image"><img src="images/000716.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Well, there’s a better scheme for improving the stopband attenuation performance of a filter and avoiding passband ripple degradation without actually changing the filter’s coefficients. The technique is called <em class="calibre7">filter sharpening</em><a href="#calibre_link-1367">[34]</a> and is shown as <em class="calibre7">H</em><sub class="calibre12">s</sub> in <a href="#calibre_link-1368">Figure 13-33</a>.</p>
<p class="caption"><a id="calibre_link-1368"></a><strong class="calibre9">Figure 13-33</strong> Filter sharpening process.</p>
<p class="image"><img src="images/001571.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The delay element in <a href="#calibre_link-1368">Figure 13-33</a> is equal to (<em class="calibre7">N</em>−1)/2 samples where <em class="calibre7">N</em> is the number of <em class="calibre7">h</em>(<em class="calibre7">k</em>) coefficients, the unit-impulse response length, in the original <em class="calibre7">H</em>(<em class="calibre7">m</em>) FIR filter. Using the sharpening process results in the improved |<em class="calibre7">H</em><sub class="calibre12">s</sub>(<em class="calibre7">m</em>)| filter performance shown as the solid curve in <a href="#calibre_link-1369">Figure 13-34</a>, where we see the increased stopband attenuation and reduced passband ripple beyond that afforded by the original <em class="calibre7">H</em>(<em class="calibre7">m</em>) filter. Because of the delayed time-alignment constraint, filter sharpening is not applicable to filters having non-constant group delay, such as minimum-phase FIR filters or IIR filters.</p>
<p class="caption"><a id="calibre_link-1369"></a><strong class="calibre9">Figure 13-34</strong> |<em class="calibre7">H</em>(<em class="calibre7">m</em>)| and |<em class="calibre7">H<sub class="calibre12">s</sub></em>(<em class="calibre7">m</em>)| performance: (a) full frequency response; (b) passband detail.</p>
<p class="image"><img src="images/000596.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">If need be, we can eliminate the multipliers shown in <a href="#calibre_link-1368">Figure 13-33</a>. The multiply by two operation can be implemented with an arithmetic left shift by one binary bit. The multiply by three operation can be implemented by adding the Delay output sample to a shifted-left-by-one-bit version of itself.</p>
<p class="calibre3"><a id="calibre_link-3275"></a>Be aware that the gain factors in <a href="#calibre_link-1368">Figure 13-33</a> are based on the assumption that the original <em class="calibre7">h</em>(<em class="calibre7">k</em>) filter to be sharpened has a passband gain of one. If the <em class="calibre7">h</em>(<em class="calibre7">k</em>) filter has a non-unity passband gain of <em class="calibre7">G</em> ≠ 1, then the network in <a href="#calibre_link-1370">Figure 13-35(a)</a> should be used, where the alternate constant gain factors provide optimum filter sharpening. On the other hand, the <a href="#calibre_link-1370">Figure 13-35(a)</a> gain factors can be modified to some extent if doing so simplifies the filter implementation. For example, if 2/<em class="calibre7">G</em><sup class="calibre10">2</sup> = 1.7, for ease of implementation, the practitioner should try using a factor of 2 in place of the factor 1.7. Using a gain factor of 2 will not be optimum but it may well be acceptable, depending on the characteristics of the filter to be sharpened. Software modeling will resolve this issue.</p>
<p class="caption"><a id="calibre_link-1370"></a><strong class="calibre9">Figure 13-35</strong> Non-unity gain filter sharpening: (a) low-order sharpening; (b) higher-order sharpening for increased stopband attenuation.</p>
<p class="image"><img src="images/000326.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">If additional stopband attenuation is needed, then the process shown in <a href="#calibre_link-1370">Figure 13-35(b)</a> can be used, where again the Delay element is equal to (<em class="calibre7">N</em>-1)/2 unit delays.</p>
<p class="calibre3">In real-time applications, the filter sharpening networks we presented are straightforward and applicable to linear-phase lowpass, bandpass, and highpass FIR filters, just so long as the original filter’s <em class="calibre7">H</em>(<em class="calibre7">f</em>) has an integer group delay. (That restriction is necessary because the number of unit delays <a id="calibre_link-2002"></a>of the Delay element, needed for time synchronization in real-time systems, in the parallel path must be an integer.) This sharpening procedure is particularly useful if the original filter hardware is constrained to have some fixed number of bits to represent its coefficients. If an FIR filter’s coefficient bit width is <em class="calibre7">b</em> bits, the filter sharpening process in <a href="#calibre_link-1368">Figure 13-33</a> can, luckily for us, achieve the performance of filters having (<em class="calibre7">b</em> + 4)-bit coefficients. So, if our hardware forces us to use, say, 8-bit coefficients, we can achieve roughly 12-bit-coefficient filter performance.</p>
<p class="calibre3">Filter sharpening can be used whenever a given filter response cannot be modified, such as an unchangeable software subroutine, and can even be applied to cascaded integrator-comb (CIC) filters to flatten their passband responses, as well as FIR fixed-point multiplierless filters where the coefficients are constrained to be powers of two[<a href="#calibre_link-1371">35</a>,<a href="#calibre_link-1372">36</a>].</p>
<p class="calibre3">As a historical aside, <em class="calibre7">filter sharpening</em> is a process refined and expanded by the accomplished R. Hamming (of Hamming window fame) based on an idea originally proposed by the great American mathematician John Tukey, the inventor of the radix-2 fast Fourier transform (FFT).</p>
<p class="calibre3"><a id="calibre_link-685"></a></p>
<h3 class="calibre6">13.14 Interpolating a Bandpass Signal</h3>
<p class="calibre3">There are many digital communications applications where a real signal is centered at one-fourth the sample rate, or <em class="calibre7">f<sub class="calibre12">s</sub></em>/4. This condition makes quadrature down-conversion particularly simple. (See <a href="#calibre_link-644">Sections 8.9</a> and <a href="#calibre_link-339">13.1</a>.) In the <a id="calibre_link-3276"></a>event that you’d like to generate an interpolated (increased sample rate) version of the bandpass signal but maintain its <em class="calibre7">f<sub class="calibre12">s</sub></em>/4 center frequency, there’s an efficient way to do so<a href="#calibre_link-1373">[37]</a>. Suppose we want to interpolate by a factor of two so the output sample rate is twice the input sample rate, <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">-out</sub> = 2<em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">-in</sub>. In this case the process is: quadrature down-conversion by <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">-in</sub>/4, interpolation factor of two, quadrature up-conversion by <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">-out</sub>/4, and then take only the real part of the complex upconverted sequence. The implementation of this scheme is shown at the top of <a href="#calibre_link-1374">Figure 13-36</a>.</p>
<p class="caption"><a id="calibre_link-1374"></a><strong class="calibre9">Figure 13-36</strong> Bandpass signal interpolation scheme, and spectra.</p>
<p class="image"><img src="images/000496.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The sequences applied to the first multiplier in the top signal path are the real <em class="calibre7">x</em>(<em class="calibre7">n</em>) input and the repeating mixing sequence 1,0,−1,0. That mixing sequence is the real (or in-phase) part of the comple<em class="calibre7">x</em> e<em class="calibre7">x</em>ponential</p>
<p class="caption"><a id="calibre_link-3277"></a>(13-71)</p>
<p class="image"><img src="images/000818.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">needed for quadrature down-conversion by <em class="calibre7">f<sub class="calibre12">s</sub></em>/4. Likewise, the repeating mixing sequence 0,−1,0,1 applied to the first multiplier in the bottom path is the <a id="calibre_link-2442"></a>imaginary (or quadrature phase) part of the complex down-conversion exponential <em class="calibre7">e</em><sup class="calibre10">−<em class="calibre7">j</em>2π(<em class="calibre7">f<sub class="calibre15">s</sub></em><sub class="calibre15">-in</sub>/4)<em class="calibre7">t<sub class="calibre15">s</sub></em><sub class="calibre15">-in</sub></sup>. The “↑2” symbol means insert one zero-valued sample between each sample at the A nodes. The final subtraction to obtain <em class="calibre7">y</em>(<em class="calibre7">n</em>) is how we extract the real part of the comple<em class="calibre7">x</em> sequence at Node D. (That is, we’re extracting the real part of the product of the complex signal at Node C times <em class="calibre7">e<sup class="calibre10">j</sup></em><sup class="calibre10">2π(1/4)</sup>.) The spectra at various nodes of this process are shown at the bottom of <a href="#calibre_link-1370">Figure 13-35</a>. The shaded spectra indicate true spectral components, while the white spectra represent spectral replications. Of course, the same lowpass filter must be used in both processing paths to maintain the proper time delay and orthogonal phase relationships.</p>
<p class="calibre3">There are several additional issues worth considering regarding this interpolation process<a href="#calibre_link-1375">[38]</a>. If the amplitude loss, inherent in interpolation, of a factor of two is bothersome, we can make the final mixing sequences 2,0,−2,0 and 0,2,0,−2 to compensate for that loss. Because there are so many zeros in the sequences at Node B (three-fourths of the samples), we should consider those efficient polyphase filters for the lowpass filtering. Finally, if it’s sensible in your implementation, consider replacing the final adder with a multiplexer (because alternate samples of the sequences at Node D are zeros). In this case, the mixing sequence in the bottom path would be changed to 0,−1,0,1.</p>
<p class="calibre3"><a id="calibre_link-686"></a></p>
<h3 class="calibre6">13.15 Spectral Peak Location Algorithm</h3>
<p class="calibre3">In the practical world of discrete spectrum analysis, we often want to estimate the frequency of a sinusoid (or the center frequency of a very narrowband signal of interest). Upon applying the radix-2 fast Fourier transform (FFT), our narrowband signals of interest rarely reside exactly on an FFT bin center whose frequency is exactly known. As such, due to the FFT’s leakage properties, the discrete spectrum of a sinusoid having <em class="calibre7">N</em> time-domain samples may look like the magnitude samples shown in <a href="#calibre_link-1376">Figure 13-37(a)</a>. There we see the sinusoid’s spectral peak residing between the FFT’s <em class="calibre7">m</em> = 5 and <em class="calibre7">m</em> = 6 bin centers. (Variable <em class="calibre7">m</em> is an <em class="calibre7">N</em>-point FFT’s frequency-domain index. The FFT bin spacing is <em class="calibre7">f<sub class="calibre12">s</sub></em>/<em class="calibre7">N</em> where, as always, <em class="calibre7">f<sub class="calibre12">s</sub></em> is the sample rate.) Close examination of <a href="#calibre_link-1376">Figure 13-37(a)</a> allows us to say the sinusoid lies in the range of <em class="calibre7">m</em> = 5 and <em class="calibre7">m</em> = 5.5, because we see that the maximum spectral sample is closer to the <em class="calibre7">m</em> = 5 bin center than the <em class="calibre7">m</em> = 6 bin center. The real-valued sinusoidal time signal has, in this example, a frequency of 5.25<em class="calibre7">f<sub class="calibre12">s</sub></em>/<em class="calibre7">N</em> Hz. In this situation, our frequency estimation resolution is half the FFT bin spacing. We often need better frequency estimation resolution, and there are indeed several ways to improve that resolution.</p>
<p class="caption"><a id="calibre_link-1376"></a><strong class="calibre9">Figure 13-37</strong> Spectral magnitudes: (a) <em class="calibre7">N</em>-point FFT; (b) 4<em class="calibre7">N</em>-point FFT.</p>
<p class="image"><img src="images/001788.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">We could collect, say, 4<em class="calibre7">N</em> time-domain signal samples and perform a 4<em class="calibre7">N</em>-point FFT, yielding a reduced bin spacing of <em class="calibre7">f<sub class="calibre12">s</sub></em>/4<em class="calibre7">N</em>. Or we could pad (append to the end of the original time samples) the original <em class="calibre7">N</em> time samples with 3<em class="calibre7">N</em> zero-valued samples and perform a 4<em class="calibre7">N</em>-point FFT on the lengthened time sequence. <a id="calibre_link-2471"></a>That would also provide an improved spectral peak estimation granularity of <em class="calibre7">f<sub class="calibre12">s</sub></em>/4<em class="calibre7">N</em>, as shown in <a href="#calibre_link-1376">Figure 13-37(b)</a>. With the spectral peak located at bin <em class="calibre7">m</em><sub class="calibre12">peak</sub> = 21, we estimate the signal’s center frequency, in Hz, using <em class="calibre7">f</em><sub class="calibre12">peak</sub> = <em class="calibre7">m</em><sub class="calibre12">peak</sub><em class="calibre7">f</em><sub class="calibre12">s</sub>/4<em class="calibre7">N</em>.</p>
<p class="calibre3">Both schemes, <em class="calibre7">collect more data</em> and <em class="calibre7">zero padding</em>, are computationally expensive. Many other techniques for enhanced-precision tone frequency measurement have been described in the scientific literature&mdash;from the close-to-home field of geophysics to the lofty studies of astrophysics&mdash;but most of those schemes seek precision without regard to computational complexity. Here we describe several computationally simple frequency estimation schemes.</p>
<p class="calibre3">Assume we have the <em class="calibre7">X</em>(<em class="calibre7">m</em>) spectral samples from an <em class="calibre7">N</em>-point FFT of a sinusoidal time signal, whose magnitudes are shown in <a href="#calibre_link-1377">Figure 13-38(a)</a>. (The vertical magnitude axis is linear, not logarithmic.) The notation in the figure is that <em class="calibre7">m<sub class="calibre12">k</sub></em> is the integer index of the largest magnitude sample |<em class="calibre7">X</em>(<em class="calibre7">m<sub class="calibre12">k</sub></em>)|. The value <em class="calibre7">m</em><sub class="calibre12">peak</sub>, which in general will not be an integer, is the value we wish to estimate and use in</p>
<p class="caption"><a id="calibre_link-3278"></a>(13-72)</p>
<p class="image"><img src="images/001677.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-1377"></a><strong class="calibre9">Figure 13-38</strong> Spectral peak detection: (a) FFT magnitudes; (b) <em class="calibre7">m</em><sub class="calibre12">peak</sub> error by naive assignment; (c) <em class="calibre7">m</em><sub class="calibre12">peak</sub> algorithm error performance.</p>
<p class="image"><img src="images/000391.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">to accurately estimate the sinusoid’s center frequency in Hz.</p>
<p class="calibre3"><a id="calibre_link-3279"></a>Next, let’s say the FFT’s input sinusoid sweeps in frequency starting at the FFT’s <em class="calibre7">m<sub class="calibre12">k</sub></em> bin center frequency to the center frequency of the <em class="calibre7">m<sub class="calibre12">k</sub></em><sub class="calibre12">+1</sub> bin and we assign <em class="calibre7">m</em><sub class="calibre12">peak</sub> to be equal to the index value (either <em class="calibre7">m<sub class="calibre12">k</sub></em> or <em class="calibre7">m<sub class="calibre12">k</sub></em><sub class="calibre12">+1</sub>) of the highest spectral magnitude sample. The error in that <em class="calibre7">m</em><sub class="calibre12">peak</sub> value will be that shown in <a href="#calibre_link-1377">Figure 13-38(b)</a>. The maximum error in that naive <em class="calibre7">m</em><sub class="calibre12">peak</sub> assignment scheme is 0.5 FFT bins (half the FFT bin spacing). Happily for us, there are more accurate methods for estimating <em class="calibre7">m</em><sub class="calibre12">peak</sub>.</p>
<p class="calibre3">As it turns out, we can estimate the signal’s index-based center frequency, <em class="calibre7">m</em><sub class="calibre12">peak</sub>, using</p>
<p class="caption"><a id="calibre_link-3280"></a>(13-73)</p>
<p class="image"><img src="images/000698.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where <em class="calibre7">C<sub class="calibre12">i</sub></em> is a scalar correction factor in the range of −0.5 ≤ <em class="calibre7">C<sub class="calibre12">i</sub></em> ≤ 0.5. There are many algorithms, based on fitting a generic parabolic curve to the |<em class="calibre7">X</em>(<em class="calibre7">m</em>)| samples, floating around in the literature of DSP for estimating <em class="calibre7">C<sub class="calibre12">i</sub></em>. Those algorithms have varying degrees of accuracy depending on the window function applied to the FFT’s input samples.</p>
<p class="calibre3"><a id="calibre_link-2030"></a>A noteworthy correction factor expression is</p>
<p class="caption"><a id="calibre_link-1378"></a>(13-74)</p>
<p class="image"><img src="images/001558.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">This complex-valued spectral peak location estimation algorithm is quite accurate for its simplicity<a href="#calibre_link-1243">[3]</a>. Its maximum frequency estimation error is roughly 0.06, 0.04, and 0.03 bin widths for signal-to-noise ratios of 3, 6, and 9 dB respectively. Not bad at all! The nice features of the algorithm are that it does not require the original time samples to be windowed, as do some other spectral peak location algorithms; and it does not require computation of FFT magnitude samples.</p>
<p class="calibre3">If a time-domain window sequence has been applied to the FFT’s input samples, then other <em class="calibre7">C<sub class="calibre12">i</sub></em> correction factor expressions should be used in place of <a href="#calibre_link-1378">Eq. (13-74)</a>. Three notable candidate expressions for <em class="calibre7">C<sub class="calibre12">i</sub></em> are</p>
<p class="caption"><a id="calibre_link-1379"></a>(13-75)</p>
<p class="image"><img src="images/000582.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-1380"></a>(13-75′)</p>
<p class="image"><img src="images/001443.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-1382"></a>(13-75″)</p>
<p class="image"><img src="images/000646.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where again we use subscripts on <em class="calibre7">C</em> merely to identify the different expressions for the correction factor <em class="calibre7">C<sub class="calibre12">i</sub></em>. The above window-dependent <em class="calibre7">P</em> and <em class="calibre7">Q</em> factors, determined empirically, are</p>
<p class="indenthangingb">• Hamming, <em class="calibre7">P</em> = 1.22, <em class="calibre7">Q</em> = 0.60;</p>
<p class="indenthangingb">• Hanning, <em class="calibre7">P</em> = 1.36, <em class="calibre7">Q</em> = 0.55;</p>
<p class="indenthangingb">• Blackman, <em class="calibre7">P</em> = 1.75, <em class="calibre7">Q</em> = 0.55; and</p>
<p class="indenthangingb">• Blackman-Harris (3-term), <em class="calibre7">P</em> = 1.72, <em class="calibre7">Q</em> = 0.56.</p>
<p class="calibre3"><a href="#calibre_link-1379">Equation (13-75)</a> is the best known peak location algorithm and has been used in the DSP business for decades. The lesser-known <a href="#calibre_link-1380">Eq. (13-75′)</a> provides a more accurate windowed-FFT peak location estimate than <a href="#calibre_link-1379">Eq. (13-75)</a><a href="#calibre_link-1381">[39]</a>. Inspired by <a href="#calibre_link-1378">Eqs. (13-74)</a> and <a href="#calibre_link-1380">(13-75′)</a>, the author has developed <a href="#calibre_link-1382">Eq. (13-75″)</a> which can be used in case the FFT magnitude samples are unavailable for use in <a href="#calibre_link-1380">Eq. (13-75′)</a>. <a href="#calibre_link-1382">Equation (13-75″)</a> is also more accurate than the better-known <a href="#calibre_link-1379">Eq. (13-75)</a>.</p>
<p class="calibre3">The solid curve in <a href="#calibre_link-1377">Figure 13-38(c)</a> shows the <em class="calibre7">m</em><sub class="calibre12">peak</sub> error in using <a href="#calibre_link-1380">Eq. (13-75′)</a> with Blackman-windowed time-domain samples whose signal-to-noise <a id="calibre_link-2115"></a>ratio is 9 dB. For comparison, the dashed curve is the <em class="calibre7">m</em><sub class="calibre12">peak</sub> error when using <a href="#calibre_link-1379">Eq. (13-75)</a>. <a href="#calibre_link-1382">Equation (13-75″)</a>’s accuracy is very similar to that of <a href="#calibre_link-1380">Eq. (13-75′)</a>.</p>
<p class="calibre3"><a href="#calibre_link-1378">Equations (13-74)</a> and <a href="#calibre_link-1382">(13-75″)</a> have the advantage that FFT magnitude calculations, with their computationally costly square root operations, are not required as is necessary with other spectral peak location algorithms described above. However, the question naturally arises, “How do we determine the index <em class="calibre7">m<sub class="calibre12">k</sub></em> of the largest-magnitude FFT sample, |<em class="calibre7">X</em>(<em class="calibre7">m<sub class="calibre12">k</sub></em>)|, in <a href="#calibre_link-1377">Figure 13-38(a)</a> without computing square roots to obtain FFT magnitudes?” The answer is that we can use the complex vector-magnitude approximations, requiring no square root computations, described in <a href="#calibre_link-678">Section 13.2</a>.</p>
<p class="calibre3">Be aware that the above spectral peak location methods are only applicable when the majority of the signal’s spectral energy lies within a single FFT bin width (<em class="calibre7">f<span class="underline"><sub class="calibre12">s</sub></span></em>/<em class="calibre7">N</em>), and the FFT spectral samples are not substantially contaminated by <em class="calibre7">leakage</em> from another spectral component.</p>
<p class="calibre3"><a id="calibre_link-687"></a></p>
<h3 class="calibre6">13.16 Computing FFT Twiddle Factors</h3>
<p class="calibre3">Typical applications using an <em class="calibre7">N</em>-point radix-2 FFT accept <em class="calibre7">N x</em>(<em class="calibre7">n</em>) input time samples and compute <em class="calibre7">N X</em>(<em class="calibre7">m</em>) frequency-domain samples. However, there are non-standard FFT applications (for example, specialized harmonic analysis, or perhaps using an FFT to implement a bank of filters) where only a subset of the full <em class="calibre7">X</em>(<em class="calibre7">m</em>) results is required. Consider <a href="#calibre_link-1383">Figure 13-39</a> which shows the butterfly operations for an 8-point radi<em class="calibre7">x</em>-2 decimation-in-frequency FFT. Notice that the FFT butterflies in <a href="#calibre_link-1383">Figure 13-39</a> are the optimized butterflies introduced in <a href="#calibre_link-43">Figure 4-14</a>. Assuming we are only interested in the <em class="calibre7">X</em>(3) and <em class="calibre7">X</em>(7) output samples, rather than compute the entire FFT we perform only the computations indicated by the bold lines in the figure.</p>
<p class="caption"><a id="calibre_link-1383"></a><strong class="calibre9">Figure 13-39</strong> Eight-point decimation-in-frequency FFT signal-flow diagram.</p>
<p class="image"><img src="images/001242.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Reduced-computation FFTs are often called <em class="calibre7">pruned FFTs</em>[<a href="#calibre_link-1384">40</a>-<a href="#calibre_link-1385">43</a>]. To implement pruned FFTs we need to know the twiddle phase angles associated with each necessary butterfly computation in the paths of any bold signal-flow line in <a href="#calibre_link-1383">Figure 13-39</a>. (As we did in <a href="#calibre_link-288">Chapter 4</a> for simplicity, the butterflies in <a href="#calibre_link-1383">Figure 13-39</a> only show the twiddle phase-angle factors and not the entire complex-valued twiddle factors.) Here we show how to compute those individual twiddle phase angles.</p>
<p class="calibre3"><a id="calibre_link-3281"></a></p>
<h4 class="calibre13">13.16.1 Decimation-in-Frequency FFT Twiddle Factors</h4>
<p class="calibre3">For the decimation-in-frequency (DIF) radix-2 FFT using the optimized butterflies:</p>
<p class="indenthangingb">• The <em class="calibre7">N</em>-point DIF FFT has log<sub class="calibre12">2</sub>(<em class="calibre7">N</em>) stages, numbered <em class="calibre7">P</em> = 1, 2, ..., log<sub class="calibre12">2</sub>(<em class="calibre7">N</em>).</p>
<p class="indenthangingb"><a id="calibre_link-2116"></a>• Each stage comprises <em class="calibre7">N</em>/2 butterflies.</p>
<p class="indenthangingb">• Not counting the −1 twiddle factors, the <em class="calibre7">P</em>th stage has <em class="calibre7">N</em>/2<em class="calibre7"><sup class="calibre10">P</sup></em> unique twiddle factors, numbered <em class="calibre7">k</em> = 0, 1, 2, ... , <em class="calibre7">N</em>/2<em class="calibre7"><sup class="calibre10">P</sup></em>−1 as indicated by the upward arrows at the bottom of <a href="#calibre_link-1383">Figure 13-39</a>.</p>
<p class="calibre3">Given those characteristics, the <em class="calibre7">k</em>th unique twiddle factor phase angle for the <em class="calibre7">P</em>th stage is computed using</p>
<p class="caption"><a id="calibre_link-3282"></a>(13-76)</p>
<p class="image"><img src="images/001340.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where 0 ≤ <em class="calibre7">k</em> ≤ <em class="calibre7">N</em>/2<em class="calibre7"><sup class="calibre10">P</sup></em>−1. For example, for the second stage (<em class="calibre7">P</em> = 2) of an <em class="calibre7">N</em> = 8-point DIF FFT, the unique twiddle factor angles are</p>
<p class="indenthanging1"><em class="calibre7">k</em> = 0, angle = 0·2<em class="calibre7"><sup class="calibre10">P</sup></em>/2 = 0·4/2 = 0<br class="calibre1" /><em class="calibre7">k</em> = 1, angle = 1·2<em class="calibre7"><sup class="calibre10">P</sup></em>/2 = 1·4/2 = 2.</p>
<p class="calibre3"><a id="calibre_link-3283"></a></p>
<h4 class="calibre13">13.16.2 Decimation-in-Time FFT Twiddle Factors</h4>
<p class="calibre3">Here we present an interesting algorithm for computing the individual twiddle factor angles of a radix-2 decimation-in-time (DIT) FFT<a href="#calibre_link-1386">[44]</a>. Consider <a href="#calibre_link-1387">Figure 13-40</a> showing the butterfly signal flow of an 8-point DIT FFT.</p>
<p class="caption"><a id="calibre_link-1387"></a><strong class="calibre9">Figure 13-40</strong> Eight-point decimation-in-time FFT signal-flow diagram.</p>
<p class="image"><img src="images/001651.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3284"></a>For the decimation-in-time (DIT) FFT using the optimized butterflies:</p>
<p class="indenthangingb">• The <em class="calibre7">N</em>-point DIT FFT has log<sub class="calibre12">2</sub>(<em class="calibre7">N</em>) stages, numbered <em class="calibre7">P</em> = 1, 2, . . ., log<sub class="calibre12">2</sub>(<em class="calibre7">N</em>).</p>
<p class="indenthangingb">• Each stage comprises <em class="calibre7">N</em>/2 butterflies.</p>
<p class="indenthangingb">• Not counting the −1 twiddle factors, the <em class="calibre7">P</em>th stage has <em class="calibre7">N</em>/2 twiddle factors, numbered <em class="calibre7">k</em> = 0, 1, 2, ... , <em class="calibre7">N</em>/2−1 as indicated by the upward arrows at the bottom of <a href="#calibre_link-1387">Figure 13-40</a>.</p>
<p class="calibre3">Given those characteristics, the <em class="calibre7">k</em>th twiddle factor phase angle for the <em class="calibre7">P</em>th stage is computed using</p>
<p class="caption"><a id="calibre_link-1388"></a>(13-76′)</p>
<p class="image"><img src="images/000376.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where 0 ≤ <em class="calibre7">k</em> ≤ <em class="calibre7">N</em>/2−1. The <img src="images/001213.jpg" alt="image" class="calibre2" /> operation means the integer part of <em class="calibre7">q</em>. The [<em class="calibre7">z</em>]<sub class="calibre12">bit-rev</sub> function represents the three-step operation of: convert decimal integer <em class="calibre7">z</em> to a binary number represented by log<sub class="calibre12">2</sub>(<em class="calibre7">N</em>)−1 binary bits, perform bit reversal on the binary number as discussed in <a href="#calibre_link-603">Section 4.5</a>, and convert the bit-reversed number back to a decimal integer.</p>
<p class="calibre3">As an example of using <a href="#calibre_link-1388">Eq. (13-76′)</a>, for the second stage (<em class="calibre7">P</em> = 2) of an <em class="calibre7">N</em> = 8-point DIT FFT, the <em class="calibre7">k</em> = 3 twiddle factor angle is</p>
<p class="image"><img src="images/000366.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2192"></a>The above [1]<sub class="calibre12">bit-rev</sub> operation is: Take the decimal number 1 and represent it with log<sub class="calibre12">2</sub>(<em class="calibre7">N</em>)−1 = 2 bits, i.e., as 01<sub class="calibre12">2</sub>. Next, reverse those bits to a binary 10<sub class="calibre12">2</sub> and convert that binary number to our desired decimal result of 2.</p>
<p class="calibre3"><a id="calibre_link-688"></a></p>
<h3 class="calibre6">13.17 Single Tone Detection</h3>
<p class="calibre3">In this section we present an IIR filter structure used to perform spectrum analysis in the detection and measurement of single sinusoidal tones. The standard method for spectral energy is the discrete Fourier transform (DFT), typically implemented using a fast Fourier transform (FFT) algorithm. However, there are applications that require spectrum analysis only over a subset of the <em class="calibre7">N</em> bin-center frequencies of an <em class="calibre7">N</em>-point DFT. A popular, as well as efficient, technique for computing sparse FFT results is the Goertzel algorithm, using an IIR filter implementation to compute a single complex DFT spectral bin value based upon <em class="calibre7">N</em> input time samples. The most common application of this process is to detect the presence of a single continuous-wave sinusoidal tone. With that in mind, let’s look briefly at tone detection.</p>
<p class="calibre3">It’s certainly possible to use the FFT to detect the presence of a single sinusoidal tone in a time-domain sequence <em class="calibre7">x</em>(<em class="calibre7">n</em>). For example, if we wanted to detect a 30 kHz tone in a time-domain sequence whose sample rate was <em class="calibre7">f<sub class="calibre12">s</sub></em> = 128 kHz, we could start by performing a 64-point FFT as shown in <a href="#calibre_link-1389">Figure 13-41</a>. Then we would examine the magnitude of the <em class="calibre7">X</em>(15) complex sample to see if it exceeds some predefined threshold.</p>
<p class="caption"><a id="calibre_link-1389"></a><strong class="calibre9">Figure 13-41</strong> DFT method, using an FFT algorithm, to detect a 30 kHz tone.</p>
<p class="image"><img src="images/001124.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">This FFT method is very inefficient. In our example, we’d be performing 192, (64/2)(log<sub class="calibre12">2</sub>64), complex multiplies to obtain the 64-point complex <em class="calibre7">X</em>(<em class="calibre7">m</em>) in order to compute the one <em class="calibre7">X</em>(15) in which we’re interested. We discarded 98 percent of our computation results! We could be more efficient and calculate our desired <em class="calibre7">X</em>(15) using the single-point discrete Fourier transform (DFT) in <a href="#calibre_link-1390">Eq. (13-77)</a>, which requires <em class="calibre7">N</em> = 64 complex multiplies using</p>
<p class="caption"><a id="calibre_link-1390"></a>(13-77)</p>
<p class="image"><img src="images/000514.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2301"></a>That would be an improvement but, happily, there’s a better way. It’s called the <em class="calibre7">Goertzel algorithm</em> (pronounced ‘girt-zel).</p>
<p class="calibre3"><a id="calibre_link-1042"></a></p>
<h4 class="calibre13">13.17.1 Goertzel Algorithm</h4>
<p class="calibre3">The Goertzel algorithm is implemented in the form of a 2nd-order IIR filter, with two real feedback coefficients and a single complex feedforward coefficient, as shown in <a href="#calibre_link-1043">Figure 13-42</a>. (Although we don’t use this process as a traditional filter, common terminology refers to the structure as a <em class="calibre7">filter</em>.) This filter computes a single-bin DFT output (the <em class="calibre7">m</em>th bin of an <em class="calibre7">N</em>-point DFT) defined by</p>
<p class="caption"><a id="calibre_link-3285"></a>(13-78)</p>
<p class="image"><img src="images/000768.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-1043"></a><strong class="calibre9">Figure 13-42</strong> IIR filter implementation of the Goertzel algorithm.</p>
<p class="image"><img src="images/000171.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The filter’s <em class="calibre7">y</em>(<em class="calibre7">n</em>) output is equal to the DFT output frequency coefficient, <em class="calibre7">X</em>(<em class="calibre7">m</em>), at the time index <em class="calibre7">n</em> = <em class="calibre7">N</em>, where the first time index value is <em class="calibre7">n</em> = 0. For emphasis, we remind the reader that the filter’s <em class="calibre7">y</em>(<em class="calibre7">n</em>) output is not equal to <em class="calibre7">X</em>(<em class="calibre7">m</em>) at any time index when <em class="calibre7">n</em> ≠ <em class="calibre7">N</em>. To be equivalent to the DFT, the frequency-domain index <em class="calibre7">m</em> must an integer in the range 0 ≤ <em class="calibre7">m</em> ≤ <em class="calibre7">N</em>−1. You’re welcome to think of the Goertzel algorithm as a <em class="calibre7">single-bin DFT</em>. The derivation of this filter (this algorithm) structure is readily available in the literature[<a href="#calibre_link-1391">45</a>&ndash;<a href="#calibre_link-1392">47</a>].</p>
<p class="calibre3">The <em class="calibre7">z</em>-domain transfer function of the Goertzel filter is</p>
<p class="caption"><a id="calibre_link-1396"></a>(13-79)</p>
<p class="image"><img src="images/001105.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">with a single <em class="calibre7">z</em>-domain zero located at <em class="calibre7">z</em> = <em class="calibre7">e</em><sup class="calibre10">−<em class="calibre7">j</em>2π<em class="calibre7">m/N</em></sup> and conjugate poles at <em class="calibre7">z</em> = <em class="calibre7">e</em><sup class="calibre10">±<em class="calibre7">j</em>2π<em class="calibre7">m/N</em></sup> as shown in <a href="#calibre_link-1393">Figure 13-43(a)</a>. The pole/zero pair at <em class="calibre7">z</em> = <em class="calibre7">e</em><sup class="calibre10">−<em class="calibre7">j</em>2π<em class="calibre7">m/N</em></sup> cancel each other. Having a filter pole on the unit circle is typically a risky thing to do for stability reasons, but not so with the Goertzel algorithm. Because it processes <em class="calibre7">N</em>+1-length blocks of time samples (where <em class="calibre7">N</em> is usually in the hundreds), <a id="calibre_link-2300"></a>the filter remains stable for such short time sequences because its internal data storage registers, <em class="calibre7">w</em>(<em class="calibre7">n</em>−1) and <em class="calibre7">w</em>(<em class="calibre7">n</em>−2), are reset to zero at the beginning of each new block of input data. The filter’s frequency magnitude response, provided in <a href="#calibre_link-1393">Figure 13-43(b)</a>, shows resonance centered at a normalized frequency of 2π<em class="calibre7">m</em>/<em class="calibre7">N</em>, corresponding to a cyclic frequency of <em class="calibre7">mf<sub class="calibre12">s</sub></em>/<em class="calibre7">N</em> Hz (where <em class="calibre7">f<sub class="calibre12">s</sub></em> is the signal sample rate).</p>
<p class="caption"><a id="calibre_link-1393"></a><strong class="calibre9">Figure 13-43</strong> Goertzel filter: (a) <em class="calibre7">z</em>-domain pole/zero locations; (b) frequency magnitude response.</p>
<p class="image"><img src="images/001013.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The Goertzel algorithm is implemented with a complex resonator having an infinite-length unit impulse response, <em class="calibre7">h</em>(<em class="calibre7">n</em>) = <em class="calibre7">e<sup class="calibre10">j</sup></em><sup class="calibre10">2π<em class="calibre7">nm</em>/<em class="calibre7">N</em></sup>, and that’s why its frequency magnitude response is so narrow. The time-domain difference equations for the Goertzel filter are</p>
<p class="caption"><a id="calibre_link-1394"></a>(13-80)</p>
<p class="image"><img src="images/001747.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-1395"></a>(13-81)</p>
<p class="image"><img src="images/000182.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">An advantage of the Goertzel filter in computing an <em class="calibre7">N</em>-point <em class="calibre7">X</em>(<em class="calibre7">m</em>) DFT bin value is that <a href="#calibre_link-1394">Eq. (13-80)</a> is implemented <em class="calibre7">N</em> times while <a href="#calibre_link-1395">Eq. (13-81)</a>, the feedforward path in <a href="#calibre_link-1043">Figure 13-42</a>, need only be computed once after the arrival of the <em class="calibre7">N</em>th input sample. Thus for real <em class="calibre7">x</em>(<em class="calibre7">n</em>) inputs the filter requires <em class="calibre7">N</em>+2 real multiplies and 2<em class="calibre7">N</em>+1 real adds to compute an <em class="calibre7">N</em>-point <em class="calibre7">X</em>(<em class="calibre7">m</em>). However, when modeling the Goertzel filter, if the time index begins at <em class="calibre7">n</em> = 0, the filter must process <em class="calibre7">N</em>+1 time samples with <em class="calibre7">x</em>(<em class="calibre7">N</em>) = 0 to compute <em class="calibre7">X</em>(<em class="calibre7">m</em>).</p>
<p class="calibre3">In typical applications, to minimize spectral leakage, we choose <em class="calibre7">N</em> so there’s an integer number of cycles in our input sequence of the tone we’re trying to detect. <em class="calibre7">N</em> can be any integer, and the larger <em class="calibre7">N</em> is, the better the frequency resolution and noise immunity. However, larger <em class="calibre7">N</em> means more computations.</p>
<p class="calibre3">It’s worth noting that while the typical Goertzel algorithm description in the literature specifies the frequency resonance variable <em class="calibre7">m</em> to be an integer (making the Goertzel filter’s output equivalent to an <em class="calibre7">N</em>-point DFT bin <a id="calibre_link-2193"></a>output), the <em class="calibre7">m</em> in <a href="#calibre_link-1043">Figure 13-42</a> and <a href="#calibre_link-1396">Eq. (13-79)</a> can in fact be any value between 0 and <em class="calibre7">N</em>−1, giving us full flexibility in specifying our filter’s resonant frequency.</p>
<p class="calibre3"><a id="calibre_link-3286"></a></p>
<h4 class="calibre13">13.17.2 Goertzel Example</h4>
<p class="calibre3">Let’s use Goertzel to calculate the spectral magnitude of that <em class="calibre7">f</em><sub class="calibre12">tone</sub> = 30 kHz tone from the <a href="#calibre_link-1389">Figure 13-41</a> example. When <em class="calibre7">f<sub class="calibre12">s</sub></em> = 128 kHz and <em class="calibre7">N</em> = 64, our resonant frequency integer <em class="calibre7">m</em> is</p>
<p class="caption"><a id="calibre_link-3287"></a>(13-82)</p>
<p class="image"><img src="images/000412.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The Goertzel filter and the necessary computations for our 30 kHz detection example are provided in <a href="#calibre_link-1397">Figure 13-44</a>.</p>
<p class="caption"><a id="calibre_link-1397"></a><strong class="calibre9">Figure 13-44</strong> Filter, coefficients, and computations to detect the 30 kHz tone.</p>
<p class="image"><img src="images/000062.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">It’s useful to know that if we want to compute the power of <em class="calibre7">X</em>(15), |<em class="calibre7">X</em>(15)<sup class="calibre10">2</sup>|, the final feedforward complex calculations can be avoided by computing</p>
<p class="caption"><a id="calibre_link-1398"></a>(13-83)</p>
<p class="image"><img src="images/001263.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">In our example, <a href="#calibre_link-1398">Eq. (13-83)</a> becomes</p>
<p class="caption"><a id="calibre_link-3288"></a>(13-84)</p>
<p class="image"><img src="images/000302.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3289"></a></p>
<h4 class="calibre13">13.17.3 Goertzel Advantages over the FFT</h4>
<p class="calibre3">Here are some implementation advantages of the Goertzel algorithm over the standard radix-2 FFT for single tone detection:</p>
<p class="indenthangingb"><a id="calibre_link-2419"></a>• <em class="calibre7">N</em> does not need to be an integer power of two.</p>
<p class="indenthangingb">• The resonant frequency can be any value between zero and <em class="calibre7">f<sub class="calibre12">s</sub></em> Hz.</p>
<p class="indenthangingb">• The amount of filter coefficient (versus FFT twiddle factor) storage is reduced. If <a href="#calibre_link-1398">Eq. (13-83)</a> is used, only one coefficient need be stored.</p>
<p class="indenthangingb">• No <em class="calibre7">storing a block of input data</em> is needed before processing can begin (as with the FFT). Processing can begin with the first input time sample.</p>
<p class="indenthangingb">• No data <em class="calibre7">bit reversal</em> is needed for Goertzel.</p>
<p class="indenthangingb">• If you implement the Goertzel algorithm <em class="calibre7">M</em> times to detect <em class="calibre7">M</em> different tones, Goertzel is more efficient (fewer multiplies) than the FFT when <em class="calibre7">M</em> &lt; log<sub class="calibre12">2</sub><em class="calibre7">N</em>.</p>
<p class="indenthangingb">• Computational requirements to detect a single tone (assuming real-only <em class="calibre7">x</em>(<em class="calibre7">n</em>) input) are given in <a href="#calibre_link-1399">Table 13-4</a>.</p>
<p class="caption"><a id="calibre_link-1399"></a><strong class="calibre9">Table 13-4 Single-Bin DFT Computational Comparisons</strong></p>
<p class="image"><img src="images/001568.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">As a final note, although the Goertzel algorithm is implemented with a complex resonating filter structure, it’s not used as a typical filter where we retain each output sample. For the Goertzel algorithm we retain only every <em class="calibre7">N</em>th, or (<em class="calibre7">N</em>+1)th, output sample. As such, the frequency magnitude response of the Goertzel algorithm when treated as a black-box process is equivalent to the |sin(<em class="calibre7">x</em>)/<em class="calibre7">x</em>|-like magnitude response of a single bin of an <em class="calibre7">N</em>-point DFT, a portion of which is shown in <a href="#calibre_link-1400">Figure 13-45</a>.</p>
<p class="caption"><a id="calibre_link-1400"></a><strong class="calibre9">Figure 13-45</strong> Goertzel algorithm frequency magnitude response.</p>
<p class="image"><img src="images/001154.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-689"></a></p>
<h3 class="calibre6">13.18 The Sliding DFT</h3>
<p class="calibre3">The above Goertzel algorithm computes a single complex DFT spectral bin value for every <em class="calibre7">N</em> input time samples. Here we describe a <em class="calibre7">sliding DFT</em> process whose spectral bin output rate is equal to the input data rate, on a sample-by-sample basis, with the advantage that it requires fewer computations than the Goertzel algorithm for real-time spectral analysis. In applications where a new DFT output spectrum is desired every sample, or every few samples, the sliding DFT is computationally simpler than the traditional radix-2 FFT.</p>
<p class="calibre3"><a id="calibre_link-3290"></a></p>
<h4 class="calibre13"><a id="calibre_link-2418"></a>13.18.1 The Sliding DFT Algorithm</h4>
<p class="calibre3">The sliding DFT (SDFT) algorithm computes a single bin result of an <em class="calibre7">N</em>-point DFT on time samples within a sliding window. That is, for the <em class="calibre7">m</em>th bin of an <em class="calibre7">N</em>-point DFT, the SDFT computes</p>
<p class="caption"><a id="calibre_link-1401"></a>(13-85)</p>
<p class="image"><img src="images/001140.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Let’s take care to understand the notation of <em class="calibre7">X<sup class="calibre10">m</sup></em>(<em class="calibre7">q</em>). Typically, as in <a href="#calibre_link-134">Chapter 3</a>, the index of a DFT result value was the frequency-domain index <em class="calibre7">m</em>. In <a href="#calibre_link-1401">Eq. (13-85)</a> the index of the DFT result is a time-domain index <em class="calibre7">q</em> = 0, 1, 2, 3, ..., such that our first <em class="calibre7">m</em>th-bin SDFT is <em class="calibre7">X<sup class="calibre10">m</sup></em>(0), our second SDFT is <em class="calibre7">X<sup class="calibre10">m</sup></em>(1), and so on.</p>
<p class="calibre3">An example SDFT analysis time window is shown in <a href="#calibre_link-1402">Figure 13-46(a)</a> where <em class="calibre7">X<sup class="calibre10">m</sup></em>(0) is computed for the <em class="calibre7">N</em> = 16 time samples <em class="calibre7">x</em>(0) to <em class="calibre7">x</em>(15). The time window is then advanced one sample, as in <a href="#calibre_link-1402">Figure 13-46(b)</a>, and the new <em class="calibre7">X<sup class="calibre10">m</sup></em>(1) is calculated. The value of this process is that each new DFT result is efficiently computed directly from the result of the previous DFT. The incremental advance of the time window for each output computation leads to the name <em class="calibre7">sliding DFT</em> or <em class="calibre7">sliding-window DFT</em>.</p>
<p class="caption"><a id="calibre_link-1402"></a><strong class="calibre9">Figure 13-46</strong> Analysis window for two 16-point DFTs: (a) data samples in the first computation; (b) second computation samples.</p>
<p class="image"><img src="images/001766.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">We can develop the mathematical expression for the SDFT as follows: the standard <em class="calibre7">N</em>-point DFT equation, of the <em class="calibre7">m</em>th DFT bin, for the <em class="calibre7">q</em>th DFT of the time sequence <em class="calibre7">x</em>(<em class="calibre7">q</em>), <em class="calibre7">x</em>(<em class="calibre7">q</em>+1), ..., <em class="calibre7">x</em>(<em class="calibre7">q</em>+<em class="calibre7">N</em>−1) is</p>
<p class="caption"><a id="calibre_link-1405"></a>(13-86)</p>
<p class="image"><img src="images/000190.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">(Variable <em class="calibre7">m</em> is the frequency-domain index, where <em class="calibre7">m</em> = 0, 1, 2, ..., <em class="calibre7">N</em>−1.) Likewise, the expression for the next DFT, the (<em class="calibre7">q</em>+1)th DFT performed on time samples <em class="calibre7">x</em>(<em class="calibre7">q</em>+1), <em class="calibre7">x</em>(<em class="calibre7">q</em>+2), ..., <em class="calibre7">x</em>(<em class="calibre7">q</em>+<em class="calibre7">N</em>), is</p>
<p class="caption"><a id="calibre_link-3291"></a><a id="calibre_link-1403"></a>(13-87)</p>
<p class="image"><img src="images/001086.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Letting <em class="calibre7">p</em> = <em class="calibre7">n</em>+1 in <a href="#calibre_link-1403">Eq. (13-87)</a>, we can write</p>
<p class="caption"><a id="calibre_link-1404"></a>(13-88)</p>
<p class="image"><img src="images/000082.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Shifting the limits of summation in <a href="#calibre_link-1404">Eq. (13-88)</a>, and including the appropriate terms (subtract the <em class="calibre7">p</em> = 0 term and add the <em class="calibre7">p</em> = <em class="calibre7">N</em> term) to compensate for the shifted limits, we write</p>
<p class="caption"><a id="calibre_link-3292"></a>(13-89)</p>
<p class="image"><img src="images/000926.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Factoring the common exponential term (<em class="calibre7">e<sup class="calibre10">j</sup></em><sup class="calibre10">2π<em class="calibre7">m</em>/<em class="calibre7">N</em></sup>), we write</p>
<p class="caption"><a id="calibre_link-3293"></a>(13-90)</p>
<p class="image"><img src="images/000814.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Recognizing the summation in the brackets being equal to the previous <em class="calibre7">X<sup class="calibre10">m</sup></em>(<em class="calibre7">q</em>) in <a href="#calibre_link-1405">Eq. (13-86)</a>, and <em class="calibre7">e</em><sup class="calibre10">−<em class="calibre7">j</em>2π<em class="calibre7">m</em></sup> = 1, we write the desired recursive expression for the sliding <em class="calibre7">N</em>-point DFT as</p>
<p class="caption"><a id="calibre_link-1406"></a>(13-91)</p>
<p class="image"><img src="images/001669.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3294"></a>where <em class="calibre7">X<sup class="calibre10">m</sup></em>(<em class="calibre7">q</em>+1) is the new single-bin DFT result and <em class="calibre7">X<sup class="calibre10">m</sup></em>(<em class="calibre7">q</em>) is the previous single-bin DFT value. The superscript <em class="calibre7">m</em> reminds us that the <em class="calibre7">X<sup class="calibre10">m</sup></em>(<em class="calibre7">q</em>) spectral samples are those associated with the <em class="calibre7">m</em>th DFT bin.</p>
<p class="calibre3">Let’s plug some numbers into <a href="#calibre_link-1406">Eq. (13-91)</a> to reveal the nature of its time indexing. If <em class="calibre7">N</em> = 20, then 20 time samples (<em class="calibre7">x</em>(0) to <em class="calibre7">x</em>(19)) are needed to compute the first result <em class="calibre7">X<sup class="calibre10">m</sup></em>(0). The computation of <em class="calibre7">X<sup class="calibre10">m</sup></em>(1) is then</p>
<p class="caption"><a id="calibre_link-1407"></a>(13-92)</p>
<p class="image"><img src="images/000694.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Due to our derivation method’s time indexing, <a href="#calibre_link-1407">Eq. (13-92)</a> <em class="calibre7">appears</em> compelled to look into the future for <em class="calibre7">x</em>(20) to compute <em class="calibre7">X<sup class="calibre10">m</sup></em>(1). With no loss in generality, we can modify <a href="#calibre_link-1406">Eq. (13-91)</a>’s time indexing so that the <em class="calibre7">x</em>(<em class="calibre7">n</em>) input samples and the <em class="calibre7">X<sup class="calibre10">m</sup></em>(<em class="calibre7">q</em>) output samples use the same time index <em class="calibre7">n</em>. That modification yields our SDFT time-domain difference equation of</p>
<p class="caption"><a id="calibre_link-1408"></a>(13-93)</p>
<p class="image"><img src="images/001555.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a href="#calibre_link-1408">Equation (13-93)</a> reveals the value of this process in computing real-time spectra. We compute <em class="calibre7">X<sup class="calibre10">m</sup></em>(<em class="calibre7">n</em>) by subtracting the <em class="calibre7">x</em>(<em class="calibre7">n</em>−<em class="calibre7">N</em>) sample and adding the current <em class="calibre7">x</em>(<em class="calibre7">n</em>) sample to the previous <em class="calibre7">X<sup class="calibre10">m</sup></em>(<em class="calibre7">n</em>−1), and phase shifting the result. Thus the SDFT requires only two real additions and one complex multiply per output sample. Not bad at all! <a href="#calibre_link-1408">Equation (13-93)</a> leads to the single-bin SDFT filter implementation shown in <a href="#calibre_link-1409">Figure 13-47</a>.</p>
<p class="caption"><a id="calibre_link-1409"></a><strong class="calibre9">Figure 13-47</strong> Single-bin sliding DFT filter structure.</p>
<p class="image"><img src="images/000791.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The single-bin SDFT algorithm is implemented as an IIR filter with a comb filter followed by a complex resonator. (If you need to compute all <em class="calibre7">N</em> DFT spectral components, <em class="calibre7">N</em> resonators with <em class="calibre7">m</em> = 0 to <em class="calibre7">N</em>−1 will be needed, all driven by a single comb filter.) The comb filter delay of <em class="calibre7">N</em> samples forces the SDFT filter’s transient response to be <em class="calibre7">N</em> samples in length, so the output will not reach steady state until the <em class="calibre7">X<sup class="calibre10">m</sup></em>(<em class="calibre7">N−1</em>) sample. The output will not be valid, or equivalent to <a href="#calibre_link-1405">Eq. (13-86)</a>’s <em class="calibre7">X<sup class="calibre10">m</sup></em>(<em class="calibre7">q</em>), until <em class="calibre7">N</em> input samples have been processed. The <em class="calibre7">z</em>-transform of <a href="#calibre_link-1408">Eq. (13-93)</a> is</p>
<p class="caption"><a id="calibre_link-3295"></a>(13-94)</p>
<p class="image"><img src="images/000579.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3296"></a>where factors of <em class="calibre7">X<sup class="calibre10">m</sup></em>(<em class="calibre7">z</em>) and <em class="calibre7">X</em>(<em class="calibre7">z</em>) are collected, yielding the <em class="calibre7">z</em>-domain transfer function for the <em class="calibre7">m</em>th bin of the SDFT filter as</p>
<p class="caption"><a id="calibre_link-3297"></a>(13-95)</p>
<p class="image"><img src="images/001439.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">This complex filter has <em class="calibre7">N</em> zeros equally spaced around the <em class="calibre7">z</em>-domain’s unit circle, due to the <em class="calibre7">N</em>-delay comb filter, as well as a single pole canceling the zero at <em class="calibre7">z</em> = <em class="calibre7">e<sup class="calibre10">j</sup></em><sup class="calibre10">2π<em class="calibre7">m</em>/<em class="calibre7">N</em></sup>. The SDFT filter’s complex unit impulse response <em class="calibre7">h</em>(<em class="calibre7">n</em>) and pole/zero locations are shown in <a href="#calibre_link-1410">Figure 13-48</a> for the example where <em class="calibre7">m</em> = 2 and <em class="calibre7">N</em> = 20.</p>
<p class="caption"><a id="calibre_link-1410"></a><strong class="calibre9">Figure 13-48</strong> Sliding DFT characteristics for <em class="calibre7">m</em> = 2 and <em class="calibre7">N</em> = 20: (a) complex impulse response; (b) pole/zero locations.</p>
<p class="image"><img src="images/001646.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Because of the comb subfilter, the SDFT filter’s complex sinusoidal unit impulse response is finite in length&mdash;truncated in time to <em class="calibre7">N</em> samples&mdash;and that property makes the frequency magnitude response of the SDFT filter identical to the sin(<em class="calibre7">Nx</em>)/sin(<em class="calibre7">x</em>) response of a single DFT bin centered at a frequency of 2π<em class="calibre7">m</em>/<em class="calibre7">N</em>.</p>
<p class="calibre3">One of the attributes of the SDFT is that once an <em class="calibre7">X<sup class="calibre10">m</sup></em>(<em class="calibre7">n</em>) is obtained, the number of computations to compute <em class="calibre7">X<sup class="calibre10">m</sup></em>(<em class="calibre7">n</em>+1) is fixed and independent of <em class="calibre7">N</em>. A computational workload comparison between the Goertzel and SDFT filters is provided later in this section. Unlike the radix-2 FFT, the SDFT’s <em class="calibre7">N</em> can be any positive integer, giving us greater flexibility to <em class="calibre7">tune</em> the SDFT’s center frequency by defining integer <em class="calibre7">m</em> such that <em class="calibre7">m</em> = <em class="calibre7">Nf</em><sub class="calibre12">i</sub>/<em class="calibre7">f<sub class="calibre12">s</sub></em>, when <em class="calibre7">f</em><sub class="calibre12">i</sub> is a frequency of interest in Hz and <em class="calibre7">f<sub class="calibre12">s</sub></em> is the signal sample rate in Hz. In addition, the SDFT requires no bit-reversal processing as does the FFT. Like the Goertzel algorithm, the SDFT is especially efficient for narrowband spectrum analysis.</p>
<p class="calibre3">For completeness, we mention that a radix-2 <em class="calibre7">sliding FFT</em> technique exists for computing all <em class="calibre7">N</em> bins of <em class="calibre7">X<sup class="calibre10">m</sup></em>(<em class="calibre7">q</em>) in <a href="#calibre_link-1401">Eq. (13-85)</a>[<a href="#calibre_link-1411">48</a>,<a href="#calibre_link-1412">49</a>]. That technique is <a id="calibre_link-2420"></a>computationally attractive because it requires only <em class="calibre7">N</em> complex multiplies to update the <em class="calibre7">N</em>-point FFT for all <em class="calibre7">N</em> bins; however, it requires 3<em class="calibre7">N</em> memory locations (2<em class="calibre7">N</em> for data and <em class="calibre7">N</em> for twiddle coefficients). Unlike the SDFT, the radix-2 sliding FFT scheme requires address bit-reversal processing and restricts <em class="calibre7">N</em> to be an integer power of two.</p>
<p class="calibre3"><a id="calibre_link-3298"></a></p>
<h4 class="calibre13">13.18.2 SDFT Stability</h4>
<p class="calibre3">The SDFT filter is only marginally stable because its pole resides on the <em class="calibre7">z</em>-domain’s unit circle. If filter coefficient numerical rounding error is not severe, the SDFT is bounded-input-bounded-output stable. Filter instability can be a problem, however, if numerical coefficient rounding causes the filter’s pole to move outside the unit circle. We can use a damping factor <em class="calibre7">r</em> to force the pole and zeros in <a href="#calibre_link-1410">Figure 13-48(b)</a> to be at a radius of <em class="calibre7">r</em> just slightly inside the unit circle and guarantee stability using a transfer function of</p>
<p class="caption"><a id="calibre_link-3299"></a>(13-96)</p>
<p class="image"><img src="images/000475.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">with the subscript “gs” meaning guaranteed-stable. (<a href="#calibre_link-1413">Section 7.5.3</a> provides the mathematical details of moving a filter’s poles and zeros inside the unit circle.) The stabilized feedforward and feedback coefficients become −<em class="calibre7">r<sup class="calibre10">N</sup></em> and <em class="calibre7">re<sup class="calibre10">j</sup></em><sup class="calibre10">2π<em class="calibre7">m</em>/<em class="calibre7">N</em></sup>, respectively. The difference equation for the stable SDFT filter becomes</p>
<p class="caption"><a id="calibre_link-3300"></a>(13-97)</p>
<p class="image"><img src="images/001336.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">with the stabilized-filter structure shown in <a href="#calibre_link-1414">Figure 13-49</a>. In this case, we perform five real multiplies and four real additions per output sample.</p>
<p class="caption"><a id="calibre_link-1414"></a><strong class="calibre9">Figure 13-49</strong> Guaranteed-stable sliding DFT filter structure.</p>
<p class="image"><img src="images/000673.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Using a damping factor as in <a href="#calibre_link-1414">Figure 13-49</a> guarantees stability, but the <em class="calibre7">X<sup class="calibre10">m</sup></em>(<em class="calibre7">q</em>) output, defined by</p>
<p class="caption"><a id="calibre_link-3301"></a>(13-98)</p>
<p class="image"><img src="images/000372.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">is no longer exactly equal to the <em class="calibre7">m</em>th bin of an <em class="calibre7">N</em>-point DFT in <a href="#calibre_link-1401">Eq. (13-85)</a>. While the error is reduced by making <em class="calibre7">r</em> very close to (but less than) unity, a <a id="calibre_link-3302"></a>scheme does exist for eliminating that error completely once every <em class="calibre7">N</em> output samples at the expense of additional conditional logic operations<a href="#calibre_link-1415">[50]</a>. Determining if the damping factor <em class="calibre7">r</em> is necessary for a particular SDFT application requires careful empirical investigation. As is so often the case in the world of DSP, this means you have to test your SDFT implementation very thoroughly and carefully!</p>
<p class="calibre3">Another stabilization method worth consideration is decrementing the largest component (either real or imaginary) of the filter’s <em class="calibre7">e<sup class="calibre10">j</sup></em><sup class="calibre10">2π<em class="calibre7">m</em>/<em class="calibre7">N</em></sup> feedback coefficient by one least significant bit. This technique can be applied selectively to problematic output bins and is effective in combating instability due to rounding errors that result in finite-precision <em class="calibre7">e<sup class="calibre10">j</sup></em><sup class="calibre10">2π<em class="calibre7">m</em>/<em class="calibre7">N</em></sup> coefficients having magnitudes greater than unity. Like the DFT, the SDFT’s output is proportional to <em class="calibre7">N</em>, so in fixed-point binary implementations the designer must allocate sufficiently wide registers to hold the computed results.</p>
<p class="calibre3"><a id="calibre_link-3303"></a></p>
<h4 class="calibre13">13.18.3 SDFT Leakage Reduction</h4>
<p class="calibre3">Being equivalent to the DFT, the SDFT also suffers from spectral leakage effects. As with the DFT, SDFT leakage can be reduced by the standard concept of windowing the <em class="calibre7">x</em>(<em class="calibre7">n</em>) input time samples as discussed in <a href="#calibre_link-594">Section 3.9</a>. However, windowing by time-domain multiplication would ruin the real-time computational simplicity of the SDFT. Thanks to the convolution theorem properties of discrete systems, we can implement time-domain windowing by means of frequency-domain convolution, as discussed in <a href="#calibre_link-464">Section 13.3</a>.</p>
<p class="calibre3">Spectral leakage reduction performed in the frequency domain is accomplished by convolving adjacent <em class="calibre7">X<sup class="calibre10">m</sup></em>(<em class="calibre7">q</em>) values with the DFT of a window function. For example, the DFT of a Hamming window comprises only three nonzero values, −0.23, 0.54, and −0.23. As such, we can compute a Hamming-windowed <em class="calibre7">X<sup class="calibre10">m</sup></em>(<em class="calibre7">q</em>) with a three-point convolution using</p>
<p class="caption"><a id="calibre_link-1418"></a>(13-99)</p>
<p class="image"><img src="images/001218.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a href="#calibre_link-1416">Figure 13-50</a> shows this process using three resonators, each tuned to adjacent DFT bins (<em class="calibre7">m</em>−1, <em class="calibre7">m</em>, and <em class="calibre7">m</em>+1). The comb filter stage need only be implemented once.</p>
<p class="caption"><a id="calibre_link-1416"></a><strong class="calibre9">Figure 13-50</strong> Three-resonator structure to compute a single Hamming-windowed <em class="calibre7">X<sup class="calibre10">m</sup></em>(<em class="calibre7">q</em>).</p>
<p class="image"><img src="images/001532.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a href="#calibre_link-1417">Table 13-5</a> provides a computational workload comparison of various spectrum analysis schemes in computing an initial <em class="calibre7">X<sup class="calibre10">m</sup></em>(<em class="calibre7">n</em>) value and computing a subsequent <em class="calibre7">X<sup class="calibre10">m</sup></em>(<em class="calibre7">n</em>+1) value.</p>
<p class="caption"><a id="calibre_link-1417"></a><strong class="calibre9">Table 13-5</strong> Single-Bin DFT Computation Comparison</p>
<p class="image"><img src="images/000593.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">To compute the initial windowed <em class="calibre7">X<sup class="calibre10">m</sup></em>(<em class="calibre7">n</em>) values in <a href="#calibre_link-1417">Table 13-5</a>, the three-term frequency-domain convolution need only be performed once, upon arrival of the <em class="calibre7">N</em>th time sample. However, the convolution needs to be performed for all subsequent computations</p>
<p class="calibre3">We remind the reader that <a href="#calibre_link-464">Section 13.3</a> discusses several implementation issues regarding Hanning windowing in the frequency domain, using binary <a id="calibre_link-2445"></a>shifts to eliminate the multiplications in <a href="#calibre_link-1418">Eq. (13-99)</a>, as well as the use of other window functions.</p>
<p class="calibre3"><a id="calibre_link-3304"></a></p>
<h4 class="calibre13">13.18.4 A Little-Known SDFT Property</h4>
<p class="calibre3">The SDFT has a special property that’s not widely known but is very important. If we change the SDFT’s comb filter feedforward coefficient (in <a href="#calibre_link-1409">Figure 13-47</a>) from −1 to +1, the comb’s zeros will be rotated counterclockwise around the unit circle by an angle of π/<em class="calibre7">N</em> radians. This situation, for <em class="calibre7">N</em> = 8, is shown on the right side of <a href="#calibre_link-1419">Figure 13-51(a)</a>. The zeros are located at angles of 2π(<em class="calibre7">m</em> + 1/2)/<em class="calibre7">N</em> radians. The <em class="calibre7">m</em> = 0 zeros are shown as solid dots. <a href="#calibre_link-1419">Figure 13-51(b)</a> shows the zeros locations for an <em class="calibre7">N</em> = 9 SDFT <a id="calibre_link-2194"></a>under the two conditions of the comb filter’s feedforward coefficient being −1 and +1.</p>
<p class="caption"><a id="calibre_link-1419"></a><strong class="calibre9">Figure 13-51</strong> Four possible orientations of comb filter zeros on the unit circle.</p>
<p class="image"><img src="images/000560.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">This alternate situation is useful: we can now expand our set of spectrum analysis center frequencies to more than just <em class="calibre7">N</em> angular frequency points around the unit circle. The analysis frequencies can be either 2π<em class="calibre7">m</em>/<em class="calibre7">N</em> or 2π(<em class="calibre7">m</em>+1/2)/<em class="calibre7">N</em>, where integer <em class="calibre7">m</em> is in the range 0 ≤ <em class="calibre7">m</em> ≤ <em class="calibre7">N</em>−1. Thus we can build an SDFT analyzer that resonates at any one of 2<em class="calibre7">N</em> frequencies between 0 and <em class="calibre7">f<sub class="calibre12">s</sub></em> Hz. Of course, if the comb filter’s feedforward coefficient is set to +1, the resonator’s feedforward coefficient must be <em class="calibre7">e<sup class="calibre10">j</sup></em><sup class="calibre10">2π(<em class="calibre7">m</em>+1/2)/<em class="calibre7">N</em></sup> to achieve pole/zero cancellation.</p>
<p class="calibre3"><a id="calibre_link-690"></a></p>
<h3 class="calibre6">13.19 The Zoom FFT</h3>
<p class="calibre3">The Zoom FFT is a spectrum analysis method that blends complex down-conversion, lowpass filtering, and sample rate change by way of decimation. The Zoom FFT scheme (also called the <em class="calibre7">zoom transform</em> or <em class="calibre7">spectral vernier</em>) is used when fine-grained spectral resolution is needed within a small portion of a signal’s overall frequency bandwidth range. In some spectrum analysis situations, this technique can be more efficient than the traditional FFT. The Zoom FFT can also be useful if we’re constrained, for some reason, to use <a id="calibre_link-3305"></a>software that performs <em class="calibre7">N</em>-point FFTs for spectrum analysis of signal sequences whose lengths are greater than <em class="calibre7">N</em>.</p>
<p class="calibre3">Think of the spectral analysis situation where we require <em class="calibre7">fine</em> frequency resolution, closely spaced FFT bins, over the frequency range occupied by the signal of interest shown in <a href="#calibre_link-1420">Figure 13-52(a)</a>. (The other signals are of no interest to us.) We could collect many time samples and perform a large-size radix-2 FFT to satisfy our fine spectral resolution requirement. This solution is inefficient because we’d be discarding most of our FFT results. The Zoom FFT can help us improve our computational efficiency through</p>
<p class="caption"><a id="calibre_link-1420"></a><strong class="calibre9">Figure 13-52</strong> Zoom FFT spectra: (a) input spectrum; (b) processing scheme; (c) down-converted spectrum; (d) filtered and decimated spectrum.</p>
<p class="image"><img src="images/001419.jpg" alt="image" class="calibre2" /></p>
<p class="indenthangingb">• frequency translation by means of complex down-conversion,</p>
<p class="indenthangingb">• lowpass filtering,</p>
<p class="indenthangingb">• decimation, and finally</p>
<p class="indenthangingb">• performing a smaller-size FFT.</p>
<p class="calibre3">The process begins with the continuous <em class="calibre7">x</em>(<em class="calibre7">t</em>) signal being digitized at a sample rate of <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">1</sub> by an analog-to-digital (A/D) converter, yielding the <em class="calibre7">N</em>-point <em class="calibre7">x</em>(<em class="calibre7">n</em>) time sequence whose spectral magnitude is |<em class="calibre7">X</em>(<em class="calibre7">m</em>)| in <a href="#calibre_link-1420">Figure 13-52(a)</a>. The Zoom FFT technique requires narrowband filtering and decimation <a id="calibre_link-3306"></a>in order to reduce the number of time samples prior to the final FFT, as shown in <a href="#calibre_link-1420">Figure 13-52(b)</a>. The down-converted signal’s spectrum, centered at zero Hz, is the |<em class="calibre7">X<sub class="calibre12">c</sub></em>(<em class="calibre7">m</em>)| shown in <a href="#calibre_link-1420">Figure 13-52(c)</a>. (The lowpass filter’s frequency response is the dashed curve.) After lowpass filtering <em class="calibre7">x<sub class="calibre12">c</sub></em>(<em class="calibre7">n</em>), the filter’s output is decimated by an integer factor <em class="calibre7">D,</em> yielding a time sequence <em class="calibre7">x</em>′<em class="calibre7"><sub class="calibre12">c</sub></em>(<em class="calibre7">n</em>) whose sample rate is <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">2</sub> = <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">1</sub>/<em class="calibre7">D</em> prior to the FFT operation. The key here is that the length of <em class="calibre7">x</em>′<em class="calibre7"><sub class="calibre12">c</sub></em>(<em class="calibre7">n</em>) is <em class="calibre7">N</em>/<em class="calibre7">D</em>, allowing a reduced-size FFT. (<em class="calibre7">N</em>/<em class="calibre7">D</em> must be an integer power of two to enable the use of radix-2 FFTs.) We perform the FFT only over the decimated signal’s bandwidth. It’s of interest to note that, because its input is complex, the <em class="calibre7">N</em>/<em class="calibre7">D</em>-point FFT has a non-redundant frequency analysis range from −<em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">2</sub>/2 to +<em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">2</sub>/2 (unlike the case of real inputs, where the positive- and negative-frequency ranges are redundant).</p>
<p class="calibre3">The implementation of the Zoom FFT is given in <a href="#calibre_link-1421">Figure 13-53</a>, where all discrete sequences are real-valued.</p>
<p class="caption"><a id="calibre_link-1421"></a><strong class="calibre9">Figure 13-53</strong> Zoom FFT processing details.</p>
<p class="image"><img src="images/001225.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Relating the discrete sequences in <a href="#calibre_link-1420">Figure 13-52(b)</a> and <a href="#calibre_link-1421">Figure 13-53</a>, the complex time sequence <em class="calibre7">x<sub class="calibre12">c</sub></em>(<em class="calibre7">n</em>) is represented mathematically as</p>
<p class="caption"><a id="calibre_link-3307"></a>(13-100)</p>
<p class="image"><img src="images/001289.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">while the complex decimated sequence <em class="calibre7">x</em>′<em class="calibre7"><sub class="calibre12">c</sub></em>(<em class="calibre7">n</em>) is</p>
<p class="caption"><a id="calibre_link-3308"></a>(13-101)</p>
<p class="image"><img src="images/000327.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The complex mixing sequence <em class="calibre7">e</em><sup class="calibre10">−<em class="calibre7">j</em>2π<em class="calibre7">f<sub class="calibre15">c</sub>nt<sub class="calibre15">s</sub></em><sub class="calibre15">1</sub></sup>, where <em class="calibre7">t<sub class="calibre12">s</sub></em><sub class="calibre12">1</sub> = 1/<em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">1</sub>, can be represented in the two forms of</p>
<p class="caption"><a id="calibre_link-3309"></a>(13-102)</p>
<p class="image"><img src="images/001170.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Relative to FFT computations, we see that an <em class="calibre7">N</em>/<em class="calibre7">D</em>-point Zoom FFT yields a reduction in computations compared to a standard <em class="calibre7">N</em>-point FFT for spectrum analysis of a narrowband portion of some <em class="calibre7">X</em>(<em class="calibre7">m</em>) spectrum&mdash;and the computational savings improve as the decimation factor <em class="calibre7">D</em> increases. Ah, but here’s the rub. As <em class="calibre7">D</em> increases, the lowpass filters must become narrower, <a id="calibre_link-3310"></a>which increases their computational workload, and this is the trade-off we face. What we must ask ourselves is “Does the Zoom FFT’s reduced FFT size compensate for the additional quadrature mixing and dual filtering computational workload?” (It certainly would if a large-size FFT is impossible with your available FFT hardware or software.)</p>
<p class="calibre3">To gain a rough appreciation for the computational savings gained by using an <em class="calibre7">N</em>/<em class="calibre7">D</em>-point Zoom FFT, compared to a standard <em class="calibre7">N</em>-point FFT, let’s look at <a href="#calibre_link-1422">Figure 13-54</a>. That figure shows the percent computational savings of a Zoom FFT versus a standard <em class="calibre7">N</em>-point FFT for various decimation factors <em class="calibre7">D</em>.</p>
<p class="caption"><a id="calibre_link-1422"></a><strong class="calibre9">Figure 13-54</strong> Zoom FFT computation reduction.</p>
<p class="image"><img src="images/001314.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The curves were computed using the following definition for percent computation reduction</p>
<p class="caption"><a id="calibre_link-1423"></a>(13-103)</p>
<p class="image"><img src="images/000862.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">under the assumptions that the time sequences applied to the FFTs were windowed, and the Zoom FFT’s lowpass filters were 24th-order (25 multiplications per output sample) tapped-delay line FIR filters using folded FIR structures. In <a href="#calibre_link-1423">Eq. (13-103)</a> a single real multiply and a single real addition are both considered as a single computation.</p>
<p class="calibre3">The range where <a href="#calibre_link-1422">Figure 13-54</a>’s curves have negative values means that the Zoom FFT is less efficient (more computations) than a standard <em class="calibre7">N</em>-point FFT. As it turns out, the curves in <a href="#calibre_link-1422">Figure 13-54</a> quickly move downward in efficiency as the order of the lowpass filters increases. So it’s in our best interest to make the lowpass filters as computationally efficient as possible. Some ways to do this are:</p>
<p class="indenthangingb"><a id="calibre_link-2447"></a>• Partition the lowpass filtering/decimation process into multiple stages (multistage decimation) as discussed in <a href="#calibre_link-291">Chapter 10</a>.</p>
<p class="indenthangingb">• Incorporate cascaded integrator-comb (CIC) filters into the lowpass filtering if the spectrum of interest is very narrowband relative to the <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">1</sub>.</p>
<p class="indenthangingb">• Use interpolated FIR filters as discussed in <a href="#calibre_link-187">Chapter 7</a>.</p>
<p class="indenthangingb">• Use polyphase filters as discussed in <a href="#calibre_link-291">Chapter 10</a>.</p>
<p class="indenthangingb">• Restrict the decimation factor <em class="calibre7">D</em> to be an integer power of two such that efficient half-band filters can be used.</p>
<p class="indenthangingb">• Use IIR filters, if spectral phase distortion can be tolerated.</p>
<p class="calibre3"><a id="calibre_link-691"></a></p>
<h3 class="calibre6">13.20 A Practical Spectrum Analyzer</h3>
<p class="calibre3">Here’s a clever trick for implementing a practical spectrum analyzer by modifying the time-domain data before applying a radix-2 FFT algorithm.</p>
<p class="calibre3">Let’s say we need to build a spectrum analyzer to display, in some manner, the spectral magnitude of a time-domain sequence. We’d like our spectrum analyzer, a bank of bandpass filters, to have a frequency magnitude response something like that shown in <a href="#calibre_link-1424">Figure 13-55(a)</a>. For spectrum analysis, the radix-2 FFT algorithm comes to mind first, as it should. However, the frequency response of individual FFT bins is that shown in <a href="#calibre_link-1424">Figure 13-55(b)</a>, with their non-flat passbands, unpleasantly high sidelobes due to spectral leakage, and overlapped main lobes. We can reduce the leakage sidelobe levels by windowing the time-domain sequence, but that leads to the increased <a id="calibre_link-3311"></a>main lobe overlap shown in <a href="#calibre_link-1424">Figure 13-55(c)</a> and degraded frequency resolution, and we still have considerable droop in the passband response.</p>
<p class="caption"><a id="calibre_link-1424"></a><strong class="calibre9">Figure 13-55</strong> Spectrum analyzer: (a) desired frequency response; (b) frequency response of standard FFT bins; (c) windowed-data FFT frequency response.</p>
<p class="image"><img src="images/000351.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Here’s how we can solve our problem. Consider an <em class="calibre7">x</em>(<em class="calibre7">n</em>) sequence of time samples of length <em class="calibre7">M</em> whose <em class="calibre7">M</em>-point DFT is</p>
<p class="caption"><a id="calibre_link-3312"></a>(13-104)</p>
<p class="image"><img src="images/001058.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Next, consider partitioning <em class="calibre7">x</em>(<em class="calibre7">n</em>) into <em class="calibre7">P</em> subsequences, each of length <em class="calibre7">N</em>. Thus <em class="calibre7">PN</em> = <em class="calibre7">M</em>. If we add, element for element, the <em class="calibre7">P</em> subsequences, we’ll obtain a new <em class="calibre7">y</em>(<em class="calibre7">n</em>) sequence of length <em class="calibre7">N</em> whose <em class="calibre7">N</em>-point DFT is</p>
<p class="caption"><a id="calibre_link-1426"></a>(13-105)</p>
<p class="image"><img src="images/000110.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The good news is that</p>
<p class="caption"><a id="calibre_link-3313"></a>(13-106)</p>
<p class="image"><img src="images/000949.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">That is, the DFT magnitudes of sequence <em class="calibre7">y</em>(<em class="calibre7">n</em>) are equal to a subset of the longer DFT magnitudes of <em class="calibre7">x</em>(<em class="calibre7">n</em>). <em class="calibre7">Y</em>(<em class="calibre7">m</em>) is equal to a decimated-by-<em class="calibre7">P</em> version of <em class="calibre7">X</em>(<em class="calibre7">k</em>). The relationship between |<em class="calibre7">Y</em>(<em class="calibre7">m</em>)| and |<em class="calibre7">X</em>(<em class="calibre7">Pm</em>)| doesn’t seem too important, but here’s how we’ll take advantage of that equality. We’ll create an <em class="calibre7">M</em>-point window sequence whose single-bin frequency response, of an <em class="calibre7">M</em>-point FFT, is the bold curve in <a href="#calibre_link-1425">Figure 13-56(a)</a>. Instead of computing all <em class="calibre7">M</em> FFT outputs, we’ll only compute every <em class="calibre7">P</em>th output of the <em class="calibre7">M</em>-point FFT, implementing <a href="#calibre_link-1426">Eq. (13-105)</a>, giving us the decimated FFT bins shown in <a href="#calibre_link-1425">Figure 13-56(b)</a>. In that figure <em class="calibre7">P</em> = 5.</p>
<p class="caption"><a id="calibre_link-1425"></a><strong class="calibre9">Figure 13-56</strong> FFT spectrum analyzer frequency responses.</p>
<p class="image"><img src="images/001194.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">That decimation of the frequency-domain |<em class="calibre7">X</em>(<em class="calibre7">k</em>)| spectrum is accomplished in the time domain by a time-aliasing operation as shown in <a href="#calibre_link-1427">Figure 13-57</a>, <a id="calibre_link-2446"></a>where again, for example, <em class="calibre7">P</em> = 5. We partition the <em class="calibre7">M</em>-sample windowed-<em class="calibre7">x</em>(<em class="calibre7">n</em>) time sequence into <em class="calibre7">P</em> = 5 subsequences and sum the subsequences element for element to obtain the time-aliased <em class="calibre7">N</em>-sample <em class="calibre7">y</em>(<em class="calibre7">n</em>) sequence. Next, the |<em class="calibre7">Y</em>(<em class="calibre7">m</em>)| spectral magnitudes are computed using the radix-2 FFT.</p>
<p class="caption"><a id="calibre_link-1427"></a><strong class="calibre9">Figure 13-57</strong> FFT spectrum analyzer process.</p>
<p class="image"><img src="images/000235.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">This process, sweet in its simplicity, is called the <em class="calibre7">weighted overlap-add</em> structure[<a href="#calibre_link-1428">51</a>,<a href="#calibre_link-1429">52</a>] and is alternatively referred to as the <em class="calibre7">window-presum FFT</em><a href="#calibre_link-1430">[53]</a>. The most difficult part of building this analyzer is designing the <em class="calibre7">M</em>-point window sequence used to window the original <em class="calibre7">x</em>(<em class="calibre7">n</em>) sequence. We do that by specifying the window’s frequency-domain characteristics, just as if it were a digital filter frequency response, and using our favorite filter design software to compute the filter’s time-domain impulse response. That impulse response is the window sequence. With the signal sample rate being <em class="calibre7">f<sub class="calibre12">s</sub></em>, the window’s passband width will be just less than <em class="calibre7">f<sub class="calibre12">s</sub></em>/<em class="calibre7">N.</em> This makes the filter’s one-sided passband width roughly <em class="calibre7">f<sub class="calibre12">s</sub></em>/2<em class="calibre7">N</em>.</p>
<p class="calibre3"><a href="#calibre_link-1431">Figure 13-58</a> illustrates an example FFT analyzer with <em class="calibre7">f<sub class="calibre12">s</sub></em> = 1 MHz, <em class="calibre7">N</em> = 64, with <em class="calibre7">P</em> = 5 making <em class="calibre7">M</em> = 320. The FFT bin spacing is 15.63 kHz, so the window design was set for a passband width of 10 kHz (thus the filter’s one-sided bandwidth was specified as 5 kHz in a Parks-McClellan design routine). <a href="#calibre_link-1431">Figure 13-58(a)</a> is the 320-point window sequence, while <a href="#calibre_link-1431">Figure 13-58(b)</a> shows the FFT analyzer’s response for the <em class="calibre7">m</em> = 3, 4, and 5 bins, with the |<em class="calibre7">Y</em>(4)| response being the solid curve.</p>
<p class="caption"><a id="calibre_link-1431"></a><strong class="calibre9">Figure 13-58</strong> FFT analyzer example: (a) window sequence; (b) analyzer response for 64-point FFT bins |<em class="calibre7">Y</em>(3)|, |<em class="calibre7">Y</em>(4)|, and |<em class="calibre7">Y</em>(5)|.</p>
<p class="image"><img src="images/001077.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The width of the spectrum analyzer’s passbands is primarily controlled by the window’s passband width. The center frequencies of the analyzer’s individual passbands are defined by <em class="calibre7">f<sub class="calibre12">s</sub></em>/<em class="calibre7">N</em>. What this means is that the amount of overlap in the analyzer’s passbands depends on both the window’s passband width, <em class="calibre7">f<sub class="calibre12">s</sub></em>, and <em class="calibre7">N</em>. The dynamic range of the analyzer can be increased by increasing <em class="calibre7">P,</em> which increases <em class="calibre7">M</em> and lengthens the <em class="calibre7">x</em>(<em class="calibre7">n</em>) sequence. As <em class="calibre7">M</em> is increased, the longer window sequence will yield analyzer passbands having a more rectangular shape, lower sidelobes, and reduced passband ripple.</p>
<p class="calibre3"><a id="calibre_link-1983"></a>Again, to implement this radix-2 FFT spectrum analyzer, the length of the time-domain sequence (<em class="calibre7">M</em>) must be an integer multiple (<em class="calibre7">P</em>) of an integer power of two (<em class="calibre7">N</em>).</p>
<p class="calibre3"><a id="calibre_link-692"></a></p>
<h3 class="calibre6">13.21 An Efficient Arctangent Approximation</h3>
<p class="calibre3">Fast and accurate methods for computing the arctangent of a complex number <em class="calibre7">x</em> = <em class="calibre7">I</em> + <em class="calibre7">jQ</em> have been the subject of extensive study because estimating the angle θ of a complex value has so many applications in the field of signal processing. The angle of <em class="calibre7">x</em> is defined as θ = tan<sup class="calibre10">−1</sup>(<em class="calibre7">Q</em>/<em class="calibre7">I</em>).</p>
<p class="calibre3">Practitioners interested in computing high-speed (minimum computations) arctangents typically use look-up tables where the value <em class="calibre7">Q</em>/<em class="calibre7">I</em> specifies a memory address in read-only memory (ROM) containing an approximation of angle θ. For high accuracy, though, this method may require very large ROM tables. Those folk interested in enhanced accuracy implement compute-intensive high-order algebraic polynomials, where Chebyshev polynomials seem to be more popular than Taylor series, to approximate angle θ. But this polynomial method requires many computations. Unfortunately, because it is such a nonlinear function, the arctangent is resistant to accurate reasonable-length polynomial approximations. There is a processing method called “CORDIC” (an acronym for <strong class="calibre9">CO</strong>ordinate <strong class="calibre9">R</strong>otation <strong class="calibre9">DI</strong>gital <strong class="calibre9">C</strong>omputer) that can compute accurate arctangents using only binary shifts and additions, but this technique can require long processing times. So, sadly, we end up choosing the <em class="calibre7">least undesirable</em> method for computing arctangents.</p>
<p class="calibre3"><a id="calibre_link-3314"></a>If you want to become famous in the field of signal processing, all you have to do is produce a very accurate arctangent algorithm that requires very few computations. (After solving that problem, you can then apply your skills to developing a perpetual-motion machine.)</p>
<p class="calibre3">Here’s another contender in the arctangent approximation race that uses neither look-up tables nor high-order polynomials. We can estimate the angle θ, in radians, of <em class="calibre7">x</em> = <em class="calibre7">I</em> + <em class="calibre7">jQ</em> using the following approximation:</p>
<p class="caption"><a id="calibre_link-1432"></a>(13-107)</p>
<p class="image"><img src="images/000245.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where −1 ≤ <em class="calibre7">Q</em>/<em class="calibre7">I</em> ≤ 1. That is, θ is in the range −45 to +45 degrees (−π/4 ≤ θ ≤ +π/4 radians). <a href="#calibre_link-1432">Equation (13-107)</a> has surprisingly good performance, particularly for a 90-degree (π/2 radians) angle range. <a href="#calibre_link-1433">Figure 13-59</a> shows the maximum error is 0.28 degrees using <a href="#calibre_link-1432">Eq. (13-107)</a> when the true angle θ is within the angular range of −45 to +45 degrees</p>
<p class="caption"><a id="calibre_link-1433"></a><strong class="calibre9">Figure 13-59</strong> Estimated angle θ’ error in degrees.</p>
<p class="image"><img src="images/000654.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">A nice feature of this θ’ computation is that it can be written as</p>
<p class="caption"><a id="calibre_link-1434"></a>(13-108)</p>
<p class="image"><img src="images/000839.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">eliminating <a href="#calibre_link-1432">Eq. (13-107)</a>’s <em class="calibre7">Q</em>/<em class="calibre7">I</em> division operation, at the expense of two additional multiplies. Another attribute of <a href="#calibre_link-1434">Eq. (13-108)</a> is that a single multiply can be eliminated with binary right shifts. The product 0.28125<em class="calibre7">Q</em><sup class="calibre10">2</sup> is equal to (1/4+1/32)<em class="calibre7">Q</em><sup class="calibre10">2</sup>, so we can implement the product by adding <em class="calibre7">Q</em><sup class="calibre10">2</sup> shifted right by two bits to <em class="calibre7">Q</em><sup class="calibre10">2</sup> shifted right by five bits. This arctangent scheme may be useful in a digital receiver application where <em class="calibre7">I</em><sup class="calibre10">2</sup> and <em class="calibre7">Q</em><sup class="calibre10">2</sup> have been previously computed in conjunction with an AM (amplitude modulation) demodulation process or envelope detection associated with automatic gain control (AGC).</p>
<p class="calibre3">We can extend the angle range over which our approximation operates. If we break up a circle into eight 45-degree octants, with the first octant being <a id="calibre_link-2265"></a>0 to 45 degrees, we can compute the arctangent of a complex number residing in any octant. We do this by using the rotational symmetry properties of the arctangent:</p>
<p class="caption"><a id="calibre_link-3315"></a>(13-109)</p>
<p class="image"><img src="images/001702.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-3316"></a>(13-110)</p>
<p class="image"><img src="images/001576.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Those properties allow us to create <a href="#calibre_link-1435">Table 13-6</a>.</p>
<p class="caption"><a id="calibre_link-1435"></a><strong class="calibre9">Table 13-6</strong> Octant Location versus Arctangent Expressions</p>
<p class="image"><img src="images/000076.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">So we have to check the signs of <em class="calibre7">Q</em> and <em class="calibre7">I</em>, and see if |<em class="calibre7">Q</em>| &gt; |<em class="calibre7">I</em>|, to determine the octant location, and then use the appropriate approximation in <a href="#calibre_link-1435">Table 13-6</a>. <a href="#calibre_link-705">Section 13.38</a> gives a method for determining the octant of the original θ. The maximum angle approximation error is 0.28 degrees for all octants.</p>
<p class="calibre3"><a id="calibre_link-314"></a></p>
<h3 class="calibre6">13.22 Frequency Demodulation Algorithms</h3>
<p class="calibre3">In <a href="#calibre_link-648">Section 9.2</a> we discussed the notion of measuring the instantaneous frequency of a complex sinusoidal signal by computing the derivative of the signal’s instantaneous θ(<em class="calibre7">n</em>) phase as shown in <a href="#calibre_link-1436">Figure 13-60</a>. This is the traditional discrete-signal FM demodulation method, and it works fine. The demodulator’s instantaneous output frequency is</p>
<p class="caption"><a id="calibre_link-1437"></a>(13-111)</p>
<p class="image"><img src="images/000602.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-1436"></a><strong class="calibre9">Figure 13-60</strong> Frequency demodulator using an arctangent function.</p>
<p class="image"><img src="images/001510.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where <em class="calibre7">f<sub class="calibre12">s</sub></em> is the sample rate in Hz.</p>
<p class="calibre3"><a id="calibre_link-3317"></a>Computing instantaneous phase θ(<em class="calibre7">n</em>) requires an arctangent operation, which is difficult to implement accurately without considerable computational resources. Here’s a scheme for computing Δθ(<em class="calibre7">n</em>) for use in <a href="#calibre_link-1437">Eq. (13-111)</a> without the intermediate θ(<em class="calibre7">n</em>) phase computation (and its pesky arctangent)[<a href="#calibre_link-1438">54</a>,<a href="#calibre_link-1439">55</a>]. We derive the Δθ(<em class="calibre7">n</em>) computation algorithm as follows, initially using continuous-time variables based on the following definitions:</p>
<p class="caption"><a id="calibre_link-3318"></a>(13-112)</p>
<p class="image"><img src="images/000421.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The following algorithm is based on the assumption that the spectrum of the <em class="calibre7">i</em>(<em class="calibre7">t</em>) + <em class="calibre7">jq</em>(<em class="calibre7">t</em>) signal is centered at zero Hz. First, we let <em class="calibre7">r</em>(<em class="calibre7">t</em>) = <em class="calibre7">q</em>(<em class="calibre7">t</em>)/<em class="calibre7">i</em>(<em class="calibre7">t</em>) be the signal for which we’re trying to compute the derivative of its arctangent. The time derivative of tan<sup class="calibre10">−1</sup>[<em class="calibre7">r</em>(<em class="calibre7">t</em>)], a calculus identity, is</p>
<p class="caption"><a id="calibre_link-1441"></a>(13-113)</p>
<p class="image"><img src="images/000446.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Because d[<em class="calibre7">r</em>(<em class="calibre7">t</em>)]/d<em class="calibre7">t</em> = d[<em class="calibre7">q</em>(<em class="calibre7">t</em>)/<em class="calibre7">i</em>(<em class="calibre7">t</em>)]/d<em class="calibre7">t</em>, we use the calculus identity for the derivative of a ratio to write</p>
<p class="caption"><a id="calibre_link-1440"></a>(13-114)</p>
<p class="image"><img src="images/000470.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Plugging <a href="#calibre_link-1440">Eq. (13-114)</a>’s result into <a href="#calibre_link-1441">Eq. (13-113)</a>, we have</p>
<p class="caption"><a id="calibre_link-1442"></a>(13-115)</p>
<p class="image"><img src="images/000397.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Replacing <em class="calibre7">r</em>(<em class="calibre7">t</em>) in <a href="#calibre_link-1442">Eq. (13-115)</a> with <em class="calibre7">q</em>(<em class="calibre7">t</em>)/<em class="calibre7">i</em>(<em class="calibre7">t</em>) yields</p>
<p class="caption"><a id="calibre_link-1443"></a>(13-116)</p>
<p class="image"><img src="images/001246.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3319"></a>We’re getting there. Next we multiply the numerator and denominator of the first ratio in <a href="#calibre_link-1443">Eq. (13-116)</a> by <em class="calibre7">i</em><sup class="calibre10">2</sup>(<em class="calibre7">t</em>) and replace <em class="calibre7">t</em> with our discrete time variable index <em class="calibre7">n</em> to arrive at our final result of</p>
<p class="caption"><a id="calibre_link-1445"></a>(13-117)</p>
<p class="image"><img src="images/000286.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The implementation of this algorithm, where the derivatives of <em class="calibre7">i</em>(<em class="calibre7">n</em>) and <em class="calibre7">q</em>(<em class="calibre7">n</em>) are <em class="calibre7">i</em>′(<em class="calibre7">n</em>) and <em class="calibre7">q</em>′(<em class="calibre7">n</em>) respectively, is shown in <a href="#calibre_link-1444">Figure 13-61(a)</a>. The Δϕ(<em class="calibre7">n</em>) output sequence is used in <a href="#calibre_link-1437">Eq. (13-111)</a> to compute instantaneous frequency.</p>
<p class="caption"><a id="calibre_link-1444"></a><strong class="calibre9">Figure 13-61</strong> Frequency demodulator without arctangent: (a) standard process; (b) simplified process.</p>
<p class="image"><img src="images/000545.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The Differentiators are tapped-delay line FIR differentiating filters with an odd number of taps. The <em class="calibre7">z</em><sup class="calibre10">−<em class="calibre7">D</em></sup> delay elements in <a href="#calibre_link-1444">Figure 13-61(a)</a> are used to time-align the input <em class="calibre7">i</em>(<em class="calibre7">n</em>) and <em class="calibre7">q</em>(<em class="calibre7">n</em>) sequences with the outputs of the differentiators. <a id="calibre_link-2009"></a>The delay is <em class="calibre7">D</em> = (<em class="calibre7">K</em>−1)/2 samples when a <em class="calibre7">K</em>-tap differentiator is used. In practice, those <em class="calibre7">z</em><sup class="calibre10">−<em class="calibre7">D</em></sup> delays can be obtained by tapping off the center tap of the differentiating filter as shown in <a href="#calibre_link-1444">Figure 13-61(b)</a>, where the differentiator is an FIR filter having 1,0,−1 as coefficients, and <em class="calibre7">D</em> = 1 in this case<a href="#calibre_link-1439">[55]</a>. Such a differentiator is the simple “central-difference differentiator” we discussed in <a href="#calibre_link-187">Chapter 7</a>, and its optimum performance occurs when the input signal is low frequency relative to the demodulator’s input <em class="calibre7">f<sub class="calibre12">s</sub></em> sample rate. Reference <a href="#calibre_link-1439">[55]</a> reports acceptable results using the differentiator in <a href="#calibre_link-1444">Figure 13-61(b)</a>, but that’s only true if the complex input signal has a bandwidth no greater than <em class="calibre7">f<sub class="calibre12">s</sub></em>/10.</p>
<p class="calibre3">If the <em class="calibre7">i</em>(<em class="calibre7">n</em>)+<em class="calibre7">jq</em>(<em class="calibre7">n</em>) signal is purely FM and <em class="calibre7">hard limited</em> such that <em class="calibre7">i</em><sup class="calibre10">2</sup>(<em class="calibre7">n</em>)+<em class="calibre7">q</em><sup class="calibre10">2</sup>(<em class="calibre7">n</em>) = Constant, the denominator computations in <a href="#calibre_link-1445">Eq. (13-117)</a> need not be performed. In this case, using the 1,0,−1 coefficient differentiators, the FM demodulator is simplified to that shown in <a href="#calibre_link-1444">Figure 13-61(b)</a>, where the Scaling operation is multiplication by the reciprocal of Constant.</p>
<p class="calibre3">Two final things to consider: First, in practice we may want to detect the unusual situation where both <em class="calibre7">i</em>(<em class="calibre7">n</em>) and <em class="calibre7">q</em>(<em class="calibre7">n</em>) are zero-valued, making the denominator of <a href="#calibre_link-1445">Eq. (13-117)</a> equal to zero. We should set Δθ(<em class="calibre7">n</em>) to zero in that case. Second, for real-world noisy signals it may be prudent to apply the Δθ(<em class="calibre7">n</em>) output to a lowpass filter to reduce unwanted high-frequency noise.</p>
<p class="calibre3"><a id="calibre_link-693"></a></p>
<h3 class="calibre6">13.23 DC Removal</h3>
<p class="calibre3">When we digitize analog signals using an analog-to-digital (A/D) converter, the converter’s output typically contains some small DC bias; that is, the average of the digitized time samples is not zero. That DC bias may have come from the original analog signal or from imperfections within the A/D converter. Another source of DC bias contamination in DSP is when we truncate a discrete sequence from a <em class="calibre7">B</em>-bit representation to word widths less than <em class="calibre7">B</em> bits. Whatever the source, unwanted DC bias on a signal can cause problems. When we’re performing spectrum analysis, any DC bias on the signal shows up in the frequency domain as energy at zero Hz, the <em class="calibre7">X</em>(0) spectral sample. For an <em class="calibre7">N</em>-point FFT the <em class="calibre7">X</em>(0) spectral value is proportional to <em class="calibre7">N</em> and becomes inconveniently large for large-sized FFTs. When we plot our spectral magnitudes, the plotting software will accommodate any large <em class="calibre7">X</em>(0) value and squash down the remainder of the spectrum in which we are more interested.</p>
<p class="calibre3">A nonzero DC bias level in audio signals is particularly troublesome because concatenating two audio signals, or switching between two audio signals, results in unpleasant audible clicks. In modern digital communications systems, a DC bias on quadrature signals degrades system performance and increases bit error rates. With that said, it’s clear that methods for DC removal are of interest to many DSP practitioners.</p>
<p class="calibre3"><a id="calibre_link-3320"></a></p>
<h4 class="calibre13"><a id="calibre_link-2100"></a>13.23.1 Block-Data DC Removal</h4>
<p class="calibre3">If you’re processing in non-real time, and the signal data is acquired in blocks (fixed-length sequences) of block length <em class="calibre7">N</em>, DC removal is straightforward. We merely compute the average of our <em class="calibre7">N</em> time samples and subtract that average value from each original sample to yield a new time sequence whose DC bias will be extremely small.</p>
<p class="calibre3">This scheme, although very effective, is not compatible with continuous-throughput (real-time) systems. For real-time systems we’re forced to use filters for DC removal.</p>
<p class="calibre3"><a id="calibre_link-3321"></a></p>
<h4 class="calibre13">13.23.2 Real-Time DC Removal</h4>
<p class="calibre3">The author has encountered three proposed filters for DC removal[<a href="#calibre_link-1446">56</a>&ndash;<a href="#calibre_link-1447">58</a>]; their structures are shown in <a href="#calibre_link-1448">Figures 13-62(a)</a>, <a href="#calibre_link-1448">13-62(b)</a>, and <a href="#calibre_link-1448">13-62(c)</a>.</p>
<p class="caption"><a id="calibre_link-1448"></a><strong class="calibre9">Figure 13-62</strong> Filters used for DC bias removal.</p>
<p class="image"><img src="images/001401.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Ignoring the constant gains of those DC-removal filters, all three filters have identical performance with the <em class="calibre7">general DC-removal</em> filter structure in <a href="#calibre_link-1448">Figure 13-62(d)</a> having a <em class="calibre7">z</em>-domain transfer function of</p>
<p class="caption"><a id="calibre_link-1449"></a>(13-118)</p>
<p class="image"><img src="images/001128.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">(It’s not immediately obvious that the filters in <a href="#calibre_link-1448">Figures 13-62(c)</a> and <a href="#calibre_link-1448">13-62(d)</a> are equivalent. You can verify that equivalency by writing the time-domain difference equations relating the various nodes in the feedback path of <a href="#calibre_link-1448">Figure 13-62(c)</a>’s filter. Next, convert those equations to <em class="calibre7">z</em>-transform expressions and solve for <em class="calibre7">Y</em>(<em class="calibre7">z</em>)/<em class="calibre7">X</em>(<em class="calibre7">z</em>) to yield <a href="#calibre_link-1449">Eq. (13-118)</a>).</p>
<p class="calibre3"><a id="calibre_link-2103"></a>Because the DC-removal filters can be modeled with the general DC-removal filter in <a href="#calibre_link-1448">Figure 13-62(d)</a>, we provide the general filter’s frequency magnitude and phase responses in <a href="#calibre_link-1450">Figures 13-63(a)</a> and <a href="#calibre_link-1450">13-63(b)</a> for α = 0.95. The filter’s pole/zero locations are given in <a href="#calibre_link-1450">Figure 13-63(c)</a>, where a zero resides at <em class="calibre7">z</em> = 1 providing infinite attenuation at DC (zero Hz) and a pole at <em class="calibre7">z</em> = α making the magnitude notch at DC very sharp. The closer α is to unity, the narrower the frequency magnitude notch centered at zero Hz. <a href="#calibre_link-1450">Figure 13-63(d)</a> shows the general filter’s unit-sample impulse response.</p>
<p class="caption"><a id="calibre_link-1450"></a><strong class="calibre9">Figure 13-63</strong> DC-removal filter, α = 0.95: (a) magnitude response; (b) phase response; (c) pole/zero locations; (d) impulse response.</p>
<p class="image"><img src="images/000638.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a href="#calibre_link-1451">Figure 13-64</a> shows the time-domain input/output performance of the general DC-removal filter (with α = 0.95) when its input is a sinusoid suddenly contaminated with a DC bias of 2 beginning at the 100th time sample and disappearing at the 200th sample. The DC-removal filter works well.</p>
<p class="caption"><a id="calibre_link-1451"></a><strong class="calibre9">Figure 13-64</strong> DC-removal filter performance: (a) filter input with sudden DC bias; (b) filter output.</p>
<p class="image"><img src="images/001293.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3322"></a></p>
<h4 class="calibre13">13.23.3 Real-Time DC Removal with Quantization</h4>
<p class="calibre3">Because the general DC-removal filter has feedback, the <em class="calibre7">y</em>(<em class="calibre7">n</em>) output samples may require wider binary word widths than those used for the <em class="calibre7">x</em>(<em class="calibre7">n</em>) input samples. This could result in overflows in fixed-point binary implementations. The scaling factors of (1+α)/2 and <em class="calibre7">K</em>, in <a href="#calibre_link-1448">Figures 13-62(a)</a> and <a href="#calibre_link-1448">13-62(b)</a>, are less than one to minimize the chance of <em class="calibre7">y</em>(<em class="calibre7">n</em>) binary overflow.</p>
<p class="calibre3">In fixed-point hardware the <em class="calibre7">y</em>(<em class="calibre7">n</em>) samples are often truncated to the same word width as the input <em class="calibre7">x</em>(<em class="calibre7">n</em>). This quantization (by means of truncation) will <a id="calibre_link-3323"></a>induce a negative DC bias onto the quantized output samples, degrading our desired DC removal. When we truncate a binary sample value, by discarding some of its least significant bits, we induce a negative error in the truncated sample. Fortunately, that error value is available for us to add to the next unquantized signal sample, increasing its positive DC bias. When that next sample is truncated, the positive error we’ve added minimizes the negative error induced by truncation of the next sample.</p>
<p class="calibre3"><a href="#calibre_link-1452">Figure 13-65(a)</a> shows the addition of a quantizing sigma-delta modulator to the feedback path of the DC-removal filter given in <a href="#calibre_link-1448">Figure 13-62(c)</a>. The <a id="calibre_link-2056"></a>positive error induced by truncation quantization (the Q block) is delayed by one sample time and fed back to the quantizer input. Because the modulator has a <em class="calibre7">noise shaping</em> property where quantization error noise is shifted up in frequency, away from zero Hz (DC), the overall DC bias at the output of the filter is minimized<a href="#calibre_link-1453">[57]</a>.</p>
<p class="caption"><a id="calibre_link-1452"></a><strong class="calibre9">Figure 13-65</strong> Two DC-removal filters using fixed-point quantization to avoid data overflow.</p>
<p class="image"><img src="images/000332.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">An equivalent quantization noise shaping process can be applied to a Direct Form I version of the <a href="#calibre_link-1448">Figure 13-62(d)</a> general DC-removal filter as shown in <a href="#calibre_link-1452">Figure 13-65(b)</a>. Again, the positive quantization error is delayed by one sample time and added to the quantizer input[<a href="#calibre_link-1454">59</a>&ndash;<a href="#calibre_link-1455">61</a>]. To reiterate, the DC-removal filters in <a href="#calibre_link-1452">Figure 13-65</a> are used to avoid binary data overflow, by means of quantization, without the use of scaling multipliers.</p>
<p class="calibre3">Later in this chapter we discuss a DC-removal filter whose frequency response exhibits linear phase.</p>
<p class="calibre3"><a id="calibre_link-215"></a></p>
<h3 class="calibre6">13.24 Improving Traditional CIC Filters</h3>
<p class="calibre3">A major design goal for cascaded integrator-comb (CIC) filters, as introduced in <a href="#calibre_link-291">Chapter 10</a> in conjunction with sample rate conversion, is to minimize their hardware power consumption by reducing data word width and reducing data clock rates wherever possible. Here we introduce a clever trick that reduces CIC filter power consumption using nonrecursive structures, by means of <em class="calibre7">polynomial factoring</em>, easing the word width growth problem. These nonrecursive structures require that the sample rate change <em class="calibre7">R</em> be an integer power of two, enhancing computational simplicity through <em class="calibre7">polyphase decomposition</em>, <em class="calibre7">transposed structures, simplified multiplication</em>, and <em class="calibre7">substructure sharing</em>[<a href="#calibre_link-1456">62</a>&ndash;<a href="#calibre_link-1457">64</a>]. (These processes are not complicated; they merely have fancy names.) Next, we’ll review a nonrecursive scheme that enables sample rate changes other than powers of two. The following discussion assumes that the reader is familiar with the CIC filter material in <a href="#calibre_link-291">Chapter 10</a>.</p>
<p class="calibre3"><a id="calibre_link-3324"></a></p>
<h4 class="calibre13">13.24.1 Nonrecursive CIC Filters</h4>
<p class="calibre3">Recall that the structures of 1st-order (<em class="calibre7">M</em> = 1) and 3rd-order (<em class="calibre7">M</em> = 3) CIC decimation filters, having a comb delay equal to the sample rate change factor <em class="calibre7">R</em>, are those shown in <a href="#calibre_link-1458">Figure 13-66</a>. As presented in <a href="#calibre_link-291">Chapter 10</a>, the transfer <a id="calibre_link-3325"></a>function of an <em class="calibre7">M</em>th-order decimating CIC filter can be expressed in either a recursive form or a nonrecursive form, as indicated in <a href="#calibre_link-1459">Eq. (13-119)</a>. (You could, if you wish, use the geometric series discussion in <a href="#calibre_link-294">Appendix B</a> to show the equality of the two forms of the filter’s transfer function.)</p>
<p class="caption"><a id="calibre_link-1459"></a>(13-119)</p>
<p class="image"><img src="images/000175.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-1460"></a>(13-119′)</p>
<p class="image"><img src="images/000628.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-1458"></a><strong class="calibre9">Figure 13-66</strong> Recursive decimation CIC filters: (a) 1st-order filter; (b) 3rd-order filter.</p>
<p class="image"><img src="images/001175.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Now if the sample rate change factor <em class="calibre7">R</em> is an integer power of two, <em class="calibre7">R</em> = 2<em class="calibre7"><sup class="calibre10">K</sup></em> where <em class="calibre7">K</em> is some positive integer, the <a href="#calibre_link-1460">Eq. (13-119′)</a> <em class="calibre7">M</em>th-order nonrecursive polynomial form of <em class="calibre7">H</em><sub class="calibre12">cic</sub>(<em class="calibre7">z</em>) can be factored as</p>
<p class="caption"><a id="calibre_link-3326"></a>(13-120)</p>
<p class="image"><img src="images/000796.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The reward for this factorization is that the CIC filter can then be implemented with <em class="calibre7">K</em> nonrecursive stages as shown in <a href="#calibre_link-1461">Figure 13-67</a>. This implementation eliminates filter feedback loops with their unpleasant binary word width growth. The data word width does increase in this nonrecursive structure by <em class="calibre7">M</em> bits for each stage, but the sampling rate is reduced by a factor of two for each stage. This nonrecursive structure has been shown to consume less power than the <a href="#calibre_link-1458">Figure 13-66(b)</a> recursive implementation for filter orders greater than three and decimation/interpolation factors larger than eight<a href="#calibre_link-1457">[64]</a>. Thus the power savings from sample rate reduction are greater than the power consumption increase due to data word width growth.</p>
<p class="caption"><a id="calibre_link-1461"></a><strong class="calibre9">Figure 13-67</strong> Multistage <em class="calibre7">M</em>th-order nonrecursive CIC structure.</p>
<p class="image"><img src="images/000216.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Happily, further improvements are possible with each stage of this nonrecursive structure<a href="#calibre_link-1462">[63]</a>. For example, assume we desire an <em class="calibre7">M</em> = 5th-order decimating CIC for Stage 1 in <a href="#calibre_link-1461">Figure 13-67</a>. In that case, the stage’s transfer function is</p>
<p class="caption"><a id="calibre_link-1463"></a>(13-121)</p>
<p class="image"><img src="images/001653.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3327"></a>The second step in <a href="#calibre_link-1463">Eq. (13-121)</a>, known as <em class="calibre7">polyphase decomposition</em>[<a href="#calibre_link-1464">65</a>&ndash;<a href="#calibre_link-1465">69</a>], enables a polyphase implementation having two parallel paths as shown in <a href="#calibre_link-1466">Figure 13-68</a>. The initial delay element and the dual decimation-by-two operations are implemented by routing the odd-indexed input samples to <em class="calibre7">F</em><sub class="calibre12">A′</sub>(<em class="calibre7">z</em>), and the even-indexed samples to <em class="calibre7">F</em><sub class="calibre12">B′</sub>(<em class="calibre7">z</em>). Because we implement decimation by two before the filtering, the new polyphase components are <em class="calibre7">F</em><sub class="calibre12">A′</sub>(<em class="calibre7">z</em>) = 1 + 10<em class="calibre7">z</em><sup class="calibre10">−1</sup> + 5<em class="calibre7">z</em><sup class="calibre10">−2</sup>, and <em class="calibre7">F</em><sub class="calibre12">B′</sub>(<em class="calibre7">z</em>) = 5 + 10<em class="calibre7">z</em><sup class="calibre10">−1</sup> + <em class="calibre7">z</em><sup class="calibre10">−2</sup> implemented at half the data rate into the stage. (Reducing data rates as early as possible is a key design goal in the implementation of CIC decimation filters.)</p>
<p class="caption"><a id="calibre_link-1466"></a><strong class="calibre9">Figure 13-68</strong> Polyphase structure of a single nonrecursive 5th-order CIC stage.</p>
<p class="image"><img src="images/001062.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The <em class="calibre7">F</em><sub class="calibre12">A′</sub>(<em class="calibre7">z</em>) and <em class="calibre7">F</em><sub class="calibre12">B′</sub>(<em class="calibre7">z</em>) polyphase components are implemented in a tapped-delay line fashion and, fortunately, further simplifications are possible. Let’s consider the <em class="calibre7">F</em><sub class="calibre12">A′</sub>(<em class="calibre7">z</em>) polyphase filter component, in a tapped-delay line configuration, shown in <a href="#calibre_link-1467">Figure 13-69(a)</a>. The transposed version of this <a id="calibre_link-2390"></a>filter is presented in <a href="#calibre_link-1467">Figure 13-69(b)</a> with its flipped coefficient sequence. The adder in <a href="#calibre_link-1467">Figure 13-69(a)</a> must perform two additions per input data sample, while in the transposed structure no adder need perform more than one add per data sample. Thus the transposed structure can operate at a higher speed.</p>
<p class="caption"><a id="calibre_link-1467"></a><strong class="calibre9">Figure 13-69</strong> Filter component <em class="calibre7">F</em><sub class="calibre12">A′</sub>(<em class="calibre7">z</em>): (a) delay line structure; (b) transposed structure; (c) simplified multiplication; (d) substructure sharing.</p>
<p class="image"><img src="images/000115.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The next improvement uses simplified multiplication, as shown in <a href="#calibre_link-1467">Figure 13-69(c)</a>, by means of arithmetic shifts and adds. Thus a factor of five is implemented as 2<sup class="calibre10">2</sup> + 1, eliminating all multiplications. Finally, because of the transposed structure, we can use the technique of <em class="calibre7">substructure sharing</em> in <a href="#calibre_link-1467">Figure 13-69(d)</a> to reduce the hardware component count. Pretty slick! By the way, these nonrecursive filters are still called cascaded integrator-comb filters, even though they have no integrators. Go figure.</p>
<p class="calibre3"><a href="#calibre_link-1468">Table 13-7</a> is provided to help the reader avoid computing the polynomial equivalent of several <em class="calibre7">M</em>th-order nonrecursive stages, as was performed in <a href="#calibre_link-1463">Eq. (13-121)</a>.</p>
<p class="caption"><a id="calibre_link-1468"></a><strong class="calibre9">Table 13-7</strong> Expansions of (1 + <em class="calibre7">z</em><sup class="calibre10">−1</sup>)<em class="calibre7"><sup class="calibre10">M</sup></em></p>
<p class="image"><img src="images/000490.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3328"></a></p>
<h4 class="calibre13">13.24.2 Nonrecursive Prime-Factor-<em class="calibre7">R</em> CIC Filters</h4>
<p class="calibre3">The nonrecursive CIC decimation filters described above have the restriction that the <em class="calibre7">R</em> decimation factor must be an integer power of two. That constraint is loosened due to a clever scheme of factoring <em class="calibre7">R</em> into a product of prime numbers<a href="#calibre_link-1469">[70]</a>. This <em class="calibre7">multiple prime-factor-R</em> technique is based on the process of factoring integer <em class="calibre7">R</em> into the form <em class="calibre7">R</em> = 2<em class="calibre7"><sup class="calibre10">p</sup></em>3<em class="calibre7"><sup class="calibre10">q</sup></em>5<em class="calibre7"><sup class="calibre10">r</sup></em>7<em class="calibre7"><sup class="calibre10">s</sup></em>11<em class="calibre7"><sup class="calibre10">t</sup></em> ..., where 2, 3, 5, 7, 11 are the prime numbers. (This process is called <em class="calibre7">prime factorization</em>, or <em class="calibre7">prime decomposition</em>, and has been of interest since the days of Euclid.) Then the appropriate number of CIC subfilters are cascaded as shown in <a href="#calibre_link-1470">Figure 13-70(a)</a>. The fortunate condition is that those <em class="calibre7">M</em>th-order CIC filters are described by</p>
<p class="caption"><a id="calibre_link-3329"></a><a id="calibre_link-1471"></a>(13-122)</p>
<p class="image"><img src="images/000678.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-1470"></a><strong class="calibre9">Figure 13-70</strong> Multiple prime-factor nonrecursive CIC example: (a) cascaded-stage structure; (b) 2nd-order, <em class="calibre7">R</em> = 90, nonrecursive CIC example.</p>
<p class="image"><img src="images/000954.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">and so on, enabling nonrecursive implementations.</p>
<p class="calibre3">Due to space constraints, the elegant and arduous derivation of this technique is not given here; but this process can be illustrated with an example. Assume we desire a 2nd-order (<em class="calibre7">M</em> = 2) CIC filter with a decimation factor of <em class="calibre7">R</em> = 90. That decimation rate is factored as 90 = (2)(3)(3)(5), so <em class="calibre7">p</em> = 1, <em class="calibre7">q</em> = 2, and <em class="calibre7">r</em> = 1. Our composite CIC filter is implemented as <em class="calibre7">H</em><sub class="calibre12">2</sub>(<em class="calibre7">z</em>)<em class="calibre7">H</em><sub class="calibre12">3</sub>(<em class="calibre7">z</em>)<em class="calibre7">H</em><sub class="calibre12">3</sub>(<em class="calibre7">z</em>)<em class="calibre7">H</em><sub class="calibre12">5</sub>(<em class="calibre7">z</em>) shown in <a href="#calibre_link-1470">Figure 13-70(b)</a>.</p>
<p class="calibre3">At first glance the many additions of the <a href="#calibre_link-1470">Figure 13-70(b)</a> CIC filter appear to aggravate the power consumption of such a filter, but the reduced <a id="calibre_link-2031"></a>sample rates significantly reduce power requirements<a href="#calibre_link-1469">[70]</a>. If one addition in Section 1 of <a href="#calibre_link-1470">Figure 13-70(b)</a> consumes <em class="calibre7">P</em> units of power, then Section 1 consumes 2<em class="calibre7">P</em> units of power, and each addition in the first portion of Section 2 consumes <em class="calibre7">P</em>/2 units of power. Each addition in the second portion of Section 2 consumes <em class="calibre7">P</em>/6 of units power, while each addition in Section 3 consumes <em class="calibre7">P</em>/18 units of power.</p>
<p class="calibre3">We have flexibility here because the subfilters in each section of <a href="#calibre_link-1470">Figure 13-70(b)</a> can be implemented recursively or nonrecursively, as indicated in <a href="#calibre_link-1471">Eq. (13-122)</a>. In nonrecursive implementations the polyphase decomposition, transposed structures, simplified multiplication, and substructure sharing schemes can be applied. CIC filter design certainly has come a long way since its introduction in the early 1980s.</p>
<p class="calibre3"><a id="calibre_link-694"></a></p>
<h3 class="calibre6">13.25 Smoothing Impulsive Noise</h3>
<p class="calibre3">In practice we may be required to make precise measurements in the presence of high noise or interference. Without some sort of analog signal conditioning, or digital signal processing, it can be difficult to obtain stable and repeatable measurements. This impulsive-noise smoothing trick, originally developed to detect microampere changes in milliampere signals, describes a smoothing algorithm that improves the stability of precision measurements in the presence of impulsive noise<a href="#calibre_link-1472">[71]</a>.</p>
<p class="calibre3">Practical noise-reduction methods often involve multiple-sample averaging (<em class="calibre7">block averaging</em>) of a sequence of measured values, <em class="calibre7">x</em>(<em class="calibre7">n</em>), to compute a sequence of <em class="calibre7">N</em>-sample arithmetic means, <em class="calibre7">M</em>(<em class="calibre7">q</em>). As such, the block-averaged sequence <em class="calibre7">M</em>(<em class="calibre7">q</em>) is defined by</p>
<p class="caption"><a id="calibre_link-1474"></a>(13-123)</p>
<p class="image"><img src="images/001537.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where the time index of the averaging process is <em class="calibre7">q</em> = 0, 1, 2, 3, etc. When <em class="calibre7">N</em> = 10, for example, for the first block of data (<em class="calibre7">q</em> = 0), time samples <em class="calibre7">x</em>(0) through <em class="calibre7">x</em>(9) are averaged to compute <em class="calibre7">M</em>(0). For the second block of data (<em class="calibre7">q</em> = 1), time samples <em class="calibre7">x</em>(10) through <em class="calibre7">x</em>(19) are averaged to compute <em class="calibre7">M</em>(1), and so on<a href="#calibre_link-1473">[72]</a>.</p>
<p class="calibre3">The following impulsive-noise smoothing algorithm processes a block of time-domain samples, obtained through periodic sampling, and the number of samples, <em class="calibre7">N</em>, may be varied according to individual needs and processing resources. The processing of a single block of <em class="calibre7">N</em> time samples proceeds as follows: Collect <em class="calibre7">N</em>+2 samples of <em class="calibre7">x</em>(<em class="calibre7">n</em>), discard the maximum (most positive) and minimum (most negative) samples to obtain an <em class="calibre7">N</em>-sample block of data, and compute the arithmetic mean, <em class="calibre7">M</em>(<em class="calibre7">q</em>), of the <em class="calibre7">N</em> samples. Each sample in the <a id="calibre_link-2438"></a>block is then compared to the mean. The direction of each sample relative to the mean (greater than, or less than) is accumulated, as well as the cumulative magnitude of the deviation of the samples in one direction (which, by definition of the mean, equals that of the other direction). This data is used to compute a correction term that is added to the mean according to the following formula,</p>
<p class="caption"><a id="calibre_link-1475"></a>(13-124)</p>
<p class="image"><img src="images/000871.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where <em class="calibre7">A</em>(<em class="calibre7">q</em>) is the <em class="calibre7">corrected mean</em>, <em class="calibre7">M</em>(<em class="calibre7">q</em>) is the arithmetic mean (average) from <a href="#calibre_link-1474">Eq. (13-123)</a>, <em class="calibre7">P</em><sub class="calibre12">os</sub> is the number of samples greater than <em class="calibre7">M</em>(<em class="calibre7">q</em>), <em class="calibre7">N</em><sub class="calibre12">eg</sub> is the number of samples less than <em class="calibre7">M</em>(<em class="calibre7">q</em>), and <em class="calibre7">D</em><sub class="calibre12">total</sub> is the sum of deviations from the mean (absolute values and one direction only). <em class="calibre7">D</em><sub class="calibre12">total</sub>, then, is the sum of the differences between the <em class="calibre7">P</em><sub class="calibre12">os</sub> samples and <em class="calibre7">M</em>(<em class="calibre7">q</em>).</p>
<p class="calibre3">For an example, consider a system acquiring ten measured samples of 10, 10, 11, 9, 10, 10, 13, 10, 10, and 10. The mean is <em class="calibre7">M</em> = 10.3, the total number of samples positive is <em class="calibre7">P</em><sub class="calibre12">os</sub> = 2, and the total number of samples negative is <em class="calibre7">N</em><sub class="calibre12">eg</sub> = 8 (so <em class="calibre7">P</em><sub class="calibre12">os</sub>−<em class="calibre7">N</em><sub class="calibre12">eg</sub> = −6). The total deviation in either direction from the mean is 3.4 (using the eight samples less than the mean, (10.3−10) times 7 plus (10.3−9); or using the two samples greater than the mean, (13−10.3) plus (11−10.3)). With <em class="calibre7">D</em><sub class="calibre12">total</sub> = 3.4, <a href="#calibre_link-1475">Eq. (13-124)</a> yields an improved result of <em class="calibre7">A</em> = 10.096.</p>
<p class="calibre3">The smoothing algorithm’s performance, relative to traditional block averaging, can be illustrated by example. <a href="#calibre_link-1476">Figure 13-71(a)</a> shows a measured 300-sample <em class="calibre7">x</em>(<em class="calibre7">n</em>) signal sequence comprising a step signal of amplitude one <a id="calibre_link-2321"></a>contaminated with random noise (with a variance of 0.1) and two large impulsive-noise spike samples.</p>
<p class="caption"><a id="calibre_link-1476"></a><strong class="calibre9">Figure 13-71</strong> Noise smoothing for <em class="calibre7">N</em> = 10: (a) input <em class="calibre7">x</em>(<em class="calibre7">n</em>) signal; (b) block average output (white) and impulsive-noise smoothing algorithm output (solid).</p>
<p class="image"><img src="images/000006.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">A few meaningful issues regarding this noise smoothing process are:</p>
<p class="indenthangingb">• The block size (<em class="calibre7">N</em>) used in the smoothing algorithm can be any integer, but for real-time fixed binary-point implementations it’s beneficial to set <em class="calibre7">N</em> equal to an integer power of two. In that case the compute-intensive division operations in <a href="#calibre_link-1474">Eqs. (13-123)</a> and <a href="#calibre_link-1475">(13-124)</a> can be accomplished by binary arithmetic right shifts to reduce the computational workload.</p>
<p class="indenthangingb">• If there’s a possibility that more than two large noise spikes are contained in a block of input samples, then we collect more than <em class="calibre7">N</em>+2 samples of <em class="calibre7">x</em>(<em class="calibre7">n</em>) and discard the appropriate number of maximum and minimum samples to eliminate the large impulsive noise samples.</p>
<p class="indenthangingb">• We could forgo the <a href="#calibre_link-1475">Eq. (13-124)</a> processing and merely perform <a href="#calibre_link-1474">Eq. (13-123)</a> to compute the mean <em class="calibre7">M</em>(<em class="calibre7">q</em>). In that case, for a given <em class="calibre7">N</em>, the standard deviation of <em class="calibre7">M</em>(<em class="calibre7">q</em>) would be roughly 15 to 20 percent greater than <em class="calibre7">A</em>(<em class="calibre7">q</em>).</p>
<p class="calibre3">As pointed out by M. Givens, impulsive noise can also be reduced by a class of filters known as <em class="calibre7">median filters</em><a href="#calibre_link-1477">[73]</a>. Median filters, not covered in this text, are typically used in noise reduction of two-dimensional signals (images). However, median filters can also be implemented to process one-dimensional signals, such as our <em class="calibre7">x</em>(<em class="calibre7">n</em>) signal here, and should be considered in any impulsive-noise reduction application.</p>
<p class="calibre3"><a id="calibre_link-695"></a></p>
<h3 class="calibre6">13.26 Efficient Polynomial Evaluation</h3>
<p class="calibre3">On the off chance that you didn’t know, there are two popular tricks used to speed up polynomial evaluations (computations), known as <em class="calibre7">Horner’s Rule</em> and <em class="calibre7">Estrin’s Method.</em> We illustrate those two techniques below.</p>
<p class="calibre3"><a id="calibre_link-3330"></a></p>
<h4 class="calibre13">13.26.1 Floating-Point Horner’s Rule</h4>
<p class="calibre3">Horner’s Rule uses nested operations to reduce the number of multiply operations needed to compute polynomials. An example of a polynomial computation is, for example, using the following expression to compute the arctangent of <em class="calibre7">x</em>:</p>
<p class="caption"><a id="calibre_link-3331"></a>(13-125)</p>
<p class="image"><img src="images/001227.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">To see how the computational workload of polynomial evaluations can be reduced, consider the following <em class="calibre7">k</em>th-order polynomial:</p>
<p class="caption"><a id="calibre_link-2022"></a><a id="calibre_link-1481"></a>(13-126)</p>
<p class="image"><img src="images/000047.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">It can be rewritten as</p>
<p class="caption"><a id="calibre_link-3332"></a>(13-127)</p>
<p class="image"><img src="images/000659.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where the “H” subscript means Horner. Using this method to compute polynomials</p>
<p class="indenthangingb">• reduces the number of necessary multiply operations, and</p>
<p class="indenthangingb">• is straightforward to implement using programmable DSP chips with their <em class="calibre7">multiply and accumulate</em> (MAC) architectures.</p>
<p class="calibre3">For e<em class="calibre7">x</em>ample, consider the 5th-order polynomial</p>
<p class="caption"><a id="calibre_link-1478"></a>(13-128)</p>
<p class="image"><img src="images/000920.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Evaluated in the standard way, <a href="#calibre_link-1478">Eq. (13-128)</a> would require nine multiplies and five additions, whereas the Horner version</p>
<p class="caption"><a id="calibre_link-3333"></a>(13-128′)</p>
<p class="image"><img src="images/001783.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">requires only five multiplies and five adds when the computations begin with the innermost multiply and add operations (<em class="calibre7">c</em><sub class="calibre12">5</sub><em class="calibre7">x</em> + <em class="calibre7">c</em><sub class="calibre12">4</sub>).</p>
<p class="calibre3">Here are a few e<em class="calibre7">x</em>amples of polynomials in the Horner format:</p>
<p class="caption"><a id="calibre_link-3334"></a>(13-129)</p>
<p class="image"><img src="images/000807.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-3335"></a>(13-130)</p>
<p class="image"><img src="images/000687.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-3336"></a>(13-131)</p>
<p class="image"><img src="images/000806.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">By the way, the multiplications and additions cannot be performed in parallel. Because Horner’s Rule is inherently serial, we need the result of the last multiplication before we can start the next addition, and that addition result is needed before the follow-on multiplication.</p>
<p class="calibre3">Horner’s Rule is another of those handy computer techniques we use whose origins are very old. Chinese mathematicians described it in the 1200s. European mathematicians (including William Horner) rediscovered and publicized it in the early 1800s. However, it seems Sir Isaac Newton also invented and used it in the 1600s.</p>
<p class="calibre3"><a id="calibre_link-3337"></a></p>
<h4 class="calibre13">13.26.2 Horner’s Rule in Binary Shift Multiplication/Division</h4>
<p class="calibre3">The Horner’s Rule method of nested multiplications has special significance for us when we evaluate polynomials using fixed-point number formats. <a id="calibre_link-2174"></a>Using Horner’s Rule enables us to minimize the truncation quantization error when we use binary right shifts to implement fractional multiplications. For example, if we are using fractional fixed-point numbers in the 1.15 format, as described in <a href="#calibre_link-1479">Section 12.1.6</a>, and we want to multiply an <em class="calibre7">x</em>(<em class="calibre7">n</em>) sample by 0.3125, we can perform that multiplication as</p>
<p class="caption"><a id="calibre_link-1480"></a>(13-132)</p>
<p class="image"><img src="images/000573.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Those scaling factors on the right side of <a href="#calibre_link-1480">Eq. (13-132)</a> can be implemented using binary right shifts by two and four bits. The larger the right shifts, however, the greater the truncation quantization errors in this type of fractional multiplication. Using Horner’s Rule, we can implement <a href="#calibre_link-1480">Eq. (13-132)</a> as</p>
<p class="caption"><a id="calibre_link-3338"></a>(13-132′)</p>
<p class="image"><img src="images/000250.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where the maximum binary right shift is by two bits, reducing the resultant truncation quantization error.</p>
<p class="calibre3"><a id="calibre_link-3339"></a></p>
<h4 class="calibre13">13.26.3 Estrin’s Method</h4>
<p class="calibre3">If your computing hardware is able to perform multiple parallel (simultaneous) <em class="calibre7">multiply and accumulate</em> (MAC) operations, we can increase the computational speed of Horner’s Rule by using parallel processing in a technique called <em class="calibre7">Estrin’s Method.</em></p>
<p class="calibre3">Here’s how Estrin’s Method works: Various <em class="calibre7">k</em>th-order polynomials, such as that in <a href="#calibre_link-1481">Eq. (13-126)</a>, can be evaluated using</p>
<p class="image"><img src="images/000252.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The above expressions look complicated, but they’re really not. The terms inside parentheses, brackets, and curly brackets are nested sub-expressions of the form <em class="calibre7">ax<sup class="calibre10">q</sup></em> + <em class="calibre7">b</em>&mdash;precisely what we need for MAC operations. For example, the sub-expressions within parentheses can be computed simultaneously with a DSP processor’s parallel MAC operations.</p>
<p class="calibre3">To illustrate Estrin’s Method, if your processing hardware can perform four simultaneous MAC operations, and assuming value <em class="calibre7">x</em><sup class="calibre10">2</sup> has been previously <a id="calibre_link-2252"></a>computed, we can evaluate polynomial <em class="calibre7">f</em><sub class="calibre12">7</sub>(<em class="calibre7">x</em>) in the following three steps:</p>
<p class="indenthangingn1"><strong class="calibre9">1.</strong> <em class="calibre7">U</em> = (<em class="calibre7">c</em><sub class="calibre12">7</sub><em class="calibre7">x</em> +<em class="calibre7">c</em><sub class="calibre12">6</sub>), <em class="calibre7">V</em> = (<em class="calibre7">c</em><sub class="calibre12">5</sub><em class="calibre7">x</em> +<em class="calibre7">c</em><sub class="calibre12">4</sub>), <em class="calibre7">W</em> = (<em class="calibre7">c</em><sub class="calibre12">3</sub><em class="calibre7">x</em> +<em class="calibre7">c</em><sub class="calibre12">2</sub>), and <em class="calibre7">X</em> = (<em class="calibre7">c</em><sub class="calibre12">1</sub><em class="calibre7">x</em> +<em class="calibre7">c</em><sub class="calibre12">0</sub>)</p>
<p class="indenthangingn1"><strong class="calibre9">2.</strong> <em class="calibre7">Y</em> = (<em class="calibre7">Ux</em><sup class="calibre10">2</sup> +<em class="calibre7">V</em>), <em class="calibre7">Z</em> = (<em class="calibre7">Wx</em><sup class="calibre10">2</sup> +<em class="calibre7">X</em>), <em class="calibre7">x</em><sup class="calibre10">4</sup> = (<em class="calibre7">x</em><sup class="calibre10">2</sup><em class="calibre7">x</em><sup class="calibre10">2</sup> +0)</p>
<p class="indenthangingn1"><strong class="calibre9">3.</strong> <em class="calibre7">f</em><sub class="calibre12">7</sub>(<em class="calibre7">x</em>) = (<em class="calibre7">Yx</em><sup class="calibre10">4</sup> +<em class="calibre7">Z</em>)</p>
<p class="calibre3">The four computations in Step 1 are performed simultaneously. Likewise, the three computations in Step 2 are performed simultaneously. The final Step 3 is a single MAC operation.</p>
<p class="calibre3">Yes, Estrin’s Method requires multiple processing steps, but this method is able to avoid much of the inherent (slow) serial processing dictated by Horner’s Rule. The bottom line here is that while Estrin’s Method does not reduce the computational workload (number of multiplies and additions) of Horner’s Rule, it does increase the computational speed of polynomial evaluations by taking advantage of modern-day parallel processing hardware architectures.</p>
<p class="calibre3"><a id="calibre_link-696"></a></p>
<h3 class="calibre6">13.27 Designing Very High-Order FIR Filters</h3>
<p class="calibre3">There are linear-phase filtering applications wherein we’re interested in designing very high-performance (very narrow passband widths, and/or very high attenuation) nonrecursive FIR filters. Consider the possibility that you’ve used <a href="#calibre_link-1482">Eq. (7-34)</a>, or some other algorithm, to determine that you need to implement a 2000-tap linear-phase FIR filter. Then when you try to design such a filter using your trusty Parks-McClellan Exchange-based (Remez) filter design software, you obtain unusable design results. It happens that some software incarnations of the Parks-McClellan Exchange algorithm have convergence problems (inaccurate results) when the number of filter taps, or filter order, exceeds 400 to 500. There’s a slick way around this high-order FIR filter design problem using a frequency-domain zero-stuffing technique.<sup class="calibre10"><a id="calibre_link-1484"></a><a href="#calibre_link-1483">†</a></sup></p>
<p class="footnotes"><a id="calibre_link-1483"></a><sup class="calibre11"><a href="#calibre_link-1484">†</a></sup> I thank my DSP pal Eric Jacobsen, Minister of Algorithms at Abineau Communications, for publicizing this technique.</p>
<p class="calibre3">If our FIR filter design software cannot generate FIR coefficient sets whose lengths are in the thousands, then we can design a shorter-length set of coefficients and interpolate those coefficients (time-domain impulse response) to whatever length we desire. Rather than use time-domain interpolation schemes and account for their inaccuracies, we can simplify the process by performing time-domain interpolation by means of frequency-domain zero stuffing.</p>
<p class="calibre3"><a id="calibre_link-3340"></a>An example of the process is as follows: Assume that we have a signal sampled at a rate of <em class="calibre7">f<sub class="calibre12">s</sub></em> = 1000 Hz. We want a lowpass filter whose cutoff frequency is 20 Hz with 60 dB of stopband attenuation. Compounding the problem are the requirements for linear phase and removal of any DC (zero Hz) component from the signal. (Those last two requirements preclude using the DC-removal schemes in <a href="#calibre_link-693">Section 13.23</a>.) First, we design a prototype nonrecursive FIR filter having, say, <em class="calibre7">N</em> = 168 coefficients whose desired frequency response magnitude is shown in <a href="#calibre_link-1485">Figure 13-72(a)</a>; its <em class="calibre7">h</em><sub class="calibre12">p</sub>(<em class="calibre7">k</em>) coefficients are depicted in <a href="#calibre_link-1485">Figure 13-72(b)</a>. Next, we compute a 168-point DFT of the coefficients to obtain the frequency-domain samples <em class="calibre7">H</em><sub class="calibre12">p</sub>(<em class="calibre7">m</em>) whose magnitudes are shown in <a href="#calibre_link-1485">Figure 13-72(c)</a>.</p>
<p class="caption"><a id="calibre_link-1485"></a><strong class="calibre9">Figure 13-72</strong> Prototype FIR filter: (a) magnitude response; (b) <em class="calibre7">h</em><sub class="calibre12">p</sub>(<em class="calibre7">k</em>) coefficients; (c) |<em class="calibre7">H</em><sub class="calibre12">p</sub>(<em class="calibre7">m</em>)| magnitudes of the 168-point DFT of <em class="calibre7">h</em><sub class="calibre12">p</sub>(<em class="calibre7">k</em>).</p>
<p class="image"><img src="images/000845.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Under the assumption that our final desired filter requires roughly 1600 taps, we’ll interpolate the <em class="calibre7">h</em><sub class="calibre12">p</sub>(<em class="calibre7">k</em>) prototype impulse response by a factor of <em class="calibre7">M</em> = 10. We perform the interpolation by inserting (<em class="calibre7">M</em>−1)<em class="calibre7">N</em> zeros in the center of the <em class="calibre7">H</em><sub class="calibre12">p</sub>(<em class="calibre7">m</em>) frequency-domain samples, yielding a 1680-point <em class="calibre7">H</em>(<em class="calibre7">m</em>) frequency-domain sequence whose magnitudes are shown in <a href="#calibre_link-1486">Figure 13-73(a)</a>. Finally, we perform a 1680-point inverse DFT on <em class="calibre7">H</em>(<em class="calibre7">m</em>) to obtain <a id="calibre_link-3341"></a>the interpolated <em class="calibre7">h</em>(<em class="calibre7">k</em>) impulse response (coefficients), shown in <a href="#calibre_link-1486">Figure 13-73(b)</a>, for our desired filter. (The ten-fold compression of the <em class="calibre7">H</em><sub class="calibre12">p</sub>(<em class="calibre7">m</em>) passband samples results in a ten-fold expansion of the <em class="calibre7">h</em><sub class="calibre12">p</sub>(<em class="calibre7">k</em>) impulse response samples.) The frequency magnitude response of our final very high-order FIR filter, over the frequency range of −30 to 30 Hz, is provided in <a href="#calibre_link-1486">Figure 13-73(c)</a>.</p>
<p class="caption"><a id="calibre_link-1486"></a><strong class="calibre9">Figure 13-73</strong> Desired FIR filter: (a) magnitude of zero-stuffed <em class="calibre7">H</em><sub class="calibre12">p</sub>(<em class="calibre7">m</em>); (b) interpolated <em class="calibre7">h</em>(<em class="calibre7">k</em>) coefficients; (c) magnitude of desired frequency response.</p>
<p class="image"><img src="images/001706.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">With this process, the prototype filter’s <em class="calibre7">h</em><sub class="calibre12">p</sub>(<em class="calibre7">k</em>) coefficients are preserved within the interpolated filter’s coefficients if the <em class="calibre7">H</em><sub class="calibre12">p</sub>(<em class="calibre7">N</em>/2) sample (<em class="calibre7">f<sub class="calibre12">s</sub></em>/2) is zero. That condition ensures that <em class="calibre7">H</em>(<em class="calibre7">m</em>) exhibits conjugate symmetry and forces the <em class="calibre7">h</em>(<em class="calibre7">k</em>) coefficients to be real-only.</p>
<p class="calibre3">The design steps for this high-order filter design scheme are:</p>
<p class="indenthangingb">• With the desired filter requiring <em class="calibre7">MN</em> taps, set the number of prototype filter coefficients, <em class="calibre7">N</em>, to an integer value small enough so your FIR filter design software provides usable results. The integer interpolation factor <em class="calibre7">M</em> equals the number of desired taps divided by <em class="calibre7">N</em>.</p>
<p class="indenthangingb"><a id="calibre_link-2179"></a>• Design the <em class="calibre7">N</em>-tap prototype FIR filter accounting for the <em class="calibre7">M</em>-fold frequency compression in the final filter. (That is, cutoff frequencies for the prototype filter are <em class="calibre7">M</em> times the desired final cutoff frequencies.)</p>
<p class="indenthangingb">• Perform an <em class="calibre7">N</em>-point DFT on the prototype filter’s <em class="calibre7">h</em><sub class="calibre12">p</sub>(<em class="calibre7">k</em>) coefficients to obtain <em class="calibre7">H</em><sub class="calibre12">p</sub>(<em class="calibre7">m</em>).</p>
<p class="indenthangingb">• Insert <em class="calibre7">M</em>−1 zero-valued samples just before the <em class="calibre7">H</em><sub class="calibre12">p</sub>(<em class="calibre7">N</em>/2) sample of <em class="calibre7">H</em><sub class="calibre12">p</sub>(<em class="calibre7">m</em>) to obtain the new <em class="calibre7">MN</em>-point <em class="calibre7">H</em>(<em class="calibre7">m</em>) frequency response.</p>
<p class="indenthangingb">• Compute the <em class="calibre7">MN</em>-point inverse DFT of <em class="calibre7">H</em>(<em class="calibre7">m</em>), yielding an <em class="calibre7">MN</em>-length interpolated <em class="calibre7">h</em>(<em class="calibre7">k</em>) coefficient set. (Due to computational errors, discard the imaginary part of <em class="calibre7">h</em>(<em class="calibre7">k</em>), making it real-only.)</p>
<p class="indenthangingb">• Multiply <em class="calibre7">h</em>(<em class="calibre7">k</em>) by <em class="calibre7">M</em> to compensate for the 1/<em class="calibre7">M</em> amplitude loss induced by interpolation.</p>
<p class="indenthangingb">• Test the <em class="calibre7">h</em>(<em class="calibre7">k</em>) coefficient set to determine its actual frequency response using standard filter analysis methods. (One method: append thousands of zeros to <em class="calibre7">h</em>(<em class="calibre7">k</em>) and perform a very large FFT on the expanded sequence.)</p>
<p class="calibre3">An example application of this filter design is when you’re building a high-performance lowpass polyphase filter, as discussed in <a href="#calibre_link-291">Chapter 10</a>. (The structures of the high-performance <em class="calibre7">interpolated FIR</em> and <em class="calibre7">frequency sampling</em> lowpass filters don’t permit their decomposition into polyphase subfilters for such an application.)</p>
<p class="calibre3"><a id="calibre_link-697"></a></p>
<h3 class="calibre6">13.28 Time-Domain Interpolation Using the FFT</h3>
<p class="calibre3">The thoughtful reader may have looked at the above <a href="#calibre_link-696">Section 13.27</a> FIR filter impulse response interpolation scheme and wondered, “If we can interpolate time-domain impulse responses, we should be able to interpolate time-domain signals using the same frequency-domain zero-stuffing method.” To quote Rocky Balboa, “This is very true.” In fact, the <a href="#calibre_link-696">Section 13.27</a> interpolation-by-<em class="calibre7">M</em> process applied to time signals is sometimes called <em class="calibre7">exact interpolation</em> because its performance is equivalent to using an <em class="calibre7">ideal</em>, infinite-stopband attenuation, time-domain interpolation filter. Let’s see how this interpolation scheme works.</p>
<p class="calibre3">To establish our notation, let’s say we compute the FFT of an <em class="calibre7">N</em>-point <em class="calibre7">x</em>(<em class="calibre7">n</em>) time sequence to produce its <em class="calibre7">X</em>(<em class="calibre7">m</em>) frequency-domain samples. Next we stuff (<em class="calibre7">M</em>-1)<em class="calibre7">N</em> zeros in the middle of <em class="calibre7">X</em>(<em class="calibre7">m</em>) to yield the <em class="calibre7">MN</em>-length <em class="calibre7">X</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>) frequency samples, where <em class="calibre7">MN</em> is an integer power of two. Then we perform an <em class="calibre7">MN</em>-point inverse FFT on <em class="calibre7">X</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>) to obtain the interpolated-by-<em class="calibre7">M x</em><sub class="calibre12">int</sub>(<em class="calibre7">n</em>) times samples. Using this frequency-domain zero stuffing to implement time-domain signal interpolation involves two important issues upon which we now focus.</p>
<p class="calibre3"><a id="calibre_link-3342"></a></p>
<h4 class="calibre13"><a id="calibre_link-2186"></a>13.28.1 Computing Interpolated Real Signals</h4>
<p class="calibre3">The first issue: to ensure the interpolated <em class="calibre7">x</em><sub class="calibre12">int</sub>(<em class="calibre7">n</em>) time sequence is real-only, conjugate symmetry must be maintained in the zero-stuffed <em class="calibre7">X</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>) frequency samples. If the <em class="calibre7">X</em>(<em class="calibre7">m</em>) sequence has a nonzero sample at <em class="calibre7">X</em><sub class="calibre12">int</sub>(<em class="calibre7">N</em>/2), the <em class="calibre7">f<sub class="calibre12">s</sub></em>/2 frequency component, we must use the following steps in computing <em class="calibre7">X</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>) to guarantee conjugate symmetry:</p>
<p class="indenthangingb">• Perform an <em class="calibre7">N</em>-point FFT on an <em class="calibre7">N</em>-point <em class="calibre7">x</em>(<em class="calibre7">n</em>) time sequence, yielding <em class="calibre7">N</em> frequency samples, <em class="calibre7">X</em>(<em class="calibre7">m</em>).</p>
<p class="indenthangingb">• Create an <em class="calibre7">MN</em>-point spectral sequence <em class="calibre7">X</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>) initially set to all zeros.</p>
<p class="indenthangingb">• Assign <em class="calibre7">X</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>) = <em class="calibre7">X</em>(<em class="calibre7">m</em>), for 0 ≤ <em class="calibre7">m</em> ≤ (<em class="calibre7">N</em>/2)−1.</p>
<p class="indenthangingb">• Assign both <em class="calibre7">X</em><sub class="calibre12">int</sub>(<em class="calibre7">N</em>/2) and <em class="calibre7">X</em><sub class="calibre12">int</sub>(<em class="calibre7">MN−N</em>/2) equal to <em class="calibre7">X</em>(<em class="calibre7">N</em>/2)/2. (This step, to maintain conjugate symmetry and improve interpolation accuracy, is not so well known<a href="#calibre_link-1487">[74]</a>.)</p>
<p class="indenthangingb">• Assign <em class="calibre7">X</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>) = <em class="calibre7">X</em>(<em class="calibre7">q</em>), where <em class="calibre7">MN</em>−(<em class="calibre7">N</em>/2)+1 ≤ <em class="calibre7">m</em> ≤ <em class="calibre7">MN</em>−1, and (<em class="calibre7">N</em>/2)+1 ≤ <em class="calibre7">q</em> ≤ <em class="calibre7">N</em>−1.</p>
<p class="indenthangingb">• Compute the real part of the <em class="calibre7">MN</em>-point inverse FFT of <em class="calibre7">X</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>), yielding the desired <em class="calibre7">MN</em>-length interpolated <em class="calibre7">x</em><sub class="calibre12">int</sub>(<em class="calibre7">n</em>) sequence.</p>
<p class="indenthangingb">• Finally, if desired, multiply <em class="calibre7">x</em><sub class="calibre12">int</sub>(<em class="calibre7">n</em>) by <em class="calibre7">M</em> to compensate for the 1/<em class="calibre7">M</em> amplitude loss induced by interpolation.</p>
<p class="calibre3">Whew! Our mathematical notation makes this signal interpolation scheme look complicated, but it’s really not so bad. <a href="#calibre_link-1488">Table 13-8</a> shows the frequency-domain <em class="calibre7">X</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>) sample assignments, where 0 ≤ <em class="calibre7">m</em> ≤ 15, to interpolate an <em class="calibre7">N</em> = 8-point <em class="calibre7">x</em>(<em class="calibre7">n</em>) sequence by a factor of <em class="calibre7">M</em> = 2.</p>
<p class="caption"><a id="calibre_link-1488"></a><strong class="calibre9">Table 13-8</strong> <em class="calibre7">X</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>) Assignments for Interpolation by Two</p>
<p class="image"><img src="images/001358.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3343"></a>One of the nice properties of the above algorithm is that every <em class="calibre7">M</em>th <em class="calibre7">x</em><sub class="calibre12">int</sub>(<em class="calibre7">n</em>) sample coincides with the original <em class="calibre7">x</em>(<em class="calibre7">n</em>) samples. In practice, due to our finite-precision computing, the imaginary parts of our final <em class="calibre7">x</em><sub class="calibre12">int</sub>(<em class="calibre7">n</em>) may have small nonzero values. As such, we take <em class="calibre7">x</em><sub class="calibre12">int</sub>(<em class="calibre7">n</em>) to be the real part of the inverse FFT of <em class="calibre7">X</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>).</p>
<p class="calibre3">Here’s the second issue regarding time-domain real signal interpolation. This technique of interpolation using FFT zero stuffing only provides acceptable results when the original <em class="calibre7">x</em>(<em class="calibre7">n</em>) time sequence has a spectrum having negligible spectral energy in the vicinity of ±<em class="calibre7">f<sub class="calibre12">s</sub></em>/2, as shown in <a href="#calibre_link-1489">Figure 13-74</a> for lowpass and bandpass signals. By negligible we mean spectral magnitudes that are, say, below a discrete signal’s quantization noise background spectral level.</p>
<p class="caption"><a id="calibre_link-1489"></a><strong class="calibre9">Figure 13-74</strong> Spectral restrictions for interpolation using the FFT: (a) lowpass signal case; (b) bandpass signal case.</p>
<p class="image"><img src="images/000724.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">An example of violating the above spectral restriction is when <em class="calibre7">x</em>(<em class="calibre7">n</em>) is a sinusoidal sequence containing a noninteger number of cycles. That signal’s positive-frequency spectrum will have nonzero spectral energy extending from zero Hz to <em class="calibre7">f<sub class="calibre12">s</sub></em>/2 Hz caused by spectral leakage. Trying to interpolate such an <em class="calibre7">x</em>(<em class="calibre7">n</em>) using this FFT zero-stuffing scheme will yield an interpolated time sequence with unacceptably high amplitude errors at the beginning and end of the interpolated sequence.</p>
<p class="calibre3">With the advent of fast hardware DSP chips and pipelined FFT techniques, the above time-domain interpolation algorithm may be viable for a number of applications, such as computing selectable sample rate time sequences of a test signal that has a fixed spectral envelope shape; providing interpolation, by selectable factors, of signals that were filtered in the frequency domain using the fast convolution method (<a href="#calibre_link-524">Section 13.10</a>); or digital image resampling. One scenario to consider is using the efficient 2<em class="calibre7">N</em>-Point Real FFT technique, described in <a href="#calibre_link-332">Section 13.5.2</a>, to compute the forward FFT of the real-valued <em class="calibre7">x</em>(<em class="calibre7">n</em>). Of course, the prudent engineer would conduct a literature search to see what algorithms are available for efficiently performing inverse FFTs when many of the frequency-domain samples are zeros.</p>
<p class="calibre3"><a id="calibre_link-334"></a></p>
<h4 class="calibre13"><a id="calibre_link-2185"></a>13.28.2 Computing Interpolated Analytic Signals</h4>
<p class="calibre3">We can use the frequency-domain zero-stuffing scheme to generate an interpolated-by-<em class="calibre7">M</em> analytic (complex-valued) time signal based upon the real <em class="calibre7">N</em>-point time sequence <em class="calibre7">x</em>(<em class="calibre7">n</em>), if <em class="calibre7">N</em> is even<a href="#calibre_link-1490">[75]</a>. The process is as follows:</p>
<p class="indenthangingb">• Perform an <em class="calibre7">N</em>-point FFT on an <em class="calibre7">N</em>-point real <em class="calibre7">x</em><sub class="calibre12">r</sub>(<em class="calibre7">n</em>) time sequence, yielding <em class="calibre7">N</em> frequency samples, <em class="calibre7">X</em><sub class="calibre12">r</sub>(<em class="calibre7">m</em>).</p>
<p class="indenthangingb">• Create an <em class="calibre7">MN</em>-point spectral sequence <em class="calibre7">X</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>) initially set to all zeros, where <em class="calibre7">MN</em> is an integer power of two.</p>
<p class="indenthangingb">• Assign <em class="calibre7">X</em><sub class="calibre12">int</sub>(0) = <em class="calibre7">X</em><sub class="calibre12">r</sub>(0), and <em class="calibre7">X</em><sub class="calibre12">int</sub>(<em class="calibre7">N</em>/2) = <em class="calibre7">X</em><sub class="calibre12">r</sub>(<em class="calibre7">N</em>/2).</p>
<p class="indenthangingb">• Assign <em class="calibre7">X</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>) = 2<em class="calibre7">X</em><sub class="calibre12">r</sub>(<em class="calibre7">m</em>), for 1 ≤ <em class="calibre7">m</em> ≤ = (<em class="calibre7">N</em>/2)−1.</p>
<p class="indenthangingb">• Compute the <em class="calibre7">MN</em>-point inverse FFT of <em class="calibre7">X</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>), yielding the desired <em class="calibre7">MN</em>-length interpolated analytic (complex) <em class="calibre7">x</em><sub class="calibre12">c,int</sub>(<em class="calibre7">n</em>) sequence.</p>
<p class="indenthangingb">• Finally, if desired, multiply <em class="calibre7">x</em><sub class="calibre12">c,int</sub>(<em class="calibre7">n</em>) by <em class="calibre7">M</em> to compensate for the 1/<em class="calibre7">M</em> amplitude loss induced by interpolation.</p>
<p class="calibre3">To minimize the interpolation error in the complex <em class="calibre7">x</em><sub class="calibre12">c,int</sub>(<em class="calibre7">n</em>) sequence, the original <em class="calibre7">x</em><sub class="calibre12">r</sub>(<em class="calibre7">n</em>) sequence must have negligible spectral energy in the vicinity of ±<em class="calibre7">f<sub class="calibre12">s</sub></em>/2, as described earlier for real-valued interpolation.</p>
<p class="calibre3"><a id="calibre_link-698"></a></p>
<h3 class="calibre6">13.29 Frequency Translation Using Decimation</h3>
<p class="calibre3">In this section we show tricks for implementing multiplierless frequency translation of both real and complex signals using simple decimation.</p>
<p class="calibre3"><a id="calibre_link-3344"></a></p>
<h4 class="calibre13">13.29.1 Translation of Real Signals Using Decimation</h4>
<p class="calibre3">We can frequency translate a real bandpass signal toward zero Hz, converting it to a lowpass signal, without the need for mixing multipliers. We do this by performing decimation by an integer factor <em class="calibre7">D</em> as shown in <a href="#calibre_link-1491">Figure 13-75(a)</a>. If the bandpass filter provides an output signal of bandwidth <em class="calibre7">B</em> Hz, located as shown in <a href="#calibre_link-1491">Figures 13-75(b)</a> and <a href="#calibre_link-1491">13-75(d)</a> where <em class="calibre7">k</em> is a positive integer, decimation by <em class="calibre7">D</em> will yield lowpass signals whose spectra are shown in <a href="#calibre_link-1491">Figures 13-75(c)</a> and <a href="#calibre_link-1491">13-75(e)</a>, depending on whether integer <em class="calibre7">k</em> is odd or even. Take care to notice the inverted spectra in <a href="#calibre_link-1491">Figure 13-75(e)</a>. To avoid decimated-output aliasing errors, we must satisfy the Nyquist criterion and ensure that <em class="calibre7">x</em><sub class="calibre12">BP</sub>(<em class="calibre7">n</em>)’s bandwidth <em class="calibre7">B</em> is not greater than <em class="calibre7">f<sub class="calibre12">s</sub></em>/(2<em class="calibre7">D</em>).</p>
<p class="caption"><a id="calibre_link-1491"></a><strong class="calibre9">Figure 13-75</strong> Real and complex bandpass signal translation using decimation by <em class="calibre7">D</em>.</p>
<p class="image"><img src="images/001580.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3345"></a></p>
<h4 class="calibre13">13.29.2 Translation of Complex Signals Using Decimation</h4>
<p class="calibre3">It’s possible to frequency translate a complex bandpass signal, without the need for mixing multipliers, so that a spectral replication is centered at zero <a id="calibre_link-2068"></a>Hz. The process we’re describing here is called <em class="calibre7">complex down-conversion</em>. The left side of <a href="#calibre_link-1491">Figure 13-75(f)</a> shows the spectrum of a complex baseband signal whose |<em class="calibre7">X</em><sub class="calibre12">CB</sub>(<em class="calibre7">m</em>)| spectral magnitude contains only positive-frequency spectral components.</p>
<p class="calibre3">If we individually decimate the real and imaginary parts of the complex time sequence <em class="calibre7">x</em><sub class="calibre12">CB</sub>(<em class="calibre7">n</em>), whose spectrum is <em class="calibre7">X</em><sub class="calibre12">CB</sub>(<em class="calibre7">m</em>), by <em class="calibre7">D,</em> the resulting complex <a id="calibre_link-1960"></a>sequence will have a spectral image centered exactly at zero Hz as shown by |<em class="calibre7">X</em>′<sub class="calibre12">CB</sub>(<em class="calibre7">m</em>)| in <a href="#calibre_link-1491">Figure 13-75(f)</a>. The key stipulation here, as you may have guessed, is that the original pre-decimated |<em class="calibre7">X</em><sub class="calibre12">CB</sub>(<em class="calibre7">m</em>)| spectral energy must be centered at an integer multiple of <em class="calibre7">f<sub class="calibre12">s</sub></em>/<em class="calibre7">D</em>.</p>
<p class="calibre3"><a id="calibre_link-699"></a></p>
<h3 class="calibre6">13.30 Automatic Gain Control (AGC)</h3>
<p class="calibre3">Since the early days of vacuum tube radios, circuits were needed to automatically adjust a receiver’s gain, as an input signal varied in amplitude, to maintain a (relatively) constant output signal level. These feedback mechanisms, called <em class="calibre7">automatic gain control</em> (AGC) circuits, are an important component of modern analog and digital communications receivers. <a href="#calibre_link-1492">Figure 13-76(a)</a> illustrates a simple digital AGC process[<a href="#calibre_link-1493">76</a>,<a href="#calibre_link-1494">77</a>]. Its operation is straightforward: The output signal power is sampled and compared to a reference level <em class="calibre7">R</em> (the <a id="calibre_link-2119"></a>desired output amplitude rms level). If the output signal level is too high (low), a negative (positive) signal is fed back, reducing (increasing) the gain. The control parameter α regulates the amplitude of the feedback signal and is used to control the AGC’s time constant (how rapidly gain changes take effect).</p>
<p class="caption"><a id="calibre_link-1492"></a><strong class="calibre9">Figure 13-76</strong> AGC process: (a) linear AGC circuit; (b) example input <em class="calibre7">x</em>(<em class="calibre7">n</em>) with amplitude fluctuations; (c) <em class="calibre7">y</em>(<em class="calibre7">n</em>) output for α = 0.01 and <em class="calibre7">R</em> = 1.</p>
<p class="image"><img src="images/000608.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Given an input signal <em class="calibre7">x</em>(<em class="calibre7">n</em>) in <a href="#calibre_link-1492">Figure 13-76(b)</a> whose amplitude envelope is fluctuating, the AGC structure provides the relatively constant amplitude <em class="calibre7">y</em>(<em class="calibre7">n</em>) output shown in <a href="#calibre_link-1492">Figure 13-76(c)</a>.</p>
<p class="calibre3">We called <a href="#calibre_link-1492">Figure 13-76(a)</a> a “simple AGC process,” but AGC is not all that simple. The process is a nonlinear, time-varying, signal-dependent feedback system. As such, it’s highly resistant to normal time-domain or <em class="calibre7">z</em>-domain analysis. This is why AGC analysis is empirical rather than mathematical and explains why there’s so little discussion of AGC in the DSP literature.</p>
<p class="calibre3">Depending on the nature of <em class="calibre7">x</em>(<em class="calibre7">n</em>), the feedback signal may fluctuate rapidly and the feedback loop will attempt to adjust the system gain too often. This will cause a mild AM modulation effect, inducing low-level harmonics in the <em class="calibre7">y</em>(<em class="calibre7">n</em>) output. That problem can be minimized by inserting a simple lowpass filter in the feedback loop just before, or just after, the <em class="calibre7">R</em> adder. But such filtering does not remedy the circuit’s main drawback. The time constant (attack time) of this AGC scheme is input signal level dependent and is different depending on whether the <em class="calibre7">x</em>(<em class="calibre7">n</em>) is increasing or decreasing. These properties drastically reduce our desired control over the system’s time constant. To solve this problem, we follow the lead of venerable radio AGC designs and enter the logarithmic domain.</p>
<p class="calibre3">We can obtain complete control of the AGC’s time constant, and increase our AGC’s dynamic range, by using logarithms as shown in <a href="#calibre_link-1495">Figure 13-77(a)</a>. As is typical in practice, this log AGC process has a lowpass filter (LPF) to eliminate too-rapid gain changes<a href="#calibre_link-1496">[78]</a>. That filter can be a simple moving average filter, a cascaded integrator-comb (CIC) filter, or a more traditional lowpass filter having a sin(<em class="calibre7">x</em>)/<em class="calibre7">x</em> impulse response.</p>
<p class="caption"><a id="calibre_link-1495"></a><strong class="calibre9">Figure 13-77</strong> AGC process: (a) logarithmic AGC circuit; (b) <em class="calibre7">y</em>(<em class="calibre7">n</em>) output for α = 0.01 and <em class="calibre7">R</em> = 1.</p>
<p class="image"><img src="images/001466.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">For the logarithmic AGC scheme, the feedback loop’s time constant is dependent solely on α and independent of the input signal level, as can be seen in <a href="#calibre_link-1495">Figure 13-77(b)</a> when the <em class="calibre7">x</em>(<em class="calibre7">n</em>) input is that in <a href="#calibre_link-1492">Figure 13-76(b)</a>. The Log and Antilog operations can be implemented as log<sub class="calibre12">2</sub>(<em class="calibre7">x</em>) and 2<em class="calibre7"><sup class="calibre10">x</sup></em>, respectively.</p>
<p class="calibre3"><a id="calibre_link-700"></a></p>
<h3 class="calibre6">13.31 Approximate Envelope Detection</h3>
<p class="calibre3">In this section, we present a crude (but simple to implement) complex signal envelope detection scheme. By “envelope detection” we mean estimating the instantaneous magnitude of a complex signal <em class="calibre7">x</em><sub class="calibre12">c</sub>(<em class="calibre7">n</em>). The process is straightforward: we sum the absolute values of a complex signal’s real and imaginary parts and apply that sum to a simple 1st-order lowpass IIR filter to obtain an envelope signal <em class="calibre7">E</em>(<em class="calibre7">n</em>) as shown in <a href="#calibre_link-1497">Figure 13-78(a)</a>. The filter’s feedback coefficient <a id="calibre_link-3346"></a>α is in the range of 0 to 1. (That lowpass filter is our exponential averager discussed in <a href="#calibre_link-668">Section 11.6</a>, which some DSP folks call a <em class="calibre7">leaky integrator</em>.) The <em class="calibre7">E</em>(<em class="calibre7">n</em>) sequence is proportional to the desired instantaneous magnitude of <em class="calibre7">x</em><sub class="calibre12">c</sub>(<em class="calibre7">n</em>), or</p>
<p class="caption"><a id="calibre_link-1499"></a>(13-133)</p>
<p class="image"><img src="images/000471.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-1497"></a><strong class="calibre9">Figure 13-78</strong> Envelope detection: (a) block diagram; (b) |<em class="calibre7">x</em><sub class="calibre12">r</sub>(<em class="calibre7">n</em>)|+|<em class="calibre7">x</em><sub class="calibre12">i</sub>(<em class="calibre7">n</em>)| adder output, and <em class="calibre7">E</em>(<em class="calibre7">n</em>) for α = 0.4; (c) <em class="calibre7">E</em>(<em class="calibre7">n</em>) for α = 0.2 and α = 0.05.</p>
<p class="image"><img src="images/000505.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">To gauge the envelope detector’s performance, consider a sampled version of an amplitude-modulated sinusoid such as the <em class="calibre7">x</em><sub class="calibre12">r</sub>(<em class="calibre7">n</em>) in <a href="#calibre_link-311">Figure 9-7(a)</a> from which a sampled analytic (complex) <em class="calibre7">x</em><sub class="calibre12">c</sub>(<em class="calibre7">n</em>) can be generated. If <em class="calibre7">x</em><sub class="calibre12">c</sub>(<em class="calibre7">n</em>) is applied to our envelope detection process, the processing results are shown in <a href="#calibre_link-1497">Figures 13-78(b)</a> and <a href="#calibre_link-1497">13-78(c)</a>, where the solid curves represent <em class="calibre7">E</em>(<em class="calibre7">n</em>) and the dashed curves are the true magnitude of <em class="calibre7">x</em><sub class="calibre12">c</sub>(<em class="calibre7">n</em>). Notice how the amount of smoothing of the <em class="calibre7">E</em>(<em class="calibre7">n</em>) fluctuations depends on the value of α.</p>
<p class="calibre3">If the scaling coefficient α/2 can take the form</p>
<p class="caption"><a id="calibre_link-1498"></a>(13-133′)</p>
<p class="image"><img src="images/001330.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where <em class="calibre7">K</em> is a positive integer, then we can eliminate the multipliers in <a href="#calibre_link-1497">Figure 13-78(a)</a>. If we satisfy <a href="#calibre_link-1498">Eq. (13-133′)</a>, the multiply by α/2 can be replaced by two binary right shifts and a subtract operation, and the multiply by (1−α) can be replaced by a single binary right-shift operation. This situation gives us a multiplierless envelope detector.</p>
<p class="calibre3"><a id="calibre_link-2395"></a>Sequence <em class="calibre7">x</em><sub class="calibre12">r</sub>(<em class="calibre7">n</em>) must be used to generate a complex analytic <em class="calibre7">x</em><sub class="calibre12">c</sub>(<em class="calibre7">n</em>) sequence (using one of the methods discussed in <a href="#calibre_link-346">Sections 9.4</a> and <a href="#calibre_link-650">9.5</a>) upon which this envelope detector scheme can be applied. The advantage of this envelope detection process is that, of course, no squaring or square root computations in <a href="#calibre_link-1499">Eq. (13-133)</a>, nor the |<em class="calibre7">x</em><sub class="calibre12">r</sub>(<em class="calibre7">n</em>)| and |<em class="calibre7">x</em><sub class="calibre12">i</sub>(<em class="calibre7">n</em>)| comparisons in the vector magnitude approximations in <a href="#calibre_link-678">Section 13.2</a>, need be performed.</p>
<p class="calibre3">Whether this envelope approximation technique yields sufficiently accurate results is for the user to decide. Its accuracy may be below the requirements of most AM (amplitude modulation) detection requirements, but the process may well be useful for estimating signal magnitude in automatic gain control (AGC) or energy detection applications.</p>
<p class="calibre3"><a id="calibre_link-701"></a></p>
<h3 class="calibre6">13.32 A Quadrature Oscillator</h3>
<p class="calibre3">Here we present a well-behaved digital quadrature oscillator, whose output is <em class="calibre7">y</em><sub class="calibre12">i</sub><em class="calibre7">(n)</em> + <em class="calibre7">jy</em><sub class="calibre12">q</sub><em class="calibre7">(n),</em> having the structure shown in <a href="#calibre_link-1500">Figure 13-79(a)</a>. If you’re new to digital oscillators, that structure looks a little complicated but it’s really not so bad. If you look carefully, you see the computations are</p>
<p class="caption"><a id="calibre_link-2089"></a><a id="calibre_link-1500"></a><strong class="calibre9">Figure 13-79</strong> Quadrature oscillators: (a) standard structure; (b) structure with AGC.</p>
<p class="image"><img src="images/001365.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-1501"></a>(13-134)</p>
<p class="image"><img src="images/000365.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">and</p>
<p class="caption"><a id="calibre_link-3347"></a>(13-134′)</p>
<p class="image"><img src="images/000465.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Those computations are merely the rectangular form of multiplying the previous complex output by a complex exponential <em class="calibre7">e<sup class="calibre10">j</sup></em><sup class="calibre10">θ</sup> as</p>
<p class="caption"><a id="calibre_link-3348"></a>(13-135)</p>
<p class="image"><img src="images/001769.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">So the theory of operation is simple. Each new complex output sample is the previous output sample rotated by θ radians, where θ is 2π<em class="calibre7">f</em><sub class="calibre12">t</sub>/<em class="calibre7">f</em><sub class="calibre12">s</sub> with <em class="calibre7">f</em><sub class="calibre12">t</sub> and <em class="calibre7">f</em><sub class="calibre12">s</sub> being the oscillator tuning frequency and the sample rate, respectively, in Hz.</p>
<p class="calibre3">To start the oscillator, we set the initial conditions of <em class="calibre7">y</em><sub class="calibre12">i</sub>(<em class="calibre7">n</em>−1) = 1 and <em class="calibre7">y</em><sub class="calibre12">q</sub>(<em class="calibre7">n</em>−1) = 0 and repeatedly compute new outputs, as time index <em class="calibre7">n</em> advances, using <a href="#calibre_link-1501">Eq. (13-134)</a>. This oscillator is called a <em class="calibre7">coupled quadrature oscillator</em> because both of its previous outputs are used to compute each new in-phase and each new quadrature output. It’s a useful oscillator because the full range of tuning frequencies is available (from nearly zero Hz up to roughly <em class="calibre7">f<sub class="calibre12">s</sub></em>/2), and its outputs are equal in amplitude, unlike some other quadrature oscillator structures<a href="#calibre_link-1502">[79]</a>. The tough part, however, is making this oscillator stable in fixed-point arithmetic implementations.</p>
<p class="calibre3">Depending on the binary word widths, and the value θ, the output amplitudes can either grow or decay as time increases because it’s not possible to represent <em class="calibre7">e<sup class="calibre10">j</sup></em><sup class="calibre10">θ</sup> having a magnitude of exactly one, over the full range of θ, using fixed-point number formats. The solution to amplitude variations is to <a id="calibre_link-2396"></a>compute <em class="calibre7">y</em><sub class="calibre12">i</sub>′(<em class="calibre7">n</em>−1) and <em class="calibre7">y</em><sub class="calibre12">q</sub>′(<em class="calibre7">n</em>−1) and multiply those samples by an instantaneous gain factor <em class="calibre7">G</em>(<em class="calibre7">n</em>) as shown in <a href="#calibre_link-1500">Figure 13-79(b)</a>. The trick here is how to compute the gain samples <em class="calibre7">G</em>(<em class="calibre7">n</em>).</p>
<p class="calibre3">We can use a linear automatic gain control (AGC) method, described in <a href="#calibre_link-699">Section 13.30</a>, as shown in <a href="#calibre_link-1503">Figure 13-80(a)</a> where α is a small value, say, α = 0.01. The value <em class="calibre7">R</em> is the desired rms value of the oscillator outputs. This AGC method greatly enhances the stability of our oscillator. However, there’s a computationally simpler AGC scheme for our oscillator that can be developed using the <em class="calibre7">Taylor series approximation</em> we learned in school. Here’s how.</p>
<p class="caption"><a id="calibre_link-1503"></a><strong class="calibre9">Figure 13-80</strong> AGC schemes: (a) linear AGC; (b) simplified AGC.</p>
<p class="image"><img src="images/000401.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Using an approach similar to reference <a href="#calibre_link-1504">[80]</a>, we can define the desired gain as</p>
<p class="caption"><a id="calibre_link-3349"></a>(13-136)</p>
<p class="image"><img src="images/000393.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">This is the desired output signal magnitude <em class="calibre7">M</em><sub class="calibre12">des</sub> over the actual output magnitude <em class="calibre7">M</em><sub class="calibre12">act</sub>. We can also represent the gain using power as</p>
<p class="caption"><a id="calibre_link-1505"></a>(13-137)</p>
<p class="image"><img src="images/000148.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where the constant <em class="calibre7">P</em><sub class="calibre12">des</sub> is the desired output signal power and <em class="calibre7">P</em><sub class="calibre12">act</sub> is the actual output power. The right side of <a href="#calibre_link-1505">Eq. (13-137)</a> shows <em class="calibre7">P</em><sub class="calibre12">act</sub> replaced by the desired power <em class="calibre7">P</em><sub class="calibre12">des</sub> plus an error component <em class="calibre7">E,</em> and that’s the ratio we’ll compute. To avoid square root computations and because the error <em class="calibre7">E</em> will be small, we’ll approximate that ratio with a two-term Taylor series expansion about <em class="calibre7">E</em> = 0 using</p>
<p class="caption"><a id="calibre_link-3350"></a>(13-138)</p>
<p class="image"><img src="images/001648.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Computing the Taylor series’ coefficients to be <em class="calibre7">a</em><sub class="calibre12">0</sub> = 1 and <em class="calibre7">a</em><sub class="calibre12">1</sub> = −1/2<em class="calibre7">P</em><sub class="calibre12">des</sub>, and recalling that <em class="calibre7">E</em> = <em class="calibre7">P</em><sub class="calibre12">act</sub>−<em class="calibre7">P</em><sub class="calibre12">des</sub>, we estimate the instantaneous gain as</p>
<p class="caption"><a id="calibre_link-1506"></a>(13-139)</p>
<p class="image"><img src="images/000535.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">If we let the quadrature output peak amplitudes equal <img src="images/000336.jpg" alt="image" class="calibre2" />, <em class="calibre7">P</em><sub class="calibre12">des</sub> equals 1/2 and we eliminate the division in <a href="#calibre_link-1506">Eq. (13-139)</a>, obtaining</p>
<p class="caption"><a id="calibre_link-3351"></a>(13-140)</p>
<p class="image"><img src="images/001738.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The simplified structure of the <em class="calibre7">G</em>(<em class="calibre7">n</em>) computation is shown in <a href="#calibre_link-1503">Figure 13-80(b)</a>.</p>
<p class="calibre3"><a id="calibre_link-2428"></a>As for practical issues, to avoid gain values greater than one (for those fixed-point fractional number systems that don’t allow numbers ≥1), we use the clever recommendation from reference <a href="#calibre_link-1502">[79]</a> of multiplying by <em class="calibre7">G</em>(<em class="calibre7">n</em>)/2 and doubling the products in <a href="#calibre_link-1500">Figure 13-79(b)</a>. Reference <a href="#calibre_link-1504">[80]</a> recommends using rounding, instead of truncation, for all intermediate computations to improve output spectral purity. Rounding also provides a slight improvement in tuning frequency control. Because this oscillator is guaranteed stable, and can be dynamically tuned, it’s definitely worth considering for real-valued as well as quadrature oscillator applications<a href="#calibre_link-1502">[79]</a>.</p>
<p class="calibre3"><a id="calibre_link-702"></a></p>
<h3 class="calibre6">13.33 Specialized Exponential Averaging</h3>
<p class="calibre3">In <a href="#calibre_link-225">Chapter 11</a> we discussed the behavior and utility of using an exponential averaging lowpass filter, also called a <em class="calibre7">leaky integrator,</em> to reduce noise fluctuations that contaminate constant-amplitude signal measurements. In this section we present three specialized exponential averaging techniques in the form of</p>
<p class="indenthangingb">• single-multiply averaging,</p>
<p class="indenthangingb">• multiplier-free averaging, and</p>
<p class="indenthangingb">• dual-mode averaging.</p>
<p class="calibre3"><a id="calibre_link-3352"></a></p>
<h4 class="calibre13">13.33.1 Single-Multiply Exponential Averaging</h4>
<p class="calibre3">This DSP trick shows how to reduce the computational workload of the standard exponential averager<a href="#calibre_link-1507">[81]</a>. An exponential averager’s difference equation is</p>
<p class="caption"><a id="calibre_link-1509"></a>(13-141)</p>
<p class="image"><img src="images/000765.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where α is a constant called the averager’s <em class="calibre7">weighting factor</em>, in the range 0 &lt; α &lt; 1. The process requires two multiplies per <em class="calibre7">y</em>(<em class="calibre7">n</em>) output sample as shown in <a href="#calibre_link-1508">Figure 13-81(a)</a>.</p>
<p class="caption"><a id="calibre_link-1508"></a><strong class="calibre9">Figure 13-81</strong> Exponential averaging: (a) standard network; (b) single-multiply network; (c) multiplierless network; (d) possible values for α; (e) dual-mode averaging.</p>
<p class="image"><img src="images/001252.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2429"></a>We can rearrange <a href="#calibre_link-1509">Eq. (13-141)</a> to the form</p>
<p class="caption"><a id="calibre_link-3353"></a>(13-141′)</p>
<p class="image"><img src="images/001620.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">which eliminates one of the averager’s multiplies, at the expense of an additional adder, giving us a single-multiply exponential averager shown in <a href="#calibre_link-1508">Figure 13-81(b)</a>. This neat single-multiply exponential averager maintains the DC (zero Hz) gain of unity exhibited by the traditional two-multiply exponential averager in <a href="#calibre_link-1508">Figure 13-81(a)</a>.</p>
<p class="calibre3"><a id="calibre_link-3354"></a></p>
<h4 class="calibre13">13.33.2 Multiplier-Free Exponential Averaging</h4>
<p class="calibre3">It is possible to eliminate the multiplier in <a href="#calibre_link-1508">Figure 13-81(b)</a> if we place restrictions on the permissible values of α. For example, if α = 0.125 = 1/8, then the <a id="calibre_link-2313"></a>output of the multiplier is merely the multiplier’s input sample shifted right by three bits.</p>
<p class="calibre3">On the other hand, if α takes the form</p>
<p class="caption"><a id="calibre_link-1510"></a>(13-142)</p>
<p class="image"><img src="images/000643.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where <em class="calibre7">L</em> = 0, 1, 2, 3, ... , and <em class="calibre7">M</em> = 1, 2, 3, ... , we can replace the multiplication by α in <a href="#calibre_link-1508">Figure 13-81(b)</a> with two binary right shifts and a subtract operation as shown in <a href="#calibre_link-1508">Figure 13-81(c)</a>. In that figure the “BRS,<em class="calibre7">L</em>” block means an arithmetic, or hardwired, Binary Right Shift by <em class="calibre7">L</em> bits.</p>
<p class="calibre3">For example, if <em class="calibre7">L</em> = 2 and <em class="calibre7">M</em> = 5, then from <a href="#calibre_link-1510">Eq. (13-142)</a>, α = 0.2188. The sequence <em class="calibre7">w</em>(<em class="calibre7">n</em>) = 0.2188<em class="calibre7">u</em>(<em class="calibre7">n</em>) = (1/4 − 1/32)<em class="calibre7">u</em>(<em class="calibre7">n</em>) is computed by subtracting <em class="calibre7">u</em>(<em class="calibre7">n</em>) shifted right by <em class="calibre7">M</em> = 5 bits from <em class="calibre7">u</em>(<em class="calibre7">n</em>) shifted right by <em class="calibre7">L</em> = 2 bits.</p>
<p class="calibre3">The tick marks in <a href="#calibre_link-1508">Figure 13-81(d)</a> show the possible values for the weighting factor α over the range of 0 ″ <em class="calibre7">L</em> ″ 5, where for each <em class="calibre7">L</em>, <em class="calibre7">M</em> is in the range <em class="calibre7">L</em>+1 ″ <em class="calibre7">M</em> ″ 6 in <a href="#calibre_link-1510">Eq. (13-142)</a>. That figure tells us that we have a reasonable selection of α values for our noise-reduction filtering applications.</p>
<p class="calibre3">The point is, for fixed-point implementation of exponential averaging, check to see if your desired α weighting factor can be represented by the difference of various reciprocals of integer powers of two. If so, then binary word shifting enables us to implement a multiplierless exponential averager.</p>
<p class="calibre3"><a id="calibre_link-3355"></a></p>
<h4 class="calibre13">13.33.3 Dual-Mode Averaging</h4>
<p class="calibre3">Here’s a clever exponential averaging scheme that blends both the quick time response of a moving averager and the noise-reduction control of an exponential averager.<sup class="calibre10"><a id="calibre_link-1512"></a><a href="#calibre_link-1511">†</a></sup> The structure of this dual-mode averager is depicted in <a href="#calibre_link-1508">Figure 13-81(e)</a>. The averager operates as follows: The switch remains open for <em class="calibre7">K</em> input samples after which the <em class="calibre7">y</em>(<em class="calibre7">n</em>) output is equal to the <em class="calibre7">K</em>-point average of the <em class="calibre7">x</em>(<em class="calibre7">n</em>) input. Just prior to the arrival of the <em class="calibre7">K</em>+1 input sample the switch closes, converting the moving average filter to an exponential averager, giving us control over the filter’s noise-reduction properties as described in <a href="#calibre_link-668">Section 11.6</a>.</p>
<p class="footnotes"><a id="calibre_link-1511"></a><sup class="calibre11"><a href="#calibre_link-1512">†</a></sup> We thank DSP guru Fred Harris for recommending this dual-mode averager.</p>
<p class="calibre3">Of course, <em class="calibre7">K</em> does not have to be an integer. In this case we can still implement dual-mode averaging by closing the switch just prior to the arrival of the <em class="calibre7">x</em>(<img src="images/001092.jpg" alt="image" class="calibre2" />) input sample, where <img src="images/001092.jpg" alt="image" class="calibre2" /> means the integer part of <em class="calibre7">K</em>. After the <em class="calibre7">K</em>th input sample has arrived, the averager’s gain at zero Hz (DC gain) is unity. As discussed in the previous section, if the weighting factor 1/<em class="calibre7">K</em> can be represented by the difference of various reciprocals of integer powers of two, then we can implement a multiplierless dual-mode noise-reduction filter.</p>
</div>
<div class="calibre" id="calibre_link-959">
<p class="calibre3"><a id="calibre_link-3356"></a></p>
<p class="calibre3"><a id="calibre_link-703"></a></p>
<h3 class="calibre6"><a id="calibre_link-1967" class="calibre5"></a>13.34 Filtering Narrowband Noise Using Filter Nulls</h3>
<p class="calibre3">Here we present two filter design tricks that take advantage of the frequency-domain magnitude nulls of simple FIR filters. These schemes are particularly useful when used in AM and FM demodulation systems.</p>
<p class="calibre3">The first example uses a simple 3-tap nonrecursive FIR filter. Such a filter can be both computationally efficient, and useful, for narrowband-noise reduction. Here’s how. Think about the <em class="calibre7">x</em>(<em class="calibre7">n</em>) time-domain signal, contaminated with high-frequency noise, shown in <a href="#calibre_link-960">Figure 13-82(a)</a> with its spectrum provided in <a href="#calibre_link-960">Figure 13-82(b)</a>. The sample rate of the signal is 10 kHz. Let’s assume we want to recover the low-frequency signal of interest (centered at zero Hz) without inducing phase distortion, and we need to attenuate the narrowband high-frequency noise, centered at 4.1 kHz, by at least 50 dB. Our solution, of course, is to pass our noisy signal through a linear-phase lowpass FIR filter whose frequency magnitude response is indicated as the dashed curve in <a href="#calibre_link-960">Figure 13-82(b)</a>.</p>
<p class="caption"><a id="calibre_link-960"></a><strong class="calibre9">Figure 13-82</strong> A noisy <em class="calibre7">x</em>(<em class="calibre7">n</em>): (a) time signal; (b) its <em class="calibre7">X</em>(<em class="calibre7">f</em>) spectral magnitude.</p>
<p class="image"><img src="images/000290.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Seeking the most computationally efficient filter possible, let’s say we’re clever and recall the special characteristic of a half-band FIR filter in which roughly half its coefficients are zero-valued. So we could design a 9-tap half-band FIR filter, having only five nonzero-valued coefficients, and that solution would be acceptable. Here’s where our <em class="calibre7">trick</em> comes in; we decide to use the linear-phase 3-tap FIR filter shown in <a href="#calibre_link-961">Figure 13-83(a)</a> with its single non-unity coefficient <em class="calibre7">h</em><sub class="calibre12">1</sub>.</p>
<p class="caption"><a id="calibre_link-961"></a><strong class="calibre9">Figure 13-83</strong> A 3-tap FIR filter: (a) filter structure; (b) pole locations; (c) frequency magnitude response.</p>
<p class="image"><img src="images/001132.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">If |<em class="calibre7">h</em><sub class="calibre12">1</sub>| ≤ 2, the 3-tap FIR filter’s transfer function will have two zeros on the <em class="calibre7">z</em>-plane at angles ±ω<sub class="calibre12">n</sub> as shown in <a href="#calibre_link-961">Figure 13-83(b)</a>. The frequency magnitude response of the filter is shown in <a href="#calibre_link-961">Figure 13-83(c)</a>. (Here, the normalized <a id="calibre_link-3357"></a>frequency axis value of π corresponds to a continuous-time frequency of half the sample rate, <em class="calibre7">f<sub class="calibre12">s</sub></em>/2.) Our goal, then, is to choose the <em class="calibre7">h</em><sub class="calibre12">1</sub> coefficient such that the filter’s positive-frequency magnitude null lands right on the 4.1 kHz center frequency of the narrowband noise in <a href="#calibre_link-960">Figure 13-82(b)</a>.</p>
<p class="calibre3">Our 3-tap filter design problem is easy because we have an expression for the <em class="calibre7">h</em><sub class="calibre12">1</sub> coefficient as a function of the desired <em class="calibre7">f</em><sub class="calibre12">n</sub> null frequency in Hz. The <em class="calibre7">h</em><sub class="calibre12">1</sub> coefficient value is</p>
<p class="caption"><a id="calibre_link-962"></a>(13-143)</p>
<p class="image"><img src="images/001497.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">With <em class="calibre7">f</em><sub class="calibre12">n</sub> = 4.1 kHz and <em class="calibre7">f</em><sub class="calibre12">s</sub> = 10 kHz, our <em class="calibre7">h</em><sub class="calibre12">1</sub> coefficient is 1.69. (The derivation of <a href="#calibre_link-962">Eq. (13-143)</a> was left as a homework problem in <a href="#calibre_link-79">Chapter 5</a>.) The <em class="calibre7">H</em>(<em class="calibre7">f</em>) frequency magnitude response of the <em class="calibre7">h</em><sub class="calibre12">1</sub> = 1.69 filter is shown as the dotted curve in <a href="#calibre_link-963">Figure 13-84(a)</a>. The <em class="calibre7">Y</em>(<em class="calibre7">f</em>) spectrum of the filter’s output is shown in <a href="#calibre_link-963">Figure 13-84(b)</a> where the narrowband noise has been attenuated by roughly 54 dB. (Recall that the noise magnitudes in the original <em class="calibre7">X</em>(<em class="calibre7">f</em>) spectrum were approximately 12 dB above the signal’s peak magnitude in <a href="#calibre_link-960">Figure 13-82(b)</a>.) The filter’s time-domain <em class="calibre7">y</em>(<em class="calibre7">n</em>) output signal, our <em class="calibre7">signal of interest</em>, is shown in <a href="#calibre_link-963">Figure 13-84(c)</a>. It’s instructive to compare that output signal to the filter’s <em class="calibre7">x</em>(<em class="calibre7">n</em>) input signal in <a href="#calibre_link-960">Figure 13-82(a)</a>.</p>
<p class="caption"><a id="calibre_link-963"></a><strong class="calibre9">Figure 13-84</strong> Three-tap filter performance: (a) |<em class="calibre7">H</em>(<em class="calibre7">f</em>)| response; (b) filter output spectrum; (c) filter time-domain output signal.</p>
<p class="image"><img src="images/000179.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">So we solved our narrowband noise filtering problem with a linear-phase FIR filter requiring only two additions and one multiply per filter output sample. Neat, huh?</p>
<p class="calibre3"><a id="calibre_link-3358"></a>Our second example of this filter design approach that takes advantage of the frequency-domain magnitude nulls of simple FIR filters involves the attenuation of multiple narrowband noise spectral components whose center frequencies are harmonically related in a frequency shift keying (FSK) demodulation system<a href="#calibre_link-964">[82]</a>. Think about a signal of interest centered at 455 kHz as shown in <a href="#calibre_link-965">Figure 13-85(a)</a>. That signal, sampled at <em class="calibre7">f<sub class="calibre12">s</sub></em> = 10 MHz, is contaminated with unwanted high-amplitude DC (zero Hz) bias noise and narrowband spectral noise components at multiples of 455 kHz. Removing the DC bias, whose magnitude is 0 dB in <a href="#calibre_link-965">Figure 13-85(a)</a>, and extracting the signal of interest from the noise appears to require some sort of bandpass filter centered at 455 kHz.</p>
<p class="caption"><a id="calibre_link-965"></a><strong class="calibre9">Figure 13-85</strong> Harmonic noise example: (a) |<em class="calibre7">X</em>(<em class="calibre7">f</em>)| spectrum; (b) filter output spectrum.</p>
<p class="image"><img src="images/001021.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">However, the trick is to use a standard FIR comb filter to remove the unwanted DC bias and attenuate the harmonic noise components. A comb filter is shown in <a href="#calibre_link-966">Figure 13-86(a)</a> where the <em class="calibre7">z<sup class="calibre10">−N</sup></em> operation is merely a delay of <em class="calibre7">N</em> samples. The |<em class="calibre7">H</em>(<em class="calibre7">f</em>)| frequency magnitude response of an <em class="calibre7">N</em> = 8, for example, comb filter is provided in <a href="#calibre_link-966">Figure 13-86(b)</a> where <em class="calibre7">f<sub class="calibre12">s</sub></em> is the sample rate.</p>
<p class="caption"><a id="calibre_link-966"></a><strong class="calibre9">Figure 13-86</strong> Standard <em class="calibre7">N</em>-delay FIR comb filter: (a) filter structure; (b) frequency magnitude response when <em class="calibre7">N</em> = 8.</p>
<p class="image"><img src="images/000070.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3359"></a>For <em class="calibre7">N</em>-delay comb filter design purposes, the following two equations give us the frequency locations of the magnitude nulls (<em class="calibre7">f</em><sub class="calibre12">null</sub>) and magnitude peaks (<em class="calibre7">f</em><sub class="calibre12">peak</sub>) in the filter’s |<em class="calibre7">H</em>(<em class="calibre7">f</em>)|,</p>
<p class="caption"><a id="calibre_link-3360"></a>(13-144)</p>
<p class="image"><img src="images/001230.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-967"></a>(13-144′)</p>
<p class="image"><img src="images/000048.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where <img src="images/000149.jpg" alt="image" class="calibre2" /> means the integer part of <em class="calibre7">X</em>. These <em class="calibre7">f</em><sub class="calibre12">null</sub> and <em class="calibre7">f</em><sub class="calibre12">peak</sub> expressions are valid for both odd and even <em class="calibre7">N</em> so long as <em class="calibre7">N</em> is larger than one.</p>
<p class="calibre3"><a id="calibre_link-3361"></a>For this noise-reduction problem, we need a comb filter that provides a magnitude null at zero Hz and a magnitude peak at 455 kHz. Rearranging <a href="#calibre_link-967">Eq. (13-144′)</a> to find a candidate value for the comb delay <em class="calibre7">N</em> for <em class="calibre7">k</em> = 0, we have</p>
<p class="caption"><a id="calibre_link-3362"></a>(13-145)</p>
<p class="image"><img src="images/000434.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">so we select <em class="calibre7">N</em> to be 11. The filter’s output spectrum, when <em class="calibre7">N</em> = 11, is shown in <a href="#calibre_link-965">Figure 13-85(b)</a>. There we see the dramatic reduction in the unwanted DC bias as well as the narrowband noise located at 910 kHz. (For reference purposes, we’ve included the <em class="calibre7">N</em> = 11 comb filter’s magnitude response in <a href="#calibre_link-965">Figure 13-85(b)</a>.)</p>
<p class="calibre3">So in this example we simplified our overall narrowband noise filtering problem using a linear-phase FIR comb filter requiring only one addition per filter output sample. In practice the comb filter is followed by a low-order lowpass filter, whose stopband would begin in the vicinity of 1365 kHz. That follow-on filter will have a significantly reduced computational workload compared to the case where the pre-filtering by the simple comb filter was not performed.</p>
<p class="calibre3">For completeness, we must mention here that an <em class="calibre7">alternate</em> comb filter can be built using the network in <a href="#calibre_link-968">Figure 13-87(a)</a> where addition is performed as opposed to the subtraction in <a href="#calibre_link-966">Figure 13-86(a)</a>.</p>
<p class="caption"><a id="calibre_link-968"></a><strong class="calibre9">Figure 13-87</strong> Alternate <em class="calibre7">N</em>-delay FIR comb filter: (a) filter structure; (b) |<em class="calibre7">H</em><sub class="calibre12">alt</sub>(<em class="calibre7">f</em>)| frequency magnitude response when <em class="calibre7">N</em> = 8.</p>
<p class="image"><img src="images/000913.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">For the alternate comb filter in <a href="#calibre_link-968">Figure 13-87(a)</a> the following two equations give us the frequency locations of the magnitude nulls (<em class="calibre7">f</em><sub class="calibre12">null,alt</sub>) and magnitude peaks (<em class="calibre7">f</em><sub class="calibre12">peak,alt</sub>) in this <em class="calibre7">N</em>-delay comb filter’s |<em class="calibre7">H</em><sub class="calibre12">alt</sub>(<em class="calibre7">f</em>)|,</p>
<p class="caption"><a id="calibre_link-3363"></a>(13-146)</p>
<p class="image"><img src="images/001301.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-3364"></a>(13-146′)</p>
<p class="image"><img src="images/000322.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2011"></a>where <img src="images/000149.jpg" alt="image" class="calibre2" /> means the integer part of <em class="calibre7">X</em>. This alternate comb filter gives us a bit of design flexibility because it passes low-frequency signals due to a frequency magnitude peak at zero Hz (DC).</p>
<p class="calibre3"><a id="calibre_link-550"></a></p>
<h3 class="calibre6">13.35 Efficient Computation of Signal Variance</h3>
<p class="calibre3">In this section we show how to reduce the computational workload, and required data storage, in computing the unbiased and biased variances of a signal sequence. (Definitions of <em class="calibre7">biased</em> and <em class="calibre7">unbiased variances</em> can be found in <a href="#calibre_link-27">Appendix D</a>.)</p>
<p class="calibre3">We start our discussion with the traditional definition of the unbiased variance of <em class="calibre7">x</em>(<em class="calibre7">n</em>), a sequence of <em class="calibre7">N</em> samples, written as</p>
<p class="caption"><a id="calibre_link-969"></a>(13-147)</p>
<p class="image"><img src="images/000731.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where <em class="calibre7">x</em><sub class="calibre12">ave</sub> is the average of the <em class="calibre7">N</em>-length <em class="calibre7">x</em>(<em class="calibre7">n</em>) sequence. Because <em class="calibre7">N</em> is a constant, we can treat the divide by <em class="calibre7">N</em> needed to compute <em class="calibre7">x</em><sub class="calibre12">ave</sub>, and the above divide by (<em class="calibre7">N</em>−1), as multiplies by reciprocals, allowing us to say that <a href="#calibre_link-969">Eq. (13-147)</a> requires 3<em class="calibre7">N</em>−2 addition and <em class="calibre7">N</em>+2 multiply operations. As it turns out, we can obtain an equivalent expression for <em class="calibre7">Var</em><sub class="calibre12">unbiased</sub> that has a reduced number of arithmetic operations<a href="#calibre_link-970">[83]</a>. Here’s how.</p>
<p class="calibre3">First, we square the bracketed term in the summation in <a href="#calibre_link-969">Eq. (13-147)</a> and write</p>
<p class="caption"><a id="calibre_link-971"></a>(13-148)</p>
<p class="image"><img src="images/000441.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Because the center summation in <a href="#calibre_link-971">Eq. (13-148)</a> is</p>
<p class="image"><img src="images/000986.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">we can rewrite <em class="calibre7">Var</em><sub class="calibre12">unbiased</sub> as</p>
<p class="caption"><a id="calibre_link-3365"></a><a id="calibre_link-3366"></a>(13-148′)</p>
<p class="image"><img src="images/001600.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Next, we arrive at our desired expression by combining terms and write <em class="calibre7">Var</em><sub class="calibre12">unbiased</sub> as</p>
<p class="caption"><a id="calibre_link-972"></a>(13-149)</p>
<p class="image"><img src="images/000621.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The efficient <a href="#calibre_link-972">Eq. (13-149)</a> requires only 2<em class="calibre7">N</em>−1 addition and <em class="calibre7">N</em>+4 multiply operations. So at the expense of two extra multiplies, we’ve reduced the number of additions needed to compute <em class="calibre7">Var</em><sub class="calibre12">unbiased</sub> by roughly <em class="calibre7">N</em> relative to <a href="#calibre_link-969">Eq. (13-147)</a>.</p>
<p class="calibre3">There is a second advantage in using <a href="#calibre_link-972">Eq. (13-149)</a> instead of <a href="#calibre_link-969">Eq. (13-147)</a> in computing the variance of <em class="calibre7">N</em> incoming <em class="calibre7">x</em>(<em class="calibre7">n</em>) samples. When using <a href="#calibre_link-969">Eq. (13-147)</a> to compute <em class="calibre7">Var</em><sub class="calibre12">unbiased</sub>, we first compute <em class="calibre7">x</em><sub class="calibre12">ave</sub> and must retain, in memory, the <em class="calibre7">N</em>-length <em class="calibre7">x</em>(<em class="calibre7">n</em>) sequence in order to compute the [<em class="calibre7">x</em>(<em class="calibre7">n</em>) − <em class="calibre7">x</em><sub class="calibre12">ave</sub>]<sup class="calibre10">2</sup> sequence. When using <a href="#calibre_link-972">Eq. (13-149)</a> to compute <em class="calibre7">Var</em><sub class="calibre12">unbiased</sub>, we can simultaneously accumulate (sum) the <em class="calibre7">N</em> incoming <em class="calibre7">x</em>(<em class="calibre7">n</em>) samples and accumulate the <em class="calibre7">N</em> computed <em class="calibre7">x</em>(<em class="calibre7">n</em>)<sup class="calibre10">2</sup> samples without having to keep past <em class="calibre7">x</em>(<em class="calibre7">n</em>) samples in memory. Thus <a href="#calibre_link-972">Eq. (13-149)</a> reduces the amount of data storage needed to compute <em class="calibre7">Var</em><sub class="calibre12">unbiased</sub>.</p>
<p class="calibre3">The traditional definition for the biased variance of <em class="calibre7">N x</em>(<em class="calibre7">n</em>) samples is written as</p>
<p class="caption"><a id="calibre_link-974"></a>(13-150)</p>
<p class="image"><img src="images/000515.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Using a derivation similar to how we arrived at <a href="#calibre_link-972">Eq. (13-149)</a>, we can write an efficient expression for computing a biased variance as</p>
<p class="caption"><a id="calibre_link-973"></a>(13-150′)</p>
<p class="image"><img src="images/001376.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2381"></a><a href="#calibre_link-973">Equation (13-150′)</a> requires 2<em class="calibre7">N</em>−1 addition and <em class="calibre7">N</em>+2 multiply operations. Here again, we’ve reduced the number of additions needed to compute <em class="calibre7">Var</em><sub class="calibre12">biased</sub> by roughly <em class="calibre7">N</em> and reduced the necessary data storage, relative to <a href="#calibre_link-974">Eq. (13-150)</a>. In the next section we discuss the hardware implementation of variance computations with a focus on real-time processing.</p>
<p class="calibre3"><a id="calibre_link-704"></a></p>
<h3 class="calibre6">13.36 Real-time Computation of Signal Averages and Variances</h3>
<p class="calibre3">In this section we present techniques for the efficient computation of real-time estimates of signal average and variance. By “real-time” we mean a continuing sequence of statistical estimates will be generated, in time, as a continuing sequence of input signal samples is applied to our processing networks.</p>
<p class="calibre3"><a id="calibre_link-3367"></a></p>
<h4 class="calibre13">13.36.1 Computing Moving Averages and Variances</h4>
<p class="calibre3"><a href="#calibre_link-975">Figure 13-88(a)</a> shows a 5-point real-time recursive moving averager that we analyzed in <a href="#calibre_link-667">Section 11.5</a>. For the reasons discussed in <a href="#calibre_link-667">Section 11.5</a> the recursive moving averager is the most computationally efficient method for computing moving averages.</p>
<p class="caption"><a id="calibre_link-975"></a><strong class="calibre9">Figure 13-88</strong> Real-time recursive <em class="calibre7">N</em>-point moving averager: (a) standard <em class="calibre7">N</em> = 5 implementation; (b) alternate implementation; (c) general recursive depiction.</p>
<p class="image"><img src="images/001777.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a href="#calibre_link-975">Figure 13-88(b)</a> shows an alternate, but equivalent, recursive moving averager where the integrator now precedes the 1/5 multiplication. In this alternate arrangement the binary register holding the integrator’s accumulation results must be large enough to accommodate values in the range of five (number of unit-delay registers) times the true average of the most recent <em class="calibre7">N x</em>(<em class="calibre7">n</em>) input samples.</p>
<p class="calibre3">In <a href="#calibre_link-975">Figure 13-88(c)</a> we redraw the alternate recursive moving averager in order to show the network of a general <em class="calibre7">N</em>-point recursive moving averager. There we use a single <em class="calibre7">z</em><sup class="calibre10">−<em class="calibre7">N</em></sup> delay element symbol to represent an <em class="calibre7">N</em>-length delay line. In that figure we show a network inside the dashed-line box, which we’ll use later for other statistical computations, called a <em class="calibre7">recursive running sum</em> (RRS).</p>
<p class="calibre3">Focusing now on the second topic of this section, there is a way to estimate the real-time <em class="calibre7">N</em>-point moving unbiased variance of a signal, <em class="calibre7">x</em><sub class="calibre12">var,unbiased</sub>(<em class="calibre7">n</em>)<a href="#calibre_link-976">[84]</a>. (A definition of <em class="calibre7">unbiased variance</em> is provided in <a href="#calibre_link-27">Appendix D</a>.) To see how, we start with the expression for the unbiased variance of <em class="calibre7">N</em> time samples, <a href="#calibre_link-972">Eq. (13-149)</a> from the previous section, rewritten here as</p>
<p class="caption"><a id="calibre_link-977"></a>(13-151)</p>
<p class="image"><img src="images/000416.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3368"></a>where <em class="calibre7">x</em><sub class="calibre12">ave</sub>(<em class="calibre7">n</em>) is the average of the most recent <em class="calibre7">N</em> input <em class="calibre7">x</em>(<em class="calibre7">n</em>) samples. The limits on the summation in <a href="#calibre_link-977">Eq. (13-151)</a> are such that we’re summing a sliding-in-time block of <em class="calibre7">N</em> samples of x(<em class="calibre7">n</em>)<sup class="calibre10">2</sup>.</p>
<p class="calibre3">The implementation of <a href="#calibre_link-977">Eq. (13-151)</a> is shown in <a href="#calibre_link-978">Figure 13-89(a)</a> where the process uses two <em class="calibre7">N</em>-point RRS networks from <a href="#calibre_link-975">Figure 13-88(c)</a> to compute the <em class="calibre7">N</em>-point moving unbiased variance <em class="calibre7">x</em><sub class="calibre12">var,unbiased</sub>(<em class="calibre7">n</em>) and the <em class="calibre7">x</em><sub class="calibre12">ave</sub>(<em class="calibre7">n</em>) <em class="calibre7">N</em>-point moving average of <em class="calibre7">x</em>(<em class="calibre7">n</em>)[<a href="#calibre_link-970">83</a>,<a href="#calibre_link-979">85</a>]. Note that the <em class="calibre7">x</em><sub class="calibre12">var,unbiased</sub>(<em class="calibre7">n</em>) and <em class="calibre7">x</em><sub class="calibre12">ave</sub>(<em class="calibre7">n</em>) outputs are not valid until the <em class="calibre7">N</em>-stage delay lines are filled with input data.</p>
<p class="caption"><a id="calibre_link-978"></a><strong class="calibre9">Figure 13-89</strong> Real-time <em class="calibre7">N</em>-point moving variance networks.</p>
<p class="image"><img src="images/000801.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">To estimate the real-time <em class="calibre7">N</em>-point moving biased variance of a signal, <em class="calibre7">x</em><sub class="calibre12">var,biased</sub>(<em class="calibre7">n</em>), we compute</p>
<p class="caption"><a id="calibre_link-2182"></a><a id="calibre_link-3369"></a>(13-152)</p>
<p class="image"><img src="images/001266.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">using the network shown in <a href="#calibre_link-978">Figure 13-89(b)</a>.</p>
<p class="calibre3">From a practical standpoint, in fixed-point systems, note that the binary word width of the upper RRS delay lines, in <a href="#calibre_link-978">Figure 13-89</a>, must be twice as wide as the lower RRS delay lines.</p>
<p class="calibre3">The above real-time fixed-length moving average and moving variance networks require data memory to implement their <em class="calibre7">N</em>-point delay lines. The following section describes techniques for estimating cumulative averages and variances with reduced data memory requirements.</p>
<p class="calibre3"><a id="calibre_link-3370"></a></p>
<h4 class="calibre13">13.36.2 Computing Exponential Moving Average and Variance</h4>
<p class="calibre3">An alternate method to generate estimates of both the real-time moving average and real-time moving variance of a signal is to use the exponential averager that we discussed in <a href="#calibre_link-668">Section 11.6</a>, shown in <a href="#calibre_link-980">Figure 13-90(a)</a>. The coefficient α is the exponential averager’s <em class="calibre7">weighting factor</em> that controls the amount of averaging that takes place at the output of the network.</p>
<p class="caption"><a id="calibre_link-980"></a><strong class="calibre9">Figure 13-90</strong> Exponential moving average and exponential moving variance: (a) standard exponential averaging network; (b) full structure.</p>
<p class="image"><img src="images/000410.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">To generate our desired exponential moving average and exponential moving variance, we use two independent exponential averaging (EA) <a id="calibre_link-2307"></a>networks as shown in <a href="#calibre_link-980">Figure 13-90(b)</a>. The two weighting factors, α<sub class="calibre12">1</sub> and α<sub class="calibre12">2</sub>, are constants in the range of zero to one.</p>
<p class="calibre3">The process in <a href="#calibre_link-980">Figure 13-90(b)</a> has several attractive properties. The α<sub class="calibre12">1</sub> and α<sub class="calibre12">2</sub> coefficients permit control over the averaging behavior of the process; and the <a href="#calibre_link-980">Figure 13-90(b)</a> process requires fewer computations per output sample, and reduced delay-line element (data memory) requirements, relative to the networks in <a href="#calibre_link-978">Figure 13-89</a>.</p>
<p class="calibre3"><a id="calibre_link-340"></a></p>
<h3 class="calibre6">13.37 Building Hilbert Transformers from Half-band Filters</h3>
<p class="calibre3">This section discusses two techniques for obtaining the coefficients of a Hilbert transformer from the coefficients of an <em class="calibre7">N</em>-point nonrecursive FIR half-band filter[<a href="#calibre_link-981">86</a>,<a href="#calibre_link-982">87</a>]. The first scheme is useful for someone who needs to design a Hilbert transformer when only generic lowpass FIR filter design software is available. The second scheme is useful for those unfortunate folks who have no FIR filter design software at hand but have available the coefficients of a half-band filter.</p>
<p class="calibre3"><a id="calibre_link-3371"></a></p>
<h4 class="calibre13">13.37.1 Half-band Filter Frequency Translation</h4>
<p class="calibre3">We can design a Hilbert transformer by first designing an <em class="calibre7">N</em>-tap half-band filter using our favorite FIR filter design software, with the restriction that <em class="calibre7">N</em>+1 is an integer multiple of four. Let’s call the half-band filter’s coefficients <em class="calibre7">h</em><sub class="calibre12">hb</sub>(<em class="calibre7">k</em>), <a id="calibre_link-3372"></a>where the coefficients’ index variable <em class="calibre7">k</em> is 0, 1, 2, ..., <em class="calibre7">N</em>−1. Next we obtain the Hilbert transformer’s <em class="calibre7">h</em><sub class="calibre12">hilb</sub>(<em class="calibre7">k</em>) coefficients using</p>
<p class="caption"><a id="calibre_link-984"></a>(13-153)</p>
<p class="image"><img src="images/000032.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a href="#calibre_link-983">Figure 13-91(a)</a> shows the coefficients of a simple 7-tap half-band filter whose DC gain is unity. <a href="#calibre_link-983">Figure 13-91(b)</a> shows the Hilbert transformer’s <em class="calibre7">h</em><sub class="calibre12">hilb</sub>(<em class="calibre7">k</em>) coefficients obtained from <a href="#calibre_link-984">Eq. (13-153)</a>. The network using those <em class="calibre7">h</em><sub class="calibre12">hilb</sub>(<em class="calibre7">k</em>) coefficients to generate a complex (analytic) <em class="calibre7">x</em><sub class="calibre12">c</sub>(<em class="calibre7">n</em>) = <em class="calibre7">x</em><sub class="calibre12">I</sub>(<em class="calibre7">n</em>)+<em class="calibre7">jx</em><sub class="calibre12">Q</sub>(<em class="calibre7">n</em>) sequence from an original real-valued <em class="calibre7">x</em><sub class="calibre12">R</sub>(<em class="calibre7">n</em>) sequence is shown in <a href="#calibre_link-983">Figure 13-91(c)</a>. (Notice the <em class="calibre7">z</em><sup class="calibre10">−2</sup> delay blocks comprising two unit-delay elements.)</p>
<p class="caption"><a id="calibre_link-983"></a><strong class="calibre9">Figure 13-91</strong> Seven-tap half-band FIR transformation: (a) <em class="calibre7">h</em><sub class="calibre12">hb</sub>(k); (b) <em class="calibre7">h</em><sub class="calibre12">hilb</sub>(<em class="calibre7">k</em>); (c) complex bandpass filter structure.</p>
<p class="image"><img src="images/001261.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Let’s call the network in <a href="#calibre_link-983">Figure 13-91(c)</a> a complex bandpass filter and describe its characteristics a bit further. <a href="#calibre_link-985">Figure 13-92(a)</a> shows the |<em class="calibre7">H</em><sub class="calibre12">hb</sub>(<em class="calibre7">f</em>)| frequency magnitude response of a half-band filter, and <a href="#calibre_link-985">Figure 13-92(b)</a> shows us that the complex bandpass filter’s |<em class="calibre7">H</em><sub class="calibre12">cbp</sub>(<em class="calibre7">f</em>)| frequency magnitude response is |<em class="calibre7">H</em><sub class="calibre12">hb</sub>(<em class="calibre7">f</em>)| translated up in frequency by <em class="calibre7">f<sub class="calibre12">s</sub></em>/4. However, notice that |<em class="calibre7">H</em><sub class="calibre12">cbp</sub>(<em class="calibre7">f</em>)|’s passband gain and ripple, as well as its stopband ripple, are twice that of |<em class="calibre7">H</em><sub class="calibre12">hb</sub>(<em class="calibre7">f</em>)|. To make the complex bandpass filter’s gain unity, rather than two, we decrease its coefficients by a factor of two and multiply the <em class="calibre7">x</em><sub class="calibre12">I</sub>(<em class="calibre7">n</em>) sequence in <a href="#calibre_link-983">Figure 13-91(c)</a> by 0.5. That 0.5 multiply could, of course, be implemented with an arithmetic right shift of the <em class="calibre7">x</em><sub class="calibre12">I</sub>(<em class="calibre7">n</em>) samples.</p>
<p class="caption"><a id="calibre_link-2317"></a><a id="calibre_link-985"></a><strong class="calibre9">Figure 13-92</strong> Frequency magnitude responses: (a) half-band filter; (b) complex bandpass filter.</p>
<p class="image"><img src="images/001762.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The nifty part of this complex bandpass filter is as follows: To build a complex nonrecursive FIR filter having the performance (transition region width, stopband attenuation, etc.) of a real <em class="calibre7">N</em>-tap lowpass FIR filter, we typically must implement two real <em class="calibre7">N</em>-tap FIR filters having an overall computational workload of 2(<em class="calibre7">N</em>−1) additions and 2<em class="calibre7">N</em> multiplications per complex output sample, as well as provide 2<em class="calibre7">N</em> memory locations to store the complex coefficients. The complex bandpass filter in <a href="#calibre_link-983">Figure 13-91(c)</a> reduces those computations and the memory requirement by a factor of two.</p>
<p class="calibre3">Here’s another attribute: because the complex filter’s coefficients are antisymmetrical, we can use the <em class="calibre7">folded</em> FIR filter scheme described in <a href="#calibre_link-148">Section 13.7</a> to reduce the number of multipliers by another factor of two!</p>
<p class="calibre3"><a id="calibre_link-3373"></a></p>
<h4 class="calibre13">13.37.2 Half-band Filter Coefficient Modification</h4>
<p class="calibre3">This second <em class="calibre7"><a href="#calibre_link-986">half-band filter</a> to Hilbert transformer</em> conversion scheme is useful for those unfortunate folks who have no nonrecursive FIR filter design software at hand but do happen to have the coefficients of a half-band filter. We can obtain the <em class="calibre7">h</em><sub class="calibre12">hilb</sub>(<em class="calibre7">k</em>) coefficients of a Hilbert transformer with a straightforward modification of the half-band FIR filter’s <em class="calibre7">h</em><sub class="calibre12">hb</sub>(<em class="calibre7">k</em>) coefficients. The modification steps are as follows:</p>
<p class="indenthangingn1"><strong class="calibre9">1.</strong> Identify the center coefficient of <em class="calibre7">h</em><sub class="calibre12">hb</sub>(<em class="calibre7">k</em>); call it <em class="calibre7">h</em><sub class="calibre12">center</sub>.</p>
<p class="indenthangingn1"><strong class="calibre9">2.</strong> Make the signs (polarity) of all nonzero coefficients before <em class="calibre7">h</em><sub class="calibre12">center</sub> negative.</p>
<p class="indenthangingn1"><strong class="calibre9">3.</strong> Make the signs (polarity) of all nonzero coefficients after <em class="calibre7">h</em><sub class="calibre12">center</sub> positive.</p>
<p class="indenthangingn1"><strong class="calibre9">4.</strong> Set the <em class="calibre7">h</em><sub class="calibre12">center</sub> coefficient equal to zero.</p>
<p class="calibre3"><a id="calibre_link-2463"></a>An example of this <em class="calibre7"><a href="#calibre_link-986">half-band filter</a> coefficient modification</em> process is shown for an 11-tap FIR half-band filter’s <em class="calibre7">h</em><sub class="calibre12">hb</sub>(<em class="calibre7">k</em>) in <a href="#calibre_link-987">Figure 13-93</a>. In order to use the <a href="#calibre_link-987">Figure 13-93(b)</a> <em class="calibre7">h</em><sub class="calibre12">hilb</sub>(<em class="calibre7">k</em>) coefficients in the complex bandpass filter in <a href="#calibre_link-985">Figure 13-92(c)</a>, those <em class="calibre7">h</em><sub class="calibre12">hilb</sub>(<em class="calibre7">k</em>) coefficients will need to be multiplied by a factor of two, or the <em class="calibre7">x</em><sub class="calibre12">I</sub>(<em class="calibre7">n</em>) sequence in <a href="#calibre_link-983">Figure 13-91(c)</a> must be multiplied by 0.5. The 0.5 multiply can be implemented with an arithmetic right shift of the <em class="calibre7">x</em>′<sub class="calibre12">r</sub>(<em class="calibre7">n</em>) samples if desired.</p>
<p class="caption"><a id="calibre_link-987"></a><strong class="calibre9">Figure 13-93</strong> Half-band filter coefficient modification: (a) original <em class="calibre7">h</em><sub class="calibre12">hb</sub>(<em class="calibre7">k</em>) coefficients; (b) <em class="calibre7">h</em><sub class="calibre12">hilb</sub>(<em class="calibre7">k</em>) coefficients.</p>
<p class="image"><img src="images/001138.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-705"></a></p>
<h3 class="calibre6">13.38 Complex Vector Rotation with Arctangents</h3>
<p class="calibre3">It’s often the case in quadrature (<em class="calibre7">I</em>/<em class="calibre7">Q</em>) processing systems that we want to compute the angle of a complex time-domain sample. That angle computation for a complex sample <em class="calibre7">C</em> = <em class="calibre7">I</em> + <em class="calibre7">jQ</em> is, of course,</p>
<p class="caption"><a id="calibre_link-988"></a>(13-154)</p>
<p class="image"><img src="images/000636.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">As it turns out, the arctangent computation in <a href="#calibre_link-988">Eq. (13-154)</a> can be performed in many ways&mdash;anywhere from slow but accurate computationally intensive high-order polynomial evaluation, to high-speed crude-accuracy table look-up methods. However, regardless of the method used, we can improve the accuracy and speed of an arctangent computation if we limit the angular range over which it is performed. And that’s where the vector rotation tricks presented here come into play.</p>
<p class="calibre3"><a id="calibre_link-3374"></a></p>
<h4 class="calibre13">13.38.1 Vector Rotation to the 1st Octant</h4>
<p class="calibre3">Plotted on the complex plane, a complex sample <em class="calibre7">C</em> = <em class="calibre7">I</em> + <em class="calibre7">jQ</em> can reside in any of the eight octants shown in <a href="#calibre_link-989">Figure 13-94(a)</a>. When performing arctangents, <a id="calibre_link-3375"></a>please know that arctangent algorithms, be they high precision and computationally expensive or be they computationally simple and lower precision, are more accurate for small angles. (That is because the problematic arctangent function is only approximately linear for small angles.) So what does this mean to us? It means that if we can <em class="calibre7">effectively</em> rotate the angle of complex sample <em class="calibre7">C</em> into <a href="#calibre_link-989">Figure 13-94(a)</a>’s 1st or 8th octant, a smaller angle, arctangent algorithms will provide more accurate results.</p>
<p class="caption"><a id="calibre_link-989"></a><strong class="calibre9">Figure 13-94</strong> Complex vector rotation: (a) octant definitions; (b) vector rotation from the 7th octant to the 1st octant.</p>
<p class="image"><img src="images/000189.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">For example, consider the complex number represented by vector <em class="calibre7">C</em> in <a href="#calibre_link-989">Figure 13-94(b)</a> residing in the 7th octant. The angle θ we want to compute is more negative than −π/4 radians (−45 degrees). Our trick is to rotate <em class="calibre7">C</em> to a new (and smaller) angle θ<sub class="calibre12">1st</sub>, compute θ<sub class="calibre12">1st</sub> with an arctangent algorithm, and add θ<sub class="calibre12">1st</sub> to −π/2 to obtain the desired value for θ.</p>
<p class="calibre3">Rotating vector <em class="calibre7">C</em> can be implemented as follows:</p>
<p class="indenthangingb">• If vector <em class="calibre7">C</em>‘s <em class="calibre7">Q</em> component is negative (<em class="calibre7">C</em> is in the 5th through the 8th octant), we can rotate <em class="calibre7">C</em> by 180 degrees by negating both the <em class="calibre7">I</em> and <em class="calibre7">Q</em> components.</p>
<p class="indenthangingb">• If vector <em class="calibre7">C</em> is in the 3rd or 4th octant, we can rotate <em class="calibre7">C</em> clockwise by 90 degrees by setting the new <em class="calibre7">I</em> equal to the old <em class="calibre7">Q</em> value, and setting the new <em class="calibre7">Q</em> equal to the negative of the old <em class="calibre7">I</em> value. (Note that the negative of the old <em class="calibre7">I</em> value is equal to the absolute value of the old <em class="calibre7">I</em> value.)</p>
<p class="indenthangingb">• If vector <em class="calibre7">C</em> is in the 2nd octant, we can rotate <em class="calibre7">C</em> clockwise by 45 degrees by swapping the <em class="calibre7">I</em> and <em class="calibre7">Q</em> components.</p>
<p class="calibre3">Using the above rotation operations for our <a href="#calibre_link-989">Figure 13-94(b)</a> example, we can rotate the original 7th-octant <em class="calibre7">C</em> = <em class="calibre7">I</em> + <em class="calibre7">jQ</em> to the 3rd octant by creating vector <em class="calibre7">C</em><sub class="calibre12">3rd</sub> = −<em class="calibre7">I</em> − <em class="calibre7">jQ</em>. Next we rotate <em class="calibre7">C</em><sub class="calibre12">3rd</sub> to the 1st octant by creating vector <em class="calibre7">C</em><sub class="calibre12">1st</sub> = −<em class="calibre7">Q</em> + <em class="calibre7">jI</em>. We compute θ<sub class="calibre12">1st</sub> as</p>
<p class="caption"><a id="calibre_link-2465"></a><a id="calibre_link-3376"></a>(13-155)</p>
<p class="image"><img src="images/000192.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">using an arctangent algorithm and finally add θ<sub class="calibre12">1st</sub> to −π/2 to obtain our desired value for θ.</p>
<p class="calibre3">OK, here’s the neat part of this trick. We don’t actually have to perform any of the above vector rotations to obtain angle θ<sub class="calibre12">1st</sub>. We merely need to find the signs of the original <em class="calibre7">I</em> and <em class="calibre7">Q</em> components and determine which component has the larger magnitude. With those three pieces of information we determine in which octant vector <em class="calibre7">C</em> is located by using <a href="#calibre_link-990">Table 13-9</a>.</p>
<p class="caption"><a id="calibre_link-990"></a><strong class="calibre9">Table 13-9</strong> Octant Identification</p>
<p class="image"><img src="images/000387.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Once we know vector <em class="calibre7">C</em>‘s octant, we take advantage of the following <em class="calibre7">rotational symmetries</em> of arctangents</p>
<p class="caption"><a id="calibre_link-3377"></a>(13-156)</p>
<p class="image"><img src="images/000102.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-3378"></a>(13-156′)</p>
<p class="image"><img src="images/000713.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">and compute our desired θ value using the appropriate expression in <a href="#calibre_link-991">Table 13-10</a>.</p>
<p class="caption"><a id="calibre_link-991"></a><strong class="calibre9">Table 13-10</strong> Arctan Computation</p>
<p class="image"><img src="images/001238.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Given that this arctangent process is implemented with programmable hardware, we’ll have <a href="#calibre_link-991">Table 13-10</a>’s four different arctangent approximation routines located at four different memory locations to which we’ll <em class="calibre7">jump</em>. The process to determine the necessary two <em class="calibre7">jump address</em> index bits (b<sub class="calibre12">1</sub>,b<sub class="calibre12">0</sub>) based on vector <em class="calibre7">C</em>‘s octant is shown in <a href="#calibre_link-992">Figure 13-95</a>.</p>
<p class="caption"><a id="calibre_link-992"></a><strong class="calibre9">Figure 13-95</strong> Octant and jump address identification flow.</p>
<p class="image"><img src="images/001028.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2464"></a>To avoid division by zero when using the algorithms in <a href="#calibre_link-991">Table 13-10</a>, it’s prudent to precede the <a href="#calibre_link-992">Figure 13-95</a> processing with <em class="calibre7">checking</em> to see if <em class="calibre7">I</em> or <em class="calibre7">Q</em> is zero:</p>
<p class="indenthangingb">• If <em class="calibre7">I</em> = 0, θ is set to π/2 or −π/2 depending on the sign of <em class="calibre7">Q</em>.</p>
<p class="indenthangingb">• If <em class="calibre7">Q</em> = 0, θ is set to 0 or π depending on the sign of <em class="calibre7">I</em>.</p>
<p class="indenthangingb">• If <em class="calibre7">I</em> and <em class="calibre7">Q</em> are both zero, set θ to 0.</p>
<p class="calibre3">Again, this section does not present any specific arctangent algorithms. This material shows how to make a given arctangent algorithm more accurate.</p>
<p class="calibre3"><a id="calibre_link-3379"></a></p>
<h4 class="calibre13"><a id="calibre_link-2466"></a>13.38.2 Vector Rotation by ±π/8</h4>
<p class="calibre3">While we’re on the subject of vector rotation, if a 1st-octant vector <em class="calibre7">C</em><sub class="calibre12">1st</sub> resides in the angle range of π/8 ≤ θ<sub class="calibre12">1st</sub> ≤ π/4 radians (Range 1 in <a href="#calibre_link-993">Figure 13-96(a)</a>, 22.5° ≤ θ<sub class="calibre12">1st</sub> ≤ 45°), we can rotate that vector by −π/8 radians (−22.5°), forcing the new vector into Region 2. We may want to perform this rotation because arctangent algorithms have improved accuracy in Region 2.</p>
<p class="caption"><a id="calibre_link-993"></a><strong class="calibre9">Figure 13-96</strong> Angle ranges of the 1st and 8th octants.</p>
<p class="image"><img src="images/000080.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">We rotate a vector <em class="calibre7">C</em><sub class="calibre12">1st</sub> = <em class="calibre7">I</em><sub class="calibre12">1st</sub> + <em class="calibre7">jQ</em><sub class="calibre12">1st</sub> residing in Range 1 to Range 2 by multiplying <em class="calibre7">C</em><sub class="calibre12">1st</sub> by the complex number e<sup class="calibre10">−<em class="calibre7">j</em>π/8</sup> = (<em class="calibre7">A</em> −<em class="calibre7">jB</em>), where</p>
<p class="caption"><a id="calibre_link-3380"></a>(13-157)</p>
<p class="image"><img src="images/000930.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">We can simplify the complex multiply by dividing <em class="calibre7">A</em> and <em class="calibre7">B</em> by 0.923879, yielding</p>
<p class="caption"><a id="calibre_link-3381"></a>(13-158)</p>
<p class="image"><img src="images/001793.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">This gives us a new (<em class="calibre7">A</em>′ −<em class="calibre7">jB</em>′) = (1 −<em class="calibre7">j</em>0.414213) multiplier, reducing the number of necessary real multiplies in this −π/8 rotation process<a href="#calibre_link-994">[88]</a>. However, be aware that this (<em class="calibre7">A</em>′ −<em class="calibre7">jB</em>′) rotation induces a vector magnitude gain of 1.0824 (0.69 dB) in the rotated vector.</p>
<p class="calibre3">Here’s how we decide if the 1st-octant vector <em class="calibre7">C</em><sub class="calibre12">1st</sub> lies in the Range 1 of π/8 ≤ θ<sub class="calibre12">1st</sub> ≤ π/4 radians. If the minimum of <em class="calibre7">I</em><sub class="calibre12">1st</sub> or <em class="calibre7">Q</em><sub class="calibre12">1st</sub> is less than 0.414213 times the maximum of <em class="calibre7">I</em><sub class="calibre12">1st</sub> or <em class="calibre7">Q</em><sub class="calibre12">1st</sub>, then <em class="calibre7">C</em><sub class="calibre12">1st</sub> lies in Region 1, in which case vector rotation by (<em class="calibre7">A</em>′ −<em class="calibre7">jB</em>′) multiplication is performed. Otherwise the 1st-octant vector is in Range 2, requiring no rotation.</p>
<p class="calibre3"><a id="calibre_link-2152"></a>In a similar manner, if an 8th-octant vector <em class="calibre7">C</em><sub class="calibre12">8th</sub> resides in the angle range of −π/4 ≤ θ<sub class="calibre12">8th</sub> ≤ −π/8 radians (Range 4 in <a href="#calibre_link-993">Figure 13-96(b)</a>), we can rotate that vector by π/8 radians (22.5°), forcing the new vector into Region 3 by multiplying <em class="calibre7">C</em><sub class="calibre12">8th</sub> by (<em class="calibre7">A</em>′ + <em class="calibre7">jB</em>′).</p>
<p class="calibre3">Again, the angle range reduction schemes in this section allow us to use arctangent algorithms that are computationally simpler (and thus faster) for a given accuracy. Of course, this technique forces us to perform additional angle range checking and to compute products such as (<em class="calibre7">I</em><sub class="calibre12">1st</sub> + <em class="calibre7">jQ</em><sub class="calibre12">1st</sub>)(<em class="calibre7">A</em>′ −<em class="calibre7">jB</em>′). Perhaps this scheme is most useful when used with an arctangent look-up table method. You make the call.</p>
<p class="calibre3"><a id="calibre_link-706"></a></p>
<h3 class="calibre6">13.39 An Efficient Differentiating Network</h3>
<p class="calibre3">This section presents a computationally efficient differentiating network that approximates the process of taking the derivative of a discrete time-domain sequence. In <a href="#calibre_link-187">Chapter 7</a> we introduced the <em class="calibre7">central-difference</em> differentiator, defined by</p>
<p class="caption"><a id="calibre_link-3382"></a>(13-159)</p>
<p class="image"><img src="images/000817.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">as a simple differentiating network that has desirable high-frequency (noise) attenuation behavior. The frequency magnitude response of that differentiator is the dashed |<em class="calibre7">H</em><sub class="calibre12">Cd</sub>(<em class="calibre7">f</em>)| curve in <a href="#calibre_link-995">Figure 13-97(a)</a>. (For comparison, we show an ideal differentiator’s straight-line |<em class="calibre7">H</em><sub class="calibre12">Ideal</sub>(<em class="calibre7">f</em>)| magnitude response in <a href="#calibre_link-995">Figure 13-97(a)</a>. The frequency axis in that figure covers the positive-frequency range 0≤ω≤π samples/radian, corresponding to a continuous-time frequency range of 0 to <em class="calibre7">f<sub class="calibre12">s</sub></em>/2, where <em class="calibre7">f<sub class="calibre12">s</sub></em> is the input sample rate in Hz.) The central-difference differentiator’s frequency range of linear operation is from zero to roughly 0.08<em class="calibre7">f<sub class="calibre12">s</sub></em> Hz.</p>
<p class="caption"><a id="calibre_link-995"></a><strong class="calibre9">Figure 13-97</strong> Proposed differentiator: (a) performance; (b) standard structure; (c) folded structure.</p>
<p class="image"><img src="images/000924.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Here we recommend a computationally efficient differentiator that maintains the central-difference differentiator’s beneficial high-frequency attenuation behavior but extends its frequency range of linear operation. The proposed differentiator is defined by</p>
<p class="caption"><a id="calibre_link-996"></a>(13-160)</p>
<p class="image"><img src="images/000697.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The <a href="#calibre_link-996">Eq. (13-160)</a> differentiator’s frequency magnitude response is the solid |<em class="calibre7">H</em><sub class="calibre12">Pr</sub>(<em class="calibre7">f</em>)| curve in <a href="#calibre_link-995">Figure 13-97(a)</a>, where its frequency range of linear operation extends from zero to approximately 0.17<em class="calibre7">f<sub class="calibre12">s</sub></em> Hz, roughly twice the usable frequency range of the central-difference differentiator. The differentiator in <a href="#calibre_link-996">Eq. (13-160)</a> has a gain greater than that of the central-difference differentiator, so the solid curve in <a href="#calibre_link-995">Figure 13-97(a)</a> was scaled for easy comparison of |<em class="calibre7">H</em><sub class="calibre12">cd</sub>(<em class="calibre7">f</em>)| and |<em class="calibre7">H</em><sub class="calibre12">dif</sub>(<em class="calibre7">f</em>)|. The |<em class="calibre7">H</em><sub class="calibre12">dif</sub>(<em class="calibre7">f</em>)| curve is the DFT of 0.6 · <em class="calibre7">y</em><sub class="calibre12">dif</sub>(<em class="calibre7">n</em>).</p>
<p class="calibre3"><a id="calibre_link-3383"></a>The structure of the proposed differentiator is shown in <a href="#calibre_link-995">Figure 13-97(b)</a> where a delay block comprises two unit-delay elements. The <em class="calibre7">folded</em>-FIR structure for this differentiator is presented in <a href="#calibre_link-995">Figure 13-97(c)</a> where only a single multiply need be performed per <em class="calibre7">y</em><sub class="calibre12">Pr</sub>(<em class="calibre7">n</em>) output sample. The really slick aspect of the <em class="calibre7">y</em><sub class="calibre12">Pr</sub>(<em class="calibre7">n</em>) differentiator is that its non-unity coefficients (±1/16) are integer powers of two. This means that a multiplication in <a href="#calibre_link-995">Figure 13-97</a> can be implemented with an arithmetic right shift by four bits. Happily, such a binary right-shift implementation is a linear-phase multiplierless differentiator.</p>
<p class="calibre3">Another valuable feature of the <em class="calibre7">y</em><sub class="calibre12">Pr</sub>(<em class="calibre7">n</em>) differentiator is that its time delay (group delay) is exactly three samples. Such an integer delay makes this differentiator convenient for use when the <em class="calibre7">y</em><sub class="calibre12">pr</sub>(<em class="calibre7">n</em>) output must be time-synchronized with other signals within a system. For fairness, we point out that the disadvantage of this very efficient differentiator is that for proper operation its <em class="calibre7">x</em>(<em class="calibre7">n</em>) input signals must be low frequency, less than one-fifth the input sample rate.</p>
<p class="calibre3"><a id="calibre_link-2102"></a>In terms of performance and computational efficiency, the only contender to the proposed differentiator is the first narrowband “super Lanczos low-noise differentiator” discussed in <a href="#calibre_link-187">Chapter 7</a>. However, the <em class="calibre7">y</em><sub class="calibre12">Pr</sub>(<em class="calibre7">n</em>) differentiator proposed here has better high-frequency noise attenuation than the Lanczos differentiator.</p>
<p class="calibre3"><a id="calibre_link-707"></a></p>
<h3 class="calibre6">13.40 Linear-Phase DC-Removal Filter</h3>
<p class="calibre3">In this section we introduce a linear-phase DC-removal filter useful for removing the DC bias from a time-domain signal. The filter is based on the notion of subtracting an input signal’s moving average (DC bias) from that signal, as shown in <a href="#calibre_link-997">Figure 13-98(a)</a>.</p>
<p class="caption"><a id="calibre_link-997"></a><strong class="calibre9">Figure 13-98</strong> DC-removal filter: (a) filter concept; (b) filter structure; (c) filter frequency response.</p>
<p class="image"><img src="images/001786.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">In order to reduce the delay line length of a standard tapped-delay line moving average network, we use the <em class="calibre7">D</em>-point recursive moving averager (MA), shown in <a href="#calibre_link-997">Figure 13-98(b)</a>. The bottom path, in <a href="#calibre_link-997">Figure 13-98(b)</a>, is a simple delay line having a length equal to the averager’s group delay, (<em class="calibre7">D</em>−1)/2 samples. This enables us to time-synchronize the averager’s <em class="calibre7">v</em>(<em class="calibre7">n</em>) output with the <em class="calibre7">x</em>(<em class="calibre7">n</em>) input in preparation for the subtraction operation. There are two delay lines in <a href="#calibre_link-997">Figure 13-98(b)</a>: the <em class="calibre7">D</em>-length <em class="calibre7">z</em><sup class="calibre10">−<em class="calibre7">D</em></sup> delay line in the top path and the bottom path’s (<em class="calibre7">D</em>−1)/2-length delay line.</p>
<p class="calibre3"><a id="calibre_link-3384"></a>The <em class="calibre7">D</em>-point recursive moving averager (MA) in <a href="#calibre_link-997">Figure 13-98(b)</a> has a transfer function defined by</p>
<p class="caption"><a id="calibre_link-3385"></a>(13-161)</p>
<p class="image"><img src="images/001433.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">This DC-removal network’s passband performance, when <em class="calibre7">D</em> = 31, is shown in <a href="#calibre_link-997">Figure 13-98(c)</a>. (The frequency axis value of 0.5 corresponds to a cyclic frequency of half the input signal’s <em class="calibre7">f</em><sub class="calibre12">s</sub> sample rate.) While the network has the desired infinite attenuation at zero Hz, its passband peak-peak ripple is unpleasantly large at 2.9 dB. We can do better, as we shall see.</p>
<p class="calibre3">If <em class="calibre7">D</em> is an integer power of two, the 1/<em class="calibre7">D</em> scaling in (1) can be performed using a binary right shift by log<sub class="calibre12">2</sub>(<em class="calibre7">D</em>) bits, making <a href="#calibre_link-997">Figure 13-98(b)</a> a multiplier-free network. However, in that scenario the MA’s group delay is not an integer number of samples, making it difficult to synchronize the delayed <em class="calibre7">x</em>(<em class="calibre7">n</em>) and the <em class="calibre7">v</em>(<em class="calibre7">n</em>) sequences. To solve this problem we can use two cascaded <em class="calibre7">D</em>-point MAs as shown in <a href="#calibre_link-998">Figure 13-99(a)</a>. Because the cascaded MAs have an integer group delay of <em class="calibre7">D</em>−1 samples, we can be clever and tap off the first moving averager’s comb delay line, eliminating the bottom-path delay line in <a href="#calibre_link-997">13-98(b)</a>. This way we still only need implement two delay lines in <a href="#calibre_link-998">Figure 13-99(a)</a>, one <em class="calibre7">z</em><sup class="calibre10">−<em class="calibre7">D</em></sup> delay line in each MA.</p>
<p class="caption"><a id="calibre_link-998"></a><strong class="calibre9">Figure 13-99</strong> Dual-MA filter: (a) filter structure; (b) filter frequency response.</p>
<p class="image"><img src="images/000812.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The magnitude response of the <a href="#calibre_link-998">Figure 13-99(a)</a> dual-MA DC-removal network, for <em class="calibre7">D</em> = 32, is shown in <a href="#calibre_link-998">Figure 13-99(b)</a>. In that figure we show the DC-removal filter’s passband with its narrower transition region width and a much improved peak-peak ripple of 0.42 dB. What we’ve created, then, is a <a id="calibre_link-3386"></a>linear-phase, multiplierless, DC-removal network having a narrow transition region near zero Hz.</p>
<p class="calibre3">Happily, it’s worth noting that standard tapped-delay line, linear-phase, highpass FIR filter designs using least-squares error minimization, or the Parks-McClellan method, require more than 100 taps to approximate our <em class="calibre7">D</em> = 32 DC-removal filter’s performance.</p>
<p class="calibre3">On a practical note, the MAs in <a href="#calibre_link-998">Figure 13-99(a)</a> contain integrators that can experience data overflow. (An integrator’s gain is infinite at DC.) Using two’s complement fixed-point arithmetic avoids integrator overflow errors if we ensure that the integrator (accumulator) bit width is at least</p>
<p class="caption"><a id="calibre_link-3387"></a>(13-162)</p>
<p class="image"><img src="images/000581.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where <em class="calibre7">q</em>(<em class="calibre7">n</em>) is the input sequence to an accumulator, and <img src="images/001460.jpg" alt="image" class="calibre2" /> means that if <em class="calibre7">k</em> is not an integer, round it up to the next larger integer.</p>
<p class="calibre3">For an even narrower filter transition region width, in the vicinity of zero Hz, than that shown in <a href="#calibre_link-998">Figure 13-99(b)</a>, we can set <em class="calibre7">D</em> to a larger integer power of two; however, this will not reduce the DC-removal filter’s passband ripple.</p>
<p class="calibre3">At the expense of three additional delay lines, and four new addition operations per output sample, we can implement the linear-phase DC-removal filter shown in <a href="#calibre_link-999">Figure 13-100(a)</a>. That quad-MA implementation, having a group delay of 2<em class="calibre7">D</em>−2 samples, yields an improved passband peak-peak ripple of only 0.02 dB, as shown in <a href="#calibre_link-999">Figure 13-100(b)</a>, as well as a reduced-width transition region relative to the dual-MA implementation.</p>
<p class="caption"><a id="calibre_link-999"></a><strong class="calibre9">Figure 13-100</strong> Quad-MA filter: (a) filter structure; (b) filter frequency response.</p>
<p class="image"><img src="images/001546.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The DC removal network in <a href="#calibre_link-999">Figure 13-100(a)</a> contains four 1/<em class="calibre7">D</em> scaling operations which, of course, can be combined and implemented as a single binary right shift by 4log2(<em class="calibre7">D</em>) bits. So the bottom line here is that at the expense <a id="calibre_link-2351"></a>of multiple delay lines, it is possible to efficiently perform linear-phase DC removal.</p>
<p class="calibre3"><a id="calibre_link-708"></a></p>
<h3 class="calibre6">13.41 Avoiding Overflow in Magnitude Computations</h3>
<p class="calibre3">Here we present a little trick to help avoid a common problem when computing the magnitude of a complex number using fixed-point binary number formats. Let’s say we have a complex number <em class="calibre7">c</em> represented by <em class="calibre7">c</em> = <em class="calibre7">R</em> + <em class="calibre7">jI</em>, and we want to compute the magnitude <em class="calibre7">c</em> using the familiar expression</p>
<p class="caption"><a id="calibre_link-1000"></a>(13-163)</p>
<p class="image"><img src="images/001442.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a href="#calibre_link-1000">Equation (13-163)</a> is troublesome because the <em class="calibre7">R</em><sup class="calibre10">2</sup> and <em class="calibre7">I</em><sup class="calibre10">2</sup> terms will cause data word overflow errors if either <em class="calibre7">R</em> or <em class="calibre7">I</em> is greater than the square root of your fixed-point number format’s largest positive number. For example, in a signed 16-bit number format, |<em class="calibre7">R</em>| and |<em class="calibre7">I</em>| must be less than 181 to avoid overflow errors. At the expense of absolute value comparison, branch, and divide operations, <a href="#calibre_link-1001">Eq. (13-164)</a> alleviates overflow problems<a href="#calibre_link-1002">[89]</a>:</p>
<p class="caption"><a id="calibre_link-1001"></a>(13-164)</p>
<p class="image"><img src="images/000929.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-709"></a></p>
<h3 class="calibre6">13.42 Efficient Linear Interpolation</h3>
<p class="calibre3">In this section we present a computationally efficient linear interpolation trick that’s useful because it performs linear interpolation requiring at most one multiply per output sample<a href="#calibre_link-1003">[90]</a>. For example, given the <em class="calibre7">x</em>(<em class="calibre7">n</em>) time sequence in <a href="#calibre_link-1004">Figure 13-101(a)</a>, this linear interpolator will generate the <em class="calibre7">y</em>(<em class="calibre7">n</em>) sequence shown in <a href="#calibre_link-1004">Figure 13-101(b)</a> when the interpolation factor is <em class="calibre7">L</em> = 3. Notice how the original <em class="calibre7">x</em>(<em class="calibre7">n</em>) samples are preserved in the <em class="calibre7">y</em>(<em class="calibre7">n</em>) output sequence.</p>
<p class="caption"><a id="calibre_link-1004"></a><strong class="calibre9">Figure 13-101</strong> Linear interpolation: (a) input sequence; (b) <em class="calibre7">L</em> = 3 interpolated sequence; (c) interpolator structure.</p>
<p class="image"><img src="images/000363.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The block diagram of this efficient linear interpolator is that in <a href="#calibre_link-1004">Figure 13-101(c)</a>. That mysterious block labeled “Hold Interpolator, <em class="calibre7">L</em>” is merely the operation where each input sample to the block is repeated <em class="calibre7">L</em>−1 times. For example, if the input to the Hold Interpolator operation is {1,4,3}, and <em class="calibre7">L</em> = 3, the output of the Hold Interpolator is {1,1,1,4,4,4,3,3,3}.</p>
<p class="calibre3">In fixed-point binary implementations if we’re able to select <em class="calibre7">L</em> to be an integer power of two, then, happily, the final 1/<em class="calibre7">L</em> multiplication can be implemented with a binary arithmetic right shift by log<sub class="calibre12">2</sub><em class="calibre7">L</em> bits, yielding a multiplierless linear interpolator. Of course, if a gain of <em class="calibre7">L</em> is acceptable, no 1/<em class="calibre7">L</em> scaling need be performed at all.</p>
<p class="calibre3"><a id="calibre_link-3388"></a>The neat part of this interpolator is that the computational workload, the number of additions and multiplies per output sample, remains fixed regardless of the value of interpolation factor <em class="calibre7">L</em>.</p>
<p class="calibre3">The experienced reader might now say, “Ah, while this network is computationally simple, linear interpolation is certainly not the most accurate method of interpolation, particularly for large interpolation factors of <em class="calibre7">L</em>.” That is true, but if interpolation is being done in multiple sections, using this efficient linear interpolation as the final section at the highest data rate (when the signal samples are already very close together) will introduce only a small interpolation error.</p>
<p class="calibre3"><a id="calibre_link-710"></a></p>
<h3 class="calibre6">13.43 Alternate Complex Down-conversion Schemes</h3>
<p class="calibre3">Here we present two interesting complex down-conversion and decimation techniques used to generate an analytic (complex) version, centered at zero Hz, of a real bandpass signal that was originally centered at ±<em class="calibre7">f<sub class="calibre12">s</sub></em>/4 (one-fourth the sample rate). Both methods perform signal frequency translation by way of decimation.</p>
<p class="calibre3"><a id="calibre_link-3389"></a></p>
<h4 class="calibre13"><a id="calibre_link-2168"></a>13.43.1 Half-band Filter Down-conversion</h4>
<p class="calibre3">The first complex down-conversion method makes use of computationally efficient half-band filters<a href="#calibre_link-1005">[91]</a>. The process is shown in <a href="#calibre_link-1006">Figure 13-102(a)</a>, where we use indices <em class="calibre7">n</em>, <em class="calibre7">p</em>, and <em class="calibre7">m</em> to clarify the multirate nature of this process. The real <em class="calibre7">x</em><sub class="calibre12">R</sub>(<em class="calibre7">n</em>) input signal has the spectrum shown in <a href="#calibre_link-1006">Figure 13-102(b)</a>, and for our example the sample rate is <em class="calibre7">f<sub class="calibre12">s</sub></em> = 24 kHz. The Delay/Hilbert transform filter combination attenuates the negative-frequency spectral components of <em class="calibre7">X</em><sub class="calibre12">R</sub>(<em class="calibre7">f</em>) to produce the complex <em class="calibre7">u</em><sub class="calibre12">I</sub>(<em class="calibre7">n</em>) + <em class="calibre7">ju</em><sub class="calibre12">Q</sub>(<em class="calibre7">n</em>) signal whose spectrum is provided in <a href="#calibre_link-1006">Figure 13-102(c)</a>. (The Delay function is a cascade of unit-delay elements, whose length is the group delay of the Hilbert filter, needed to time-synchronize the <em class="calibre7">u</em><sub class="calibre12">I</sub>(<em class="calibre7">n</em>) and <em class="calibre7">u</em><sub class="calibre12">Q</sub>(<em class="calibre7">n</em>) sequences.) The follow-on downsample by two, discard every other sample, produces the complex <em class="calibre7">v</em>(<em class="calibre7">p</em>) sequence having the spectrum shown in <a href="#calibre_link-1006">Figure 13-102(d)</a> where the new sample rate is 12 kHz.</p>
<p class="caption"><a id="calibre_link-1006"></a><strong class="calibre9">Figure 13-102</strong> Analytic signal generation and decimation by two.</p>
<p class="image"><img src="images/000983.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Next, sequences <em class="calibre7">v</em><sub class="calibre12">I</sub>(<em class="calibre7">p</em>) and <em class="calibre7">v</em><sub class="calibre12">Q</sub>(<em class="calibre7">p</em>) are applied to two identical real-valued highpass half-band filters, each having the frequency magnitude response <a id="calibre_link-2170"></a>shown in <a href="#calibre_link-1007">Figure 13-103(a)</a>, yielding the complex <em class="calibre7">w</em>(<em class="calibre7">p</em>) = <em class="calibre7">w</em><sub class="calibre12">I</sub>(<em class="calibre7">p</em>) and <em class="calibre7">w</em><sub class="calibre12">Q</sub>(<em class="calibre7">p</em>) whose spectrum is that in <a href="#calibre_link-1007">Figure 13-103(b)</a>. The final step in this down-conversion process is another decimation by two, producing the desired <em class="calibre7">x</em><sub class="calibre12">c</sub>(<em class="calibre7">m</em>) sequence having the spectrum given in <a href="#calibre_link-1007">Figure 13-103(c)</a> where the output sample rate is 6 kHz. Due to the nature of half-band filters there will be some amount of spectral overlap in <em class="calibre7">X</em><sub class="calibre12">c</sub>(<em class="calibre7">f</em>) as shown in <a href="#calibre_link-1007">Figure 13-103(c)</a>. The amount of spectral overlap is proportional to the transition region width of an <em class="calibre7">h</em><sub class="calibre12">hp</sub>(<em class="calibre7">k</em>) filter (inversely proportional to the number of filter taps).</p>
<p class="caption"><a id="calibre_link-1007"></a><strong class="calibre9">Figure 13-103</strong> Highpass filtering, down-conversion, and decimation by two.</p>
<p class="image"><img src="images/001618.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">There are three useful aspects to this first complex down-conversion scheme that enhance its computational efficiency:</p>
<p class="indenthangingb">• If the Hilbert transform filter has an odd number of taps, roughly half of its coefficients will be zero-valued, and the Delay function is an integer number of unit-delay elements.</p>
<p class="indenthangingb">• Roughly half of the coefficients of the highpass half-band filters, with their transition regions centered at <em class="calibre7">f<sub class="calibre12">s</sub></em>/4 and 3<em class="calibre7">f<sub class="calibre12">s</sub></em>/4, will be zero-valued.</p>
<p class="indenthangingb">• Because the coefficients of the filters in <a href="#calibre_link-1006">Figure 13-102(a)</a> are either symmetrical or antisymmetrical, we can use the <em class="calibre7">folded</em> FIR filter scheme described in <a href="#calibre_link-148">Section 13.7</a> to reduce the number of multipliers by another factor of two.</p>
<p class="calibre3"><a id="calibre_link-3390"></a></p>
<h4 class="calibre13"><a id="calibre_link-2169"></a>13.43.2 Efficient Single-Decimation Down-conversion</h4>
<p class="calibre3">Our second complex down-conversion trick is a very computationally efficient scheme, shown in <a href="#calibre_link-1008">Figure 13-104(a)</a>, that operates on real <em class="calibre7">x</em><sub class="calibre12">R</sub>(<em class="calibre7">n</em>) signals centered at ±<em class="calibre7">f<sub class="calibre12">s</sub></em>/4. Just as in <a href="#calibre_link-1006">Figure 13-102(a)</a>, the Delay/Hilbert transform filter combination attenuates the negative-frequency spectral components of <em class="calibre7">x</em><sub class="calibre12">R</sub>(<em class="calibre7">n</em>) to produce a complex analytic signal whose spectrum is centered at <em class="calibre7">f<sub class="calibre12">s</sub></em>/4 (6 kHz). The downsample-by-four, retain every fourth sample, operation down-converts (frequency translates) the desired complex signal originally centered at <em class="calibre7">f<sub class="calibre12">s</sub></em>/4 Hz down to a center frequency of zero Hz. The compensation filter is used to compensate for the non-flat frequency magnitude response of the simple 2-tap Hilbert filter in order to widen the down-converter’s usable passband width. (The Delay function after the downsampling in the top path is needed to time-synchronize the <em class="calibre7">x</em><sub class="calibre12">I</sub>(<em class="calibre7">m</em>) and <em class="calibre7">x</em><sub class="calibre12">Q</sub>(<em class="calibre7">m</em>) sequences.) The detailed block diagram of the down-converter is shown in <a href="#calibre_link-1008">Figure 13-104(b)</a>, where the compensation filter’s coefficients are <em class="calibre7">h</em><sub class="calibre12">c</sub>(0) = −1/32, and <em class="calibre7">h</em><sub class="calibre12">c</sub>(1) = 1/2 + 1/16.</p>
<p class="caption"><a id="calibre_link-1008"></a><strong class="calibre9">Figure 13-104</strong> High-efficiency complex down-conversion: (a) process; (b) detailed structure.</p>
<p class="image"><img src="images/000042.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2122"></a>If the <em class="calibre7">x</em><sub class="calibre12">R</sub>(<em class="calibre7">n</em>) input signal’s bandwidth is no greater than <em class="calibre7">f<sub class="calibre12">s</sub></em>/6, then the Hilbert filter attenuates <em class="calibre7">x</em><sub class="calibre12">R</sub>(<em class="calibre7">n</em>)’s undesired negative-frequency spectral components, at the <em class="calibre7">x</em><sub class="calibre12">c</sub>(<em class="calibre7">n</em>) output, by approximately 35 dB. That much attenuation may not be something to write home about, but keep in mind that this down-converter requires no multipliers because the multiplies by the <em class="calibre7">h</em><sub class="calibre12">c</sub>(0) and <em class="calibre7">h</em><sub class="calibre12">c</sub>(1) coefficients can be implemented with binary shifts and adds. At the expense of two multiplies per output sample, the compensation filter coefficients can be set to <em class="calibre7">h</em><sub class="calibre12">c</sub>(0) = −0.02148 and <em class="calibre7">h</em><sub class="calibre12">c</sub>(1) = 0.54128 to attenuate <em class="calibre7">x</em><sub class="calibre12">R</sub>(<em class="calibre7">n</em>)’s undesired negative-frequency spectral components by roughly 45 dB.</p>
<p class="calibre3"><a id="calibre_link-711"></a></p>
<h3 class="calibre6">13.44 Signal Transition Detection</h3>
<p class="calibre3">When we are tasked to build a system that must detect transitions in a pulsed signal, we generally look to a digital differentiator as the solution to our problem. However, when a pulsed signal’s transition spans many samples, and particularly if the signal is noisy, digital differentiators do not provide reliable signal transition detection. One compelling solution to this problem uses a standard tapped-delay line (time-domain convolution) filtering scheme developed by C. Turner<a href="#calibre_link-1009">[92]</a>. Called <em class="calibre7">time-domain slope filtering,</em> the transition detection tapped-delay line filter uses <em class="calibre7">N</em> coefficients defined by</p>
<p class="caption"><a id="calibre_link-1011"></a>(13-165)</p>
<p class="image"><img src="images/001339.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where the coefficient index <em class="calibre7">k</em> covers the range 0 ≤ <em class="calibre7">k</em> ≤ <em class="calibre7">N</em>−1.</p>
<p class="calibre3">For any integer <em class="calibre7">N</em>, the slope filtering <em class="calibre7">C<sub class="calibre12">k</sub></em> coefficients comprise a linear ramp, making that sequence quite useful for detecting linear transitions in an input signal. <a href="#calibre_link-1010">Figure 13-105(a)</a> shows the output of the time-domain slope filtering process, when <em class="calibre7">N</em> = 53. In that figure we see that the slope filter performs well in detecting the transitions of the Input signal. The dotted curve in <a href="#calibre_link-1010">Figure 13-105(a)</a> is the output of a traditional tapped-delay line digital differentiator having 53 taps. (The frequency magnitude of the traditional digital differentiator, specifically designed to attenuate high-frequency noise, is provided in <a href="#calibre_link-1010">Figure 13-105(b)</a>.)</p>
<p class="caption"><a id="calibre_link-1010"></a><strong class="calibre9">Figure 13-105</strong> Time-domain slope filtering: (a) pulsed input performance; (b) digital differentiator magnitude response; (c) high-noise input performance.</p>
<p class="image"><img src="images/001054.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The superiority of the time-domain slope filtering scheme over traditional differentiation is further illustrated in <a href="#calibre_link-1010">Figure 13-105(c)</a> where the pulsed Input signal is contaminated with high-level noise.</p>
<p class="calibre3">Concerning two practical issues, if the number of samples in a pulsed input signal’s transition is <em class="calibre7">L,</em> the value for <em class="calibre7">N</em>, found empirically, is generally in the range of <em class="calibre7">L</em>/4 to <em class="calibre7">L</em>. It’s convenient to set <em class="calibre7">N</em> to be an odd integer, forcing the filter’s delay to be an integer number, (<em class="calibre7">N</em>−1)/2, of samples. This facilitates the time synchronization of the filter’s output to other sequences in a system. <a id="calibre_link-2439"></a>Also, if the <em class="calibre7">C<sub class="calibre12">k</sub></em> coefficients are to be used in correlation processing (as opposed to the convolution processing discussed above), the correlation’s <em class="calibre7">C<sub class="calibre12">k</sub></em> coefficients should be the coefficients from <a href="#calibre_link-1011">Eq. (13-165)</a> reversed in time order.</p>
<p class="calibre3"><a id="calibre_link-712"></a></p>
<h3 class="calibre6">13.45 Spectral Flipping around Signal Center Frequency</h3>
<p class="calibre3">In <a href="#calibre_link-586">Section 2.4</a>, we discussed a super-simple method of spectral flipping (spectral inversion) of a real signal where the center of spectral rotation was <em class="calibre7">f<sub class="calibre12">s</sub></em>/4. In this section we discuss a different kind of spectral flipping process.</p>
<p class="calibre3"><a id="calibre_link-3391"></a>Consider the situation where we need to process a real-valued <em class="calibre7">x</em>(<em class="calibre7">n</em>) time signal, whose <em class="calibre7">X</em>(<em class="calibre7">f</em>) spectrum is shown in <a href="#calibre_link-1012">Figure 13-106(a)</a>, to obtain a real-valued <em class="calibre7">y</em>(<em class="calibre7">n</em>) time signal whose spectrum is the flipped <em class="calibre7">Y</em>(<em class="calibre7">f</em>) spectrum shown in <a href="#calibre_link-1012">Figure 13-106(b)</a>. Notice that the center of rotation of the desired spectral flipping is not <em class="calibre7">f<sub class="calibre12">s</sub></em>/4 Hz but is instead the <em class="calibre7">x</em>(<em class="calibre7">n</em>) signal’s <em class="calibre7">f</em><sub class="calibre12">c</sub> center frequency. The spectral flipping process described in <a href="#calibre_link-586">Section 2.4</a> does not solve our problem because that process would result in the undesirable spectrum shown in <a href="#calibre_link-1012">Figure 13-106(c)</a>, where the original <em class="calibre7">X</em>(<em class="calibre7">f</em>) spectrum is the dashed curve.</p>
<p class="caption"><a id="calibre_link-1012"></a><strong class="calibre9">Figure 13-106</strong> Spectral flipping, centered at <em class="calibre7">f</em><sub class="calibre12">c</sub>: (a) original spectrum; (b) desired spectrum; (c) incorrect spectrum.</p>
<p class="image"><img src="images/001695.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">There are two methods to solve our <em class="calibre7">f</em><sub class="calibre12">c</sub>-centered spectral flipping problem. <a href="#calibre_link-1013">Figure 13-107(a)</a> shows the first method, comprising a multirate processing technique. In considering this spectral flipping method, the user should keep in mind that:</p>
<p class="indenthangingb">• The two lowpass filters (LPFs) have passbands that extend from zero Hz to <em class="calibre7">f</em><sub class="calibre12">H</sub> Hz. (Note that the sample rate for both filters is 2<em class="calibre7">f<sub class="calibre12">s</sub></em> Hz.) The second LFP’s transition region width is less than 2<em class="calibre7">f</em><sub class="calibre12">L</sub>.</p>
<p class="indenthangingb">• The cosine mixing sequence uses the upsampled-by-two time index variable <em class="calibre7">n</em>′.</p>
<p class="indenthangingb">• The multiply-by-four operation compensates for the sequence <em class="calibre7">u</em>(<em class="calibre7">n</em>′) amplitude loss by a factor of two caused by interpolation, and the amplitude loss by another factor of two due to the cosine mixing.</p>
<p class="caption"><a id="calibre_link-1013"></a><strong class="calibre9">Figure 13-107</strong> Spectral flipping techniques: (a) first method; (b) second method.</p>
<p class="image"><img src="images/000022.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Of course, a smart engineer will eliminate the multiply-by-four operation altogether by increasing the DC (zero Hz) gain of one of the lowpass filters by four.</p>
<p class="calibre3">The second method we could use to obtain a signal having the desired <a href="#calibre_link-1012">Figure 13-106(b)</a> spectrum, promoted by D. Bell, is the process shown in <a href="#calibre_link-1013">Figure 13-107(b)</a><a href="#calibre_link-1014">[93]</a>. <a id="calibre_link-2378"></a>While somewhat more computationally intensive than the above multirate method, this technique works well and deserves mention here. The first complex multiplication and the Complex LPF are identical to the quadrature sampling operations we discussed in <a href="#calibre_link-412">Figure 8-18(a)</a>. The two identical lowpass filters, comprising the Complex LPF, have passbands that extend from zero Hz to (<em class="calibre7">f</em><sub class="calibre12">H</sub>−<em class="calibre7">f</em><sub class="calibre12">L</sub>)/2 Hz, and transition region widths of less than 2<em class="calibre7">f</em><sub class="calibre12">L</sub>. The Real Part operation merely means take the real part of sequence <em class="calibre7">v</em>(<em class="calibre7">n</em>).</p>
<p class="calibre3">We can eliminate the multiply-by-two operation by increasing the DC (zero Hz) gain of the complex filter by two. In this method, as Bell recommends, we can combine the second complex multiply and Real Part extraction stages by computing only the real part of sequence <em class="calibre7">u</em>(<em class="calibre7">n</em>), yielding sequence <em class="calibre7">v</em>(<em class="calibre7">n</em>). The multiply-by-two operation compensates for the amplitude loss by a factor of two caused by the Real Part operation.</p>
<p class="calibre3"><a id="calibre_link-713"></a></p>
<h3 class="calibre6">13.46 Computing Missing Signal Samples</h3>
<p class="calibre3">Consider the situation where we need to process a time-domain signal that has been corrupted such that every <em class="calibre7">Q</em>th sample is missing from the desired signal sequence. This section provides a trick for how to recover periodically spaced missing samples of a corrupted time sequence<a href="#calibre_link-1015">[94]</a>.</p>
<p class="calibre3">To explain our problem, assume we want to process an <em class="calibre7">x</em><sub class="calibre12">0</sub>(<em class="calibre7">n</em>) time sequence, whose sample rate is <em class="calibre7">f<sub class="calibre12">s</sub></em> Hz, but all we have available to us is a corrupted <em class="calibre7">x</em><sub class="calibre12">q</sub>(<em class="calibre7">n</em>) sequence where:</p>
<p class="indenthangingb">• <em class="calibre7">x</em><sub class="calibre12">q</sub>(<em class="calibre7">n</em>) is equal to the desired <em class="calibre7">x</em><sub class="calibre12">0</sub>(<em class="calibre7">n</em>) with every <em class="calibre7">Q</em>th sample of <em class="calibre7">x</em><sub class="calibre12">0</sub>(<em class="calibre7">n</em>) missing. The missing samples in <em class="calibre7">x</em><sub class="calibre12">q</sub>(<em class="calibre7">n</em>), <em class="calibre7">x</em><sub class="calibre12">q</sub>(<em class="calibre7">pQ</em>) where <em class="calibre7">p</em> = 0, 1, 2, ... are represented by zero-valued samples.</p>
<p class="indenthangingb"><a id="calibre_link-3392"></a>• <em class="calibre7">x</em><sub class="calibre12">0</sub>(<em class="calibre7">n</em>) is band-limited with negligible energy above <em class="calibre7">B</em> Hz where</p>
<p class="caption"><a id="calibre_link-1018"></a>(13-166)</p>
<p class="image"><img src="images/001573.jpg" alt="image" class="calibre2" /></p>
<p class="indentpara6">for some integer <em class="calibre7">Q</em> ≥ 2 where <em class="calibre7">f<sub class="calibre12">s</sub></em> is the data sample rate in Hz.</p>
<p class="calibre3">As an example, when <em class="calibre7">Q</em> = 5, if the desired <em class="calibre7">x</em><sub class="calibre12">0</sub>(<em class="calibre7">n</em>) is the sequence in <a href="#calibre_link-1016">Figure 13-108(a)</a>, then <em class="calibre7">x</em><sub class="calibre12">q</sub>(<em class="calibre7">n</em>) is the corrupted sequence shown in <a href="#calibre_link-1016">Figure 13-108(b)</a>. Our job, then, is to recover (interpolate) the missing samples in <em class="calibre7">x</em><sub class="calibre12">q</sub>(<em class="calibre7">n</em>), <em class="calibre7">x</em><sub class="calibre12">q</sub>(0), <em class="calibre7">x</em><sub class="calibre12">q</sub>(5), <em class="calibre7">x</em><sub class="calibre12">q</sub>(10), ... etc., to reconstruct the desired <em class="calibre7">x</em><sub class="calibre12">0</sub>(<em class="calibre7">n</em>) sequence.</p>
<p class="caption"><a id="calibre_link-1016"></a><strong class="calibre9">Figure 13-108</strong> Time sequences: (a) original <em class="calibre7">x</em><sub class="calibre12">0</sub>(<em class="calibre7">n</em>); (b) corrupted <em class="calibre7">x</em><sub class="calibre12">q</sub>(<em class="calibre7">n</em>) when <em class="calibre7">Q</em> = 5.</p>
<p class="image"><img src="images/000355.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The solution to our problem is to apply the <em class="calibre7">x</em><sub class="calibre12">q</sub>(<em class="calibre7">n</em>) sequence to the tapped-delay line reconstruction filter shown in <a href="#calibre_link-1017">Figure 13-109</a>. Describing <a href="#calibre_link-1017">Figure 13-109</a>’s operation in words: our desired <em class="calibre7">x</em><sub class="calibre12">o</sub>(<em class="calibre7">n</em>−<em class="calibre7">K</em>) samples are the <em class="calibre7">x</em><sub class="calibre12">q</sub>(<em class="calibre7">n</em>−<em class="calibre7">K</em>) samples at the center tap of the filter unless that <em class="calibre7">x</em><sub class="calibre12">q</sub>(<em class="calibre7">n</em>−<em class="calibre7">K</em>) sample is a zero-valued missing sample, in which case the switches toggle and we compute the estimated <em class="calibre7">x</em><sub class="calibre12">o</sub>(<em class="calibre7">n</em>−<em class="calibre7">K</em>) = <em class="calibre7">x</em><sub class="calibre12">o</sub>(<em class="calibre7">pQ</em>).</p>
<p class="caption"><a id="calibre_link-1017"></a><strong class="calibre9">Figure 13-109</strong> Reconstruction filter implementation.</p>
<p class="image"><img src="images/001201.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The filter’s <em class="calibre7">c</em>(<em class="calibre7">k</em>) coefficients are determined by first evaluating the following expression:</p>
<p class="caption"><a id="calibre_link-1020"></a>(13-167)</p>
<p class="image"><img src="images/001222.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where integer index <em class="calibre7">k</em> is in the range −<em class="calibre7">K</em> ≤ <em class="calibre7">k</em> ≤ <em class="calibre7">K</em>, sinc(<em class="calibre7">x</em>) = sin(π<em class="calibre7">x</em>)/π<em class="calibre7">x</em>, and <em class="calibre7">w</em>(<em class="calibre7">k</em>) is a time-symmetric window sequence of length 2<em class="calibre7">K</em>+1. Next, we use <em class="calibre7">h</em>(<em class="calibre7">k</em>) to compute our desired filter coefficients as</p>
<p class="caption"><a id="calibre_link-3393"></a>(13-168)</p>
<p class="image"><img src="images/000262.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3394"></a>This missing sample recovery process can also be applied to complex <em class="calibre7">x</em><sub class="calibre12">q</sub>(<em class="calibre7">n</em>) signals, in which case the real and imaginary parts of a complex <em class="calibre7">x</em><sub class="calibre12">q</sub>(<em class="calibre7">n</em>) must be filtered separately.</p>
<p class="calibre3">There are two practical considerations to keep in mind when using this missing sample recovery process. The first consideration is to be aware that the maximum bandwidth <em class="calibre7">B</em> given in <a href="#calibre_link-1018">Eq. (13-166)</a> is based on the assumption that the reconstruction filter has an infinite number of taps. As such, for practical-length filters the <em class="calibre7">B</em> bandwidth requirement must be reduced. To show this, <a href="#calibre_link-1019">Figure 13-110</a> illustrates the missing sample recovery error when <em class="calibre7">Q</em> = 5, <em class="calibre7">B</em> = 0.4<em class="calibre7">f</em><sub class="calibre12">s</sub>, using a Chebyshev window with −100 dB sidelobes, for various values of <em class="calibre7">K</em>. The input signal is a noiseless sinusoid, with unity peak amplitude, swept in frequency from a very low frequency up to <em class="calibre7">f</em><sub class="calibre12">s</sub>/2 (half the sample rate).</p>
<p class="caption"><a id="calibre_link-1019"></a><strong class="calibre9">Figure 13-110</strong> Recovery error curves, for various <em class="calibre7">K</em>, versus input tone frequency.</p>
<p class="image"><img src="images/001082.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">In that figure we see that a <em class="calibre7">K</em> = 3 filter (7 taps) exhibits low missing sample recovery error until the input signal’s frequency approaches roughly 0.25<em class="calibre7">f</em><sub class="calibre12">s</sub>, where the recovery error starts to become large. When <em class="calibre7">K</em> = 5, the recovery error doesn’t become large until the input signal’s frequency approaches roughly 0.3<em class="calibre7">f</em><sub class="calibre12">s</sub>. (The unlabeled curve in <a href="#calibre_link-1019">Figure 13-110</a> is a <em class="calibre7">K</em> = 7 curve.) So what we see is that to minimize our missing sample recovery error for short-length <a id="calibre_link-2127"></a>filters, the maximum input signal bandwidth must be kept substantially lower than the <em class="calibre7">B</em> Hz specified in <a href="#calibre_link-1018">Eq. (13-166)</a>.</p>
<p class="calibre3">The second practical consideration to consider when using this missing sample recovery process is the <em class="calibre7">w</em>(<em class="calibre7">k</em>) window sequence in <a href="#calibre_link-1020">Eq. (13-167)</a>. There seems to be no “best” window sequence that minimizes the recovery error for all real-world signals that we might encounter. So experimentation, using various window functions, becomes necessary. A good place to start is to use either Kaiser or Chebyshev window sequences whose control parameters are set such that the windows’ frequency-domain sidelobes are very low relative to their main lobe levels.</p>
<p class="calibre3">We conclude this section by mentioning that reference <a href="#calibre_link-1021">[95]</a> describes a missing sample recovery technique that is applicable when the pattern of missing samples is more complicated than the simple every <em class="calibre7">Q</em>th sample described here.</p>
<p class="calibre3"><a id="calibre_link-714"></a></p>
<h3 class="calibre6">13.47 Computing Large DFTs Using Small FFTs</h3>
<p class="calibre3">It is possible to compute <em class="calibre7">N</em>-point discrete Fourier transforms (DFTs) using radix-2 fast Fourier transforms (FFTs) whose sizes are less than <em class="calibre7">N</em>. For example, let’s say the largest size FFT software routine we have available is a 1024-point FFT. With the following trick we can combine the results of multiple 1024-point FFTs to compute DFTs whose sizes are greater than 1024.</p>
<p class="calibre3">The simplest form of this idea is computing an <em class="calibre7">N</em>-point DFT using two <em class="calibre7">N</em>/2-point FFT operations. Here’s how the trick works for computing a 16-point DFT, of a 16-sample <em class="calibre7">x</em>(<em class="calibre7">n</em>) input sequence, using two 8-point FFTs. First we perform an 8-point FFT on the <em class="calibre7">x</em>(<em class="calibre7">n</em>) samples where <em class="calibre7">n</em> = 0, 2, 4, ..., 14. We’ll call those FFT results <em class="calibre7">X</em><sub class="calibre12">0</sub>(<em class="calibre7">k</em>). Then we store two copies of <em class="calibre7">X</em><sub class="calibre12">0</sub>(<em class="calibre7">k</em>) in Memory Array 1 as shown in <a href="#calibre_link-1022">Figure 13-111</a>. Next we compute an 8-point FFT on the <a id="calibre_link-3395"></a><em class="calibre7">x</em>(<em class="calibre7">n</em>) samples where <em class="calibre7">n</em> = 1, 3, 5, ..., 15. We call those FFT results <em class="calibre7">X</em><sub class="calibre12">1</sub>(<em class="calibre7">k</em>). We store two copies of <em class="calibre7">X</em><sub class="calibre12">1</sub>(<em class="calibre7">k</em>) in Memory Array 3 in <a href="#calibre_link-1022">Figure 13-111</a>.</p>
<p class="caption"><a id="calibre_link-1022"></a><strong class="calibre9">Figure 13-111</strong> A 16-point DFT using two 8-point FFTs.</p>
<p class="image"><img src="images/000136.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">In Memory Array 2 we have stored 16 samples of one cycle of the complex exponential <em class="calibre7">e</em><sup class="calibre10">−<em class="calibre7">j</em>2π<em class="calibre7">m</em>/<em class="calibre7">N</em></sup>, where <em class="calibre7">N</em> = 16, and 0 ≤ <em class="calibre7">m</em> ≤ 15. Finally we compute our desired 16-point <em class="calibre7">X</em>(<em class="calibre7">m</em>) samples by performing the arithmetic shown in <a href="#calibre_link-1022">Figure 13-111</a> on the horizontal rows of the memory arrays. That is,</p>
<p class="image"><img src="images/000882.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The desired <em class="calibre7">X</em>(<em class="calibre7">m</em>) DFT results are stored in Memory Array 4.</p>
<p class="calibre3">We describe the above process, algebraically, as</p>
<p class="caption"><a id="calibre_link-3396"></a>(13-169)</p>
<p class="image"><img src="images/001668.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">and</p>
<p class="caption"><a id="calibre_link-3397"></a>(13-169′)</p>
<p class="image"><img src="images/000156.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">for <em class="calibre7">k</em> in the range 0 ≤ <em class="calibre7">k</em> ≤ 7.</p>
<p class="calibre3"><a id="calibre_link-3398"></a>Notice that we did nothing to reduce the size of Memory Array 2 due to redundancies in the complex exponential sequence <em class="calibre7">e</em><sup class="calibre10">−<em class="calibre7">j</em>2π<em class="calibre7">m</em>/<em class="calibre7">N</em></sup>. As it turns out, for an <em class="calibre7">N</em>-point DFT, only <em class="calibre7">N</em>/4 complex values need be stored in Memory Array 2. The reason for this is that</p>
<p class="caption"><a id="calibre_link-1023"></a>(13-170)</p>
<p class="image"><img src="images/000043.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">which involves a simple sign change on <em class="calibre7">e</em><sup class="calibre10">−<em class="calibre7">j</em>2π<em class="calibre7">m</em>/<em class="calibre7">N</em></sup>. In addition,</p>
<p class="caption"><a id="calibre_link-1024"></a>(13-170′)</p>
<p class="image"><img src="images/000894.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">which is merely swapping the real and imaginary parts of <em class="calibre7">e</em><sup class="calibre10">−<em class="calibre7">j</em>2π<em class="calibre7">m</em>/<em class="calibre7">N</em></sup> plus a sign change of the resulting imaginary part. So <a href="#calibre_link-1023">Eqs. (13-170)</a> and <a href="#calibre_link-1024">(13-170′)</a> tell us that only the values <em class="calibre7">e</em><sup class="calibre10">−<em class="calibre7">j</em>2π<em class="calibre7">m</em>/<em class="calibre7">N</em></sup> for 0 ≤ <em class="calibre7">m</em> ≤ <em class="calibre7">N</em>/4−1 need be stored in Memory Array 2. With that reduced storage idea aside, to be clear regarding exactly what computations are needed for our “multiple-FFTs” technique, we leave Memory Array 2 unchanged from that in <a href="#calibre_link-1022">Figure 13-111</a>.</p>
<p class="calibre3">The neat part of this “multiple-FFTs” scheme is that our DFT length, <em class="calibre7">N</em>, is not restricted to be an integer power of two. We can use computationally efficient radix-2 FFTs to compute DFTs whose lengths are any integer multiple of an integer power of two. For example, we can compute an <em class="calibre7">N</em> = 24-point DFT using three 8-point FFTs. To do so, we perform an 8-point FFT on the <em class="calibre7">x</em>(<em class="calibre7">n</em>) samples, where <em class="calibre7">n</em> = 0, 3, 6, ..., 21, to obtain <em class="calibre7">X</em><sub class="calibre12">0</sub>(<em class="calibre7">k</em>). Next we compute an 8-point FFT on the <em class="calibre7">x</em>(<em class="calibre7">n</em>) samples, where <em class="calibre7">n</em> = 1, 4, 7, ..., 22, to yield <em class="calibre7">X</em><sub class="calibre12">1</sub>(<em class="calibre7">k</em>). And then we perform an 8-point FFT on the <em class="calibre7">x</em>(<em class="calibre7">n</em>) samples, where <em class="calibre7">n</em> = 2, 5, 8, ..., 23, to obtain an <em class="calibre7">X</em><sub class="calibre12">2</sub>(<em class="calibre7">k</em>) sequence. Finally, we compute our desired 24-point DFT results using</p>
<p class="caption"><a id="calibre_link-3399"></a>(13-171)</p>
<p class="image"><img src="images/000944.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-3400"></a>(13-171′)</p>
<p class="image"><img src="images/001808.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">and</p>
<p class="caption"><a id="calibre_link-3401"></a>(13-171″)</p>
<p class="image"><img src="images/000834.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">for <em class="calibre7">k</em> in the range 0 ≤ <em class="calibre7">k</em> ≤ 7. The memory-array depiction of this process is shown in <a href="#calibre_link-1025">Figure 13-112</a>, with our final 24-point DFT results residing in Memory Array 6. Memory Array 2 contains <em class="calibre7">N</em> = 24 samples of one cycle of the complex exponential <em class="calibre7">e</em><sup class="calibre10">−<em class="calibre7">j</em>2π<em class="calibre7">m</em>/24</sup>, where 0 ≤ <em class="calibre7">m</em> ≤ 23. Memory Array 4 contains 24 samples of two cycles of the complex exponential <em class="calibre7">e</em><sup class="calibre10">−<em class="calibre7">j</em>2π(2<em class="calibre7">m</em>)/24</sup>.</p>
<p class="caption"><a id="calibre_link-1025"></a><strong class="calibre9">Figure 13-112</strong> A 24-point DFT using three 8-point FFTs.</p>
<p class="image"><img src="images/000975.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">To conclude this section, we state that the larger the size of the FFTs, the more computationally efficient is this “multiple-FFTs” spectrum analysis technique. This behavior is illustrated in <a href="#calibre_link-1026">Figure 13-113</a> where we show the number of complex multiplies required by the “multiple-FFTs” algorithm versus the desired DFT size (<em class="calibre7">N</em>). The top bold curve is the number of complex multiplies required by the standard (inefficient) DFT algorithm, and the bottom dashed curve is the number of complex multiplies required by a single <em class="calibre7">N</em>-point radix-2 <a id="calibre_link-3402"></a>FFT. The curves in the center of the figure show the number of complex multiplies required by the “multiple-FFTs” algorithm when various FFT sizes (<em class="calibre7">P</em>) are used to compute an <em class="calibre7">N</em>-point DFT. For example, if we must perform a 4096-point DFT using this “multiple-FFTs” algorithm, it’s better for us to perform sixteen 256-point FFTs rather than one hundred twenty-eight 32-point FFTs.</p>
<p class="caption"><a id="calibre_link-1026"></a><strong class="calibre9">Figure 13-113</strong> Number of complex multiplies versus <em class="calibre7">N</em>.</p>
<p class="image"><img src="images/000027.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-715"></a></p>
<h3 class="calibre6"><a id="calibre_link-2305" class="calibre5"></a>13.48 Computing Filter Group Delay without Arctangents</h3>
<p class="calibre3">Here we present an interesting scheme used to compute the group delay of digital filters that does not require the phase unwrapping process needed when computing arctangents in traditional group delay measurement algorithms. The technique is based on the following: Assume we have the <em class="calibre7">N</em>-sample <em class="calibre7">h</em>(<em class="calibre7">k</em>) impulse response of a digital filter, with <em class="calibre7">k</em> (0″<em class="calibre7">k</em>″<em class="calibre7">N</em>−1) being our time-domain index, and that we represent the filter’s discrete-time Fourier transform (DTFT), <em class="calibre7">H</em>(ω), in polar form as</p>
<p class="caption"><a id="calibre_link-1027"></a>(13-172)</p>
<p class="image"><img src="images/001693.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">In <a href="#calibre_link-1027">Eq. (13-172)</a>, <em class="calibre7">M</em>(ω) is the frequency magnitude response of the filter, ϕ(ω) is the filter’s phase response, and ω is continuous frequency measured in radians/second. Taking the derivative of <em class="calibre7">H</em>(ω) with respect to ω, and performing a variety of algebraic acrobatics, we can write</p>
<p class="caption"><a id="calibre_link-1028"></a>(13-173)</p>
<p class="image"><img src="images/000715.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">So what does that puzzling gibberish in <a href="#calibre_link-1028">Eq. (13-173)</a> tell us? As it turns out, it tells us a lot if we recall the following items:</p>
<p class="indenthangingb">• <em class="calibre7">j</em>d[<em class="calibre7">H</em>(ω)]/dω = the DTFT of <em class="calibre7">k</em> · <em class="calibre7">h</em>(<em class="calibre7">k</em>)</p>
<p class="indenthangingb">• <em class="calibre7">M</em>(ω) · <em class="calibre7">e<sup class="calibre10">j</sup></em><sup class="calibre10">ϕ(ω)</sup> = <em class="calibre7">H</em>(ω) = the DTFT of <em class="calibre7">h</em>(<em class="calibre7">k</em>)</p>
<p class="indenthangingb">• −d[ϕ(ω)]/dω = group delay of the filter</p>
<p class="calibre3">Now we are able to translate <a href="#calibre_link-1028">Eq. (13-173)</a> into the meaningful expression</p>
<p class="caption"><a id="calibre_link-1029"></a>(13-173′)</p>
<p class="image"><img src="images/001570.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Discretizing expression <a href="#calibre_link-1029">(13-173′)</a> by replacing the DTFT with the discrete Fourier transform (DFT), we arrive at our scheme for computing the group delay of a digital filter, measured in samples:</p>
<p class="caption"><a id="calibre_link-1030"></a>(13-174)</p>
<p class="image"><img src="images/000595.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">So, starting with a filter’s <em class="calibre7">N</em>-sample <em class="calibre7">h</em>(<em class="calibre7">k</em>) impulse response, performing two <em class="calibre7">N</em>-point DFTs and an <em class="calibre7">N</em>-sample complex division, we can compute the filter’s passband group delay. (Of course, to improve our group delay granularity we can zero-pad our original <em class="calibre7">h</em>(<em class="calibre7">k</em>) before computing the DFTs). Again, the advantage of the process in expression <a href="#calibre_link-1030">(13-174)</a> is that the phase unwrapping <a id="calibre_link-2188"></a>process needed in traditional group delay algorithms is not needed here. Note that in implementing the process in expression <a href="#calibre_link-1030">(13-174)</a>, we must be prepared to accommodate the situation where a frequency-domain DFT[<em class="calibre7">h</em>(<em class="calibre7">k</em>)] sample is zero-valued, which will make a group delay sample unrealistically large.</p>
<p class="calibre3">As an example, the square dots in <a href="#calibre_link-1031">Figure 13-114(a)</a> show the <em class="calibre7">N</em> = 25-sample <em class="calibre7">h</em>(<em class="calibre7">k</em>) impulse response of a 2nd-order IIR lowpass filter. A 25-sample filter group delay estimation, using expression <a href="#calibre_link-1030">(13-174)</a>, is shown in <a href="#calibre_link-1031">Figure 13-114(b)</a>. When we zero-pad the <em class="calibre7">h</em>(<em class="calibre7">k</em>) and <em class="calibre7">k</em> · <em class="calibre7">h</em>(<em class="calibre7">k</em>) sequences to a length of 64 samples (0≤<em class="calibre7">k</em>≤63), expression <a href="#calibre_link-1030">(13-174)</a> yields the group delay estimate in <a href="#calibre_link-1031">Figure 13-114(c)</a>.</p>
<p class="caption"><a id="calibre_link-1031"></a><strong class="calibre9">Figure 13-114</strong> Group delay computation: (a) 25-sample <em class="calibre7">h</em>(<em class="calibre7">k</em>) and <em class="calibre7">k</em> · <em class="calibre7">h</em>(<em class="calibre7">k</em>); (b) 25-point group delay; (c) 64-point group delay.</p>
<p class="image"><img src="images/000870.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-716"></a></p>
<h3 class="calibre6">13.49 Computing a Forward and Inverse FFT Using a Single FFT</h3>
<p class="calibre3">In <a href="#calibre_link-463">Section 13.5</a> we described the processes of using a single <em class="calibre7">N</em>-point complex FFT to perform both a 2<em class="calibre7">N</em>-Point Real FFT and two independent <em class="calibre7">N</em>-Point Real FFTs. This section presents the algorithm for simultaneously computing a forward FFT and an inverse FFT using a single radix-2 FFT<a href="#calibre_link-1032">[96]</a>.</p>
<p class="calibre3"><a id="calibre_link-3403"></a>Our algorithm is depicted by the seven steps, S1 through S7, shown in <a href="#calibre_link-1033">Figure 13-115</a>. In that figure, we compute the <em class="calibre7">x</em>(<em class="calibre7">n</em>) inverse FFT of the <em class="calibre7">N</em>-point frequency-domain conjugate-symmetric input sequence <em class="calibre7">X</em>(<em class="calibre7">m</em>), as well as compute the <em class="calibre7">Y</em>(<em class="calibre7">m</em>) forward FFT of the <em class="calibre7">N</em>-point time-domain real-valued input sequence <em class="calibre7">y</em>(<em class="calibre7">n</em>) using the single complex FFT in Step S4. Sample indices <em class="calibre7">n</em> and <em class="calibre7">m</em> both range from 0 to <em class="calibre7">N</em>−1 where <em class="calibre7">N</em> is an integer power of two.</p>
<p class="caption"><a id="calibre_link-1033"></a><strong class="calibre9">Figure 13-115</strong> Simultaneous FFT and inverse FFT algorithm.</p>
<p class="image"><img src="images/001725.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">At first glance <a href="#calibre_link-1033">Figure 13-115</a> looks more complicated than it actually is, and here’s why:</p>
<p class="indenthangingb">• Steps S1 and S2 create a complex sequence that we call <em class="calibre7">v</em>(<em class="calibre7">n</em>).</p>
<p class="indenthangingb">• Step S1 generates the first <em class="calibre7">N</em>/2+1 samples of <em class="calibre7">v</em>(<em class="calibre7">n</em>) based on the real-valued input sequence <em class="calibre7">y</em>(<em class="calibre7">n</em>).</p>
<p class="indenthangingb">• Step S2 extends <em class="calibre7">v</em>(<em class="calibre7">n</em>) to a length of <em class="calibre7">N</em> samples and forces <em class="calibre7">v</em>(<em class="calibre7">n</em>) to be conjugate symmetric. The “*” symbol in Step S2 means conjugation.</p>
<p class="indenthangingb"><a id="calibre_link-3404"></a>• Step S3 combines the conjugate-symmetric sequences <em class="calibre7">X</em>(<em class="calibre7">m</em>) and <em class="calibre7">v</em>(<em class="calibre7">n</em>) to create a sequence we call <em class="calibre7">z</em>(<em class="calibre7">n</em>). (Sequence <em class="calibre7">z</em>(<em class="calibre7">n</em>) is not conjugate symmetric.)</p>
<p class="indenthangingb">• Step S4 is the algorithm’s single radix-2 FFT operation, generating complex sequence <em class="calibre7">Z</em>(<em class="calibre7">m</em>).</p>
<p class="indenthangingb">• Step S5 generates the desired real-valued <em class="calibre7">x</em>(<em class="calibre7">n</em>) time sequence by performing a <em class="calibre7">circular reversal</em> of the real part of <em class="calibre7">Z</em>(<em class="calibre7">m</em>). (That is, other than the first sample, the real parts of <em class="calibre7">Z</em>(<em class="calibre7">m</em>) samples are reversed in order to produce <em class="calibre7">x</em>(<em class="calibre7">n</em>). This type of sequence reversal is discussed in <a href="#calibre_link-295">Appendix C</a>.)</p>
<p class="indenthangingb">• Steps S6 and S7 generate the desired frequency-domain <em class="calibre7">Y</em>(<em class="calibre7">m</em>) sequence.</p>
<p class="indenthangingb">• Step S6 generates the first <em class="calibre7">N</em>/2+1 samples of <em class="calibre7">Y</em>(<em class="calibre7">m</em>).</p>
<p class="indenthangingb">• Step S7 extends the sequence from Step S6 to a length of <em class="calibre7">N</em> samples and forces conjugate symmetry, to produce <em class="calibre7">Y</em>(<em class="calibre7">m</em>). The “*” symbol in Step S7 means conjugation.</p>
<p class="calibre3">The <a href="#calibre_link-1033">Figure 13-115</a> algorithm’s computational workload is one complex <em class="calibre7">N</em>-point FFT and roughly 2<em class="calibre7">N</em> additions/subtractions.</p>
<p class="calibre3"><a id="calibre_link-717"></a></p>
<h3 class="calibre6">13.50 Improved Narrowband Lowpass IIR Filters</h3>
<p class="calibre3">Due to their resistance to quantized-coefficient errors, traditional 2nd-order infinite impulse response (IIR) filters are the fundamental building blocks in computationally efficient high-order IIR digital filter implementations. However, when used in fixed-point number systems, the inherent properties of quantized-coefficient 2nd-order IIR filters do not readily permit their use in narrowband lowpass filtering applications. Narrowband lowpass IIR filters have traditionally had a bad reputation&mdash;for example, MATLAB’s Signal Processing Toolbox documentation warns: “All classical IIR lowpass filters are ill-conditioned for extremely low cutoff frequencies.”</p>
<p class="calibre3">This section presents a neat trick to overcome the shortcomings of narrowband 2nd-order lowpass IIR filters, with no increase in filter coefficient bit widths and no increase in the number of filter multiplies per output sample.</p>
<p class="calibre3"><a id="calibre_link-3405"></a></p>
<h4 class="calibre13">13.50.1 The Problem with Narrowband Lowpass IIR Filters</h4>
<p class="calibre3">Narrowband lowpass IIR filters are difficult to implement because of intrinsic limitations on their <em class="calibre7">z</em>-plane pole locations. Let’s examine the restrictions on the <em class="calibre7">z</em>-plane pole locations of a standard 2nd-order IIR filter whose structure is shown in <a href="#calibre_link-1034">Figure 13-116(a)</a>.</p>
<p class="caption"><a id="calibre_link-1034"></a><strong class="calibre9">Figure 13-116</strong> Second-order IIR filters: (a) standard form; (b) coupled form.</p>
<p class="image"><img src="images/000750.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Such an IIR filter, having a transfer function given by</p>
<p class="caption"><a id="calibre_link-3406"></a>(13-175)</p>
<p class="image"><img src="images/001457.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2090"></a>has a pair of conjugate poles located at radii of <em class="calibre7">r</em>, at angles of ±θ radians. (For filter stability reasons, we always ensure that <em class="calibre7">r</em> &lt; 1.) In fixed-point implementations, quantizing the 2<em class="calibre7">r</em>cos(θ) and −<em class="calibre7">r</em><sup class="calibre10">2</sup> coefficients restricts the possible pole locations[<a href="#calibre_link-1035">97</a>,<a href="#calibre_link-1036">98</a>]. On the <em class="calibre7">z</em>-plane, a pole can only reside at the intersection of a vertical line defined by the quantized value of 2<em class="calibre7">r</em>cos(θ) and a concentric circle whose radius is defined by the square root of the quantized value of <em class="calibre7">r</em><sup class="calibre10">2</sup>. For example, <a href="#calibre_link-1037">Figure 13-117</a> shows the first quadrant of possible <em class="calibre7">z</em>-plane pole locations using five magnitude bits to represent the filter’s two coefficients. Notice the irregular spacing of those permissible pole locations. (Due to trigonometric symmetry, the pole locations in the other three quadrants of the <em class="calibre7">z</em>-plane are mirror images of those shown in <a href="#calibre_link-1037">Figure 13-117</a>.)</p>
<p class="caption"><a id="calibre_link-1037"></a><strong class="calibre9">Figure 13-117</strong> Possible pole locations for five magnitude bit coefficient quantization.</p>
<p class="image"><img src="images/001609.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">So here’s the problem we have with standard 2nd-order IIR filters: If we use floating-point software to design a very narrowband (high-order) lowpass IIR filter (implemented as cascaded 2nd-order filters) having poles residing in the shaded area near <em class="calibre7">z</em> = 1, subsequent quantizing of the designed filter coefficients to five magnitude bits will make the poles shift to one of the locations shown by the dots on the border of the shaded region in <a href="#calibre_link-1037">Figure 13-117</a>. Unfortunately that pole shifting, inherent in the <a href="#calibre_link-1034">Figure 13-116(a)</a> IIR filter implementation due to coefficient quantization in fixed-point systems, prevents us from realizing the desired narrowband lowpass filter. We can always reduce the size of the shaded forbidden zone near <em class="calibre7">z</em> = 1 in <a href="#calibre_link-1037">Figure 13-117</a> by increasing the number of bits used to represent the 2nd-order filters’ coefficients. However, in some filter implementation scenarios increasing coefficient binary-word bit widths may not be a viable option.</p>
<p class="calibre3">One solution to the above problem is to use the so-called <em class="calibre7">coupled-form</em> IIR filter (also called the Gold-Rader filter<a href="#calibre_link-1038">[99]</a>) structure, shown in <a href="#calibre_link-1034">Figure 13-116(b)</a>, having a transfer function given by</p>
<p class="caption"><a id="calibre_link-3407"></a><a id="calibre_link-3408"></a>(13-176)</p>
<p class="image"><img src="images/000495.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Because the coupled-form filter’s quantized coefficients in <a href="#calibre_link-1034">Figure 13-116(b)</a> are linear in <em class="calibre7">r</em>cos(θ) and <em class="calibre7">r</em>sin(θ), its possible pole locations are on a regularly spaced grid on the <em class="calibre7">z</em>-plane defined by <em class="calibre7">z</em> = <em class="calibre7">r</em>cos(θ) + <em class="calibre7">jr</em>sin(θ). This enables us to build 2nd-order narrowband lowpass IIR filters with poles in the desired shaded region of <a href="#calibre_link-1037">Figure 13-117</a>.</p>
<p class="calibre3">This pole placement behavior is a beautiful example of the difference between apparently equivalent filter implementations. With infinite-precision coefficients the standard and coupled-form IIR filters, having identical denominators in their transfer functions, will have identical <em class="calibre7">z</em>-plane pole locations. But with quantized coefficients the two filters will have different pole locations.</p>
<p class="calibre3">Back to our problem. While the coupled-form IIR filter gives us increased flexibility in placing <em class="calibre7">z</em>-plane poles for lowpass filtering, unfortunately, this coupled-form implementation requires twice the number of multiplies needed by the standard 2nd-order IIR filter in <a href="#calibre_link-1034">Figure 13-116(a)</a>.</p>
<p class="calibre3">In the following material we describe a slick narrowband lowpass IIR filter structure, proposed by Harris and Loudermilk, having poles residing in <a id="calibre_link-3409"></a>the shaded region of <a href="#calibre_link-1037">Figure 13-117</a> with no increase in coefficient bit width and no additional multiplication operations beyond those needed for a standard 2nd-order IIR filter<a href="#calibre_link-1039">[100]</a>.</p>
<p class="calibre3"><a id="calibre_link-3410"></a></p>
<h4 class="calibre13">13.50.2 An Improved Narrowband Lowpass IIR Filter</h4>
<p class="calibre3">The improved lowpass IIR filter is created by replacing each unit-delay element in a standard 2nd-order IIR filter with multiple unit-delay elements as shown in the left portion of <a href="#calibre_link-1040">Figure 13-118</a>. This <em class="calibre7">zero-stuffed IIR filter</em> will retain its original lowpass passband and have multiple passband images, exactly as did the interpolated finite impulse response (IFIR) filters that we studied in <a href="#calibre_link-187">Chapter 7</a>. The zero-stuffed IIR filter is followed by a lowpass image-reject filter that attenuates those unwanted passband images. Given this cascaded structure, which we’ll demonstrate shortly, we call the filter combination in <a href="#calibre_link-1040">Figure 13-118</a> an <em class="calibre7">interpolated infinite impulse response</em> (interpolated-IIR) filter.</p>
<p class="caption"><a id="calibre_link-1040"></a><strong class="calibre9">Figure 13-118</strong> Interpolated-IIR filter.</p>
<p class="image"><img src="images/000631.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The <em class="calibre7">M</em>-length delay lines, where <em class="calibre7">M</em> is a positive integer, in the zero-stuffed IIR filter shift a standard IIR filter’s conjugate poles, originally located at <em class="calibre7">z</em> = <em class="calibre7">re</em><sup class="calibre10">±<em class="calibre7">j</em>θ</sup>, to the new locations of</p>
<p class="caption"><a id="calibre_link-3411"></a>(13-177)</p>
<p class="image"><img src="images/001359.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">That is, the new conjugate pole locations are at radii of the <em class="calibre7">M</em>th root of <em class="calibre7">r</em>, at angles of ±θ /<em class="calibre7">M</em> radians. Happily, those interpolated-IIR filter pole locations can now reside in the desired shaded region of <a href="#calibre_link-1037">Figure 13-117</a> without using more bits to represent the zero-stuffed IIR filter’s coefficients.</p>
<p class="calibre3">If the original <a href="#calibre_link-1034">Figure 13-116(a)</a> 2nd-order IIR filter contains feedforward coefficients, those coefficients are also delayed by <em class="calibre7">M</em>-length delay lines.</p>
<p class="calibre3"><a id="calibre_link-3412"></a></p>
<h4 class="calibre13"><a id="calibre_link-2332"></a>13.50.3 Interpolated-IIR Filter Example</h4>
<p class="calibre3">Let’s show an example of an interpolated-IIR filter in action. With <em class="calibre7">f</em><sub class="calibre12">s</sub> representing a filter’s input signal sample rate in Hz, assume we want to implement a recursive lowpass filter whose one-sided passband width is 0.005<em class="calibre7">f</em><sub class="calibre12">s</sub> with a stopband attenuation greater than 60 dB. If we choose to set <em class="calibre7">M</em> = 4, then we start our interpolated-IIR filter design process by designing a standard IIR filter having a one-sided passband width of <em class="calibre7">M</em> · 0.005<em class="calibre7">f</em><sub class="calibre12">s</sub> = 0.02<em class="calibre7">f</em><sub class="calibre12">s</sub>. Using our favorite IIR filter design software (for an elliptic IIR filter in this example), we obtain a 5th-order prototype IIR filter. Partitioning that 5th-order prototype IIR filter into two 2nd-order and one single-order IIR filter sections, all in cascade and having coefficients represented by 12-bit words, yields the frequency magnitude response shown in <a href="#calibre_link-1041">Figure 13-119(a)</a>.</p>
<p class="caption"><a id="calibre_link-1041"></a><strong class="calibre9">Figure 13-119</strong> Frequency magnitude responses: (a) original IIR prototype filter; (b) zero-stuffed interpolated-IIR filter and CIC filters (dashed); (c) final narrowband 12-bit coefficient filter.</p>
<p class="image"><img src="images/001490.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Next, replacing the unit-delay elements in the filter sections with <em class="calibre7">M</em> = 4 unit-delay elements results in the frequency magnitude response shown in <a href="#calibre_link-1041">Figure 13-119(b)</a>. There we see the multiple narrowband passband images induced by the <em class="calibre7">M</em> = 4-length delay lines of the interpolated-IIR filter. Our final job is to attenuate those unwanted passband images. We can do so by following the cascaded increased-delay IIR filter sections with a cascaded integrator-comb (CIC) <a id="calibre_link-2302"></a>filter, whose structure is shown on the right side of <a href="#calibre_link-1040">Figure 13-118</a>. (The CIC filter is computationally advantageous because it requires no multiplications.) To satisfy our desired 60 dB stopband attenuation requirement, we use a 2nd-order CIC filter&mdash;two 1st-order CIC filters in cascade&mdash;to attenuate the passband images in <a href="#calibre_link-1041">Figure 13-119(b)</a>. The result of our design is the interpolated-IIR and CIC filter combination whose composite frequency magnitude response meets our filter requirements as shown <a href="#calibre_link-1041">Figure 13-119(c)</a>.</p>
<p class="calibre3">In practice, 2nd-order subfilters may have large gains requiring unpleasantly large bit-width multipliers and large bit-width registers to store intermediate results. For this reason it may be necessary to scale the IIR subfilters’ coefficients as discussed in <a href="#calibre_link-289">Chapter 6</a>, or truncate the subfilters’ output samples, in order to avoid undesirably large bit-width processing.</p>
<p class="calibre3">To recap this material, we discussed the limitations encountered when using traditional 2nd-order quantized-coefficient IIR filters to perform narrowband lowpass filtering and mentioned the coupled-form IIR filter that reduced those limitations albeit with an increased computational cost of doubling the number of multiplies per filter output sample. Next we described, and then demonstrated, an interpolated-IIR filter that overcomes the shortcomings of traditional lowpass IIR filters. The interpolated-IIR filter provides improved lowpass IIR filter performance while requiring no increase in filter coefficient bit widths and no additional multiply operations beyond a traditional IIR filter. When it comes to narrowband lowpass IIR filters, there’s a new sheriff in town.</p>
<p class="calibre3"><a id="calibre_link-718"></a></p>
<h3 class="calibre6">13.51 A Stable Goertzel Algorithm</h3>
<p class="calibre3">In <a href="#calibre_link-1042">Section 13.17.1</a> we discussed the computational value of the Goertzel algorithm for computing discrete Fourier transform (DFT) spectral components. However, we also mentioned that the <a href="#calibre_link-1043">Figure 13-42</a> complex resonator implementation of the Goertzel algorithm places resonator <em class="calibre7">z</em>-domain poles on the <em class="calibre7">z</em>-plane’s unit circle. Having a resonator pole on the unit circle leads to potential instability problems because we cannot represent the resonator’s coefficients with infinite precision. We’re forced to represent the coefficients as accurately as a fixed number of binary bits allows. This means the resonator’s poles will not lie exactly on the unit circle. If an imprecise binary representation of the coefficient 2cos(2π<em class="calibre7">m</em>/<em class="calibre7">N</em>) places the poles slightly inside the <em class="calibre7">z</em>-plane’s unit circle, then the computed <em class="calibre7">X</em>(<em class="calibre7">m</em>) spectral sample will contain a small error. Even worse, if an imprecise binary representation of 2cos(2π<em class="calibre7">m</em>/<em class="calibre7">N</em>) places the poles slightly outside the unit circle, then the resonator is unstable. For this reason, typical applications of the Goertzel algorithm restrict the transform length <em class="calibre7">N</em> to be in the hundreds.</p>
<p class="calibre3"><a id="calibre_link-3413"></a>One way to avoid those potential stability problems, and let <em class="calibre7">N</em> be any value we wish, is by way of a heterodyning scheme. That is, instead of building an imperfect resonator centered at our frequency of interest, 2′<em class="calibre7">m</em>/<em class="calibre7">N</em> radians/sample, we frequency translate our signal of interest down to zero frequency where we can build a perfect resonator as shown in <a href="#calibre_link-1044">Figure 13-120(a)</a>. We say “perfect resonator” because that resonator, centered at zero frequency (frequency index <em class="calibre7">m</em> = 0), has coefficients of two and one, which can be represented by binary words with perfect precision.</p>
<p class="caption"><a id="calibre_link-1044"></a><strong class="calibre9">Figure 13-120</strong> Stable Goertzel algorithm: (a) resonator implementation; (b) <em class="calibre7">z</em>-plane poles and zero.</p>
<p class="image"><img src="images/001383.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Such a resonator has a <em class="calibre7">z</em>-domain transfer function of</p>
<p class="caption"><a id="calibre_link-1045"></a>(13-178)</p>
<p class="image"><img src="images/000390.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">with a single <em class="calibre7">z</em>-domain zero located at <em class="calibre7">z</em> = 1 and two poles at <em class="calibre7">z</em> = 1 as shown in <a href="#calibre_link-1044">Figure 13-120(b)</a>. One of the poles cancels the zero at <em class="calibre7">z</em> = 1. The advantages of the network in <a href="#calibre_link-1044">Figure 13-120(a)</a> are that it is guaranteed stable, and it exhibits no output error due to a pole or zero being slightly inside or outside the <em class="calibre7">z</em>-plane unit circle.</p>
<p class="calibre3">Now the perceptive reader would factor <a href="#calibre_link-1045">Eq. (13-178)</a> as</p>
<p class="caption"><a id="calibre_link-3414"></a>(13-179)</p>
<p class="image"><img src="images/001241.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">and redraw <a href="#calibre_link-1044">Figure 13-120(a)</a> as shown in <a href="#calibre_link-1046">Figure 13-121(a)</a>.</p>
<p class="caption"><a id="calibre_link-1046"></a><strong class="calibre9">Figure 13-121</strong> Simplified stable Goertzel algorithm: (a) simplified resonator implementation; (b) <em class="calibre7">z</em>-plane pole.</p>
<p class="image"><img src="images/000425.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a href="#calibre_link-1046">Figure 13-121(a)</a> tells us that our desired <em class="calibre7">X</em>(<em class="calibre7">m</em>) = <em class="calibre7">y</em>(<em class="calibre7">n</em>) spectral sample is equal to the sum of the <em class="calibre7">N</em> samples output by the multiplier in <a href="#calibre_link-1046">Figure 13-121(a)</a>. (This makes perfect sense because the zero-frequency spectral sample of an <em class="calibre7">N</em>-point DFT, <em class="calibre7">X</em>(0), is computed by merely summing a DFT’s <em class="calibre7">N</em> input samples.) So our “stable Goertzel algorithm” now becomes quite simple.</p>
<p class="calibre3"><a id="calibre_link-3415"></a>Ah, but there’s trouble in paradise. The “weak link in the chain” of the <a href="#calibre_link-1046">Figure 13-121(a)</a> network is that we’re assuming the heterodyning sequence <em class="calibre7">e</em><sup class="calibre10">−<em class="calibre7">j</em>2π<em class="calibre7">m</em>/<em class="calibre7">N</em></sup> is ideal in its precision. If you’ve ever tried to generate a complex <em class="calibre7">e</em><sup class="calibre10">−<em class="calibre7">j</em>2π<em class="calibre7">m</em>/<em class="calibre7">N</em></sup> sequence using binary arithmetic, you know that your sequence must be quantized to some fixed number of bits, and thus have imperfect precision. That means the output of your <em class="calibre7">e</em><sup class="calibre10">−<em class="calibre7">j</em>2π<em class="calibre7">m</em>/<em class="calibre7">N</em></sup> oscillator will either increase in magnitude, or decrease in magnitude, as time index <em class="calibre7">n</em> increases. However, we solve that problem by using the guaranteed-stable quadrature oscillator described in <a href="#calibre_link-701">Section 13.32</a>.</p>
<p class="calibre3">It’s fair to copy a slogan from the Aston Martin automobile company and say that the <a href="#calibre_link-1046">Figure 13-121(a)</a> Goertzel algorithm, using the stable quadrature oscillator, is “engineered to exceed all expectations.”</p>
<p class="calibre3"><a id="calibre_link-719"></a></p>
<h3 class="calibre6">References</h3>
<p class="chapterendnote"><a id="calibre_link-1242"></a>[1] Powell, S. “Design and Implementation Issues of All Digital Broadband Modems,” <em class="calibre7">DSP World Workshop Proceedings</em>, Toronto, Canada, September 13&ndash;16, 1998, pp. 127&ndash;142.</p>
<p class="chapterendnote"><a id="calibre_link-3416"></a>[2] Frerking, M. <em class="calibre7">Digital Signal Processing in Communications Systems</em>, Chapman &amp; Hall, New York, 1994, p. 330.</p>
<p class="chapterendnote"><a id="calibre_link-1243"></a>[3] Jacobsen, E., Minister of Algorithms, Abineau Communications, private communication, September 11, 2003.</p>
<p class="chapterendnote"><a id="calibre_link-1247"></a>[4] Palacherls, A. “DSP-mP Routine Computes Magnitude,” <em class="calibre7">EDN</em>, October 26, 1989.</p>
<p class="chapterendnote"><a id="calibre_link-1248"></a>[5] Mikami, N., Kobayashi, M., and Yokoyama, Y. “A New DSP-Oriented Algorithm for Calculation of the Square Root Using a Nonlinear Digital Filter,” <em class="calibre7">IEEE Trans. on Signal Processing</em>, Vol. 40, No. 7, July 1992.</p>
<p class="chapterendnote"><a id="calibre_link-1251"></a>[6] Lyons, R. “Turbocharge Your Graphics Algorithm,” <em class="calibre7">ESD: The Electronic System Design Magazine</em>, October 1988.</p>
<p class="chapterendnote"><a id="calibre_link-3417"></a><a id="calibre_link-1252"></a>[7] Adams W., and Brady, J. “Magnitude Approximations for Microprocessor Implementation,” <em class="calibre7">IEEE Micro</em>, Vol. 3, No. 5, October 1983.</p>
<p class="chapterendnote"><a id="calibre_link-1253"></a>[8] Harris Semiconductor Corp. HSP50110 Digital Quadrature Tuner Data Sheet, File Number 3651, February 1994.</p>
<p class="chapterendnote"><a id="calibre_link-1257"></a>[9] Sabin, W., and Schoenike, E., eds., <em class="calibre7">Single Sideband Systems and Circuits</em>, McGraw-Hill, New York, 1987.</p>
<p class="chapterendnote"><a id="calibre_link-1259"></a>[10] Schreiner, C. “Subject: Re: Approximation for Sum of Two Squares,” Usenet group <em class="calibre7">comp.dsp</em> post, October 4, 1999.</p>
<p class="chapterendnote"><a id="calibre_link-1261"></a>[11] Filip, A. “Linear Approximations to sqrt(x2+y2) Having Equiripple Error Characteristics,” <em class="calibre7">IEEE Trans. on Audio and Electroacoustics</em>, December 1973, pp. 554&ndash;556.</p>
<p class="chapterendnote"><a id="calibre_link-1268"></a>[12] Bingham, C., Godfrey, M., and Tukey, J. “Modern Techniques for Power Spectrum Estimation,” <em class="calibre7">IEEE Trans. on Audio and Electroacoust.</em>, Vol. AU-15, No. 2, June 1967.</p>
<p class="chapterendnote"><a id="calibre_link-3418"></a>[13] Bergland, G. “A Guided Tour of the Fast Fourier Transform,” <em class="calibre7">IEEE Spectrum Magazine,</em> July 1969, p. 47.</p>
<p class="chapterendnote"><a id="calibre_link-1269"></a>[14] Harris, F. “On the Use of Windows for Harmonic Analysis with the Discrete Fourier Transform,” <em class="calibre7">Proceedings of the IEEE,</em> Vol. 66, No. 1, January 1978.</p>
<p class="chapterendnote"><a id="calibre_link-1272"></a>[15] Nuttall, A. “Some Windows with Very Good Sidelobe Behavior,” <em class="calibre7">IEEE Trans. on Acoust. Speech, and Signal Proc.,</em> Vol. ASSP-29, No. 1, February 1981.</p>
<p class="chapterendnote"><a id="calibre_link-1274"></a>[16] Cox, R. “Complex-Multiply Code Saves Clocks Cycles,” <em class="calibre7">EDN</em>, June 25, 1987.</p>
<p class="chapterendnote"><a id="calibre_link-1278"></a>[17] Rabiner, L., and Gold, B. <em class="calibre7">Theory and Application of Digital Signal Processing</em>, Prentice Hall, Englewood Cliffs, New Jersey, 1975.</p>
<p class="chapterendnote"><a id="calibre_link-3419"></a>[18] Sorenson, H., Jones, D., Heideman, M., and Burrus, C. “Real-Valued Fast Fourier Transform Algorithms,” <em class="calibre7">IEEE Trans. on Acoust. Speech, and Signal Proc.,</em> Vol. ASSP-35, No. 6, June 1987.</p>
<p class="chapterendnote"><a id="calibre_link-1279"></a>[19] Cooley, J., Lewis, P., and Welch, P. “The Fast Fourier Transform Algorithm: Programming Considerations in the Calculation of Sine, Cosine and Laplace Transforms,” <em class="calibre7">Journal Sound Vib.</em>, Vol. 12, July 1970.</p>
<p class="chapterendnote"><a id="calibre_link-1304"></a>[20] Brigham, E. <em class="calibre7">The Fast Fourier Transform and Its Applications</em>, Prentice Hall, Englewood Cliffs, New Jersey, 1988.</p>
<p class="chapterendnote"><a id="calibre_link-1328"></a>[21] Burrus, C., et al. <em class="calibre7">Computer-Based Exercises for Signal Processing</em>, Prentice Hall, Englewood Cliffs, New Jersey, 1994, p. 53.</p>
<p class="chapterendnote"><a id="calibre_link-1341"></a>[22] Hewlett-Packard, “The Dynamic Range Benefits of Large-Scale Dithered Analog-to-Digital Conversion, <em class="calibre7">HP Product Note</em>: 89400-7.</p>
<p class="chapterendnote"><a id="calibre_link-1342"></a>[23] Blesser, B., and Locanthi, B. “The Application of Narrow-Band Dither Operating at the Nyquist Frequency in Digital Systems to Provide Improved Signal-to-Noise Ratio over Conventional Dithering,” <em class="calibre7">J. Audio Eng. Soc.</em>, Vol. 35, June 1987.</p>
<p class="chapterendnote"><a id="calibre_link-3420"></a><a id="calibre_link-1344"></a>[24] Coleman, B., et al. “Coherent Sampling Helps When Specifying DSP A/D Converters,” <em class="calibre7">EDN</em>, October 1987.</p>
<p class="chapterendnote"><a id="calibre_link-3421"></a>[25] Ushani, R. “Classical Tests Are Inadequate for Modern High-Speed Converters,” <em class="calibre7">EDN Magazine</em>, May 9, 1991.</p>
<p class="chapterendnote"><a id="calibre_link-1345"></a>[26] Meehan, P., and Reidy, J. “FFT Techniques Give Birth to Digital Spectrum Analyzer,” <em class="calibre7">Electronic Design</em>, August 11, 1988, p. 120.</p>
<p class="chapterendnote"><a id="calibre_link-1356"></a>[27] Beadle, E. “Algorithm Converts Random Variables to Normal,” <em class="calibre7">EDN Magazine</em>, May 11, 1995.</p>
<p class="chapterendnote"><a id="calibre_link-1358"></a>[28] Spiegel, M. <em class="calibre7">Theory and Problems of Statistics</em>, Shaum’s Outline Series, McGraw-Hill, New York, 1961, p. 142.</p>
<p class="chapterendnote"><a id="calibre_link-3422"></a>[29] Davenport, W., Jr., and Root, W. <em class="calibre7">Random Signals and Noise</em>, McGraw-Hill, New York, 1958.</p>
<p class="chapterendnote"><a id="calibre_link-1359"></a>[30] Salibrici, B. “Fixed-Point DSP Chip Can Generate Real-Time Random Noise,” <em class="calibre7">EDN Magazine</em>, April 29, 1993.</p>
<p class="chapterendnote"><a id="calibre_link-1362"></a>[31] Marsaglia, G., and Tsang, W. “The Ziggurat Method for Generating Random Variables,” <em class="calibre7">Journal of Statistical Software</em>, Vol. 5, No. 8, 2000.</p>
<p class="chapterendnote"><a id="calibre_link-3423"></a>[32] <em class="calibre7"><a href="http://finmath.uchicago.edu/~wilder/Code/random/Papers/Marsaglia_00_ZMGRV.pdf">http://finmath.uchicago.edu/~wilder/Code/random/Papers/Marsaglia_00_ZMGRV.pdf</a>.</em></p>
<p class="chapterendnote"><a id="calibre_link-1363"></a>[33] <em class="calibre7"><a href="http://www.jstatsoft.org/v05/i08/ziggurat.pdf">http://www.jstatsoft.org/v05/i08/ziggurat.pdf</a>.</em></p>
<p class="chapterendnote"><a id="calibre_link-1367"></a>[34] Donadio, M. “Lost Knowledge Refound: Sharpened FIR Filters,” <em class="calibre7">IEEE Signal Processing Magazine</em>, Vol. 20, No. 5, September 2003, pp. 61&ndash;63.</p>
<p class="chapterendnote"><a id="calibre_link-1371"></a>[35] Kwentus, A., et al. “Application of Filter Sharpening to Cascaded Integrator-Comb Decimation Filters,” <em class="calibre7">IEEE Transactions on Signal Processing</em>, Vol. 45, February 1997, pp. 457&ndash;467.</p>
<p class="chapterendnote"><a id="calibre_link-1372"></a>[36] Gentili, P., et al. “Improved Power-of-Two Sharpening Filter Design by Genetic Algorithm,” 1996 IEEE Conference on Acoustics, Speech and Signal Processing (ICASSP ‘96), Atlanta, Georgia, Vol. 3, 1996, p. 1375.</p>
<p class="chapterendnote"><a id="calibre_link-1373"></a>[37] Graychip Inc. “Upconverting Signals with the GC2011 for Easier Digital to Analog Conversion,” Application Note: GC2011-AN9804, December 20, 1998.</p>
<p class="chapterendnote"><a id="calibre_link-1375"></a>[38] Donadio, M., private communication, September 11, 2003.</p>
<p class="chapterendnote"><a id="calibre_link-1381"></a>[39] Jacobsen, E., and Kootsookos, P. “Fast, Accurate Frequency Estimators,” <em class="calibre7">IEEE Signal Processing Magazine,</em> “DSP Tips &amp; Tricks” column, Vol. 24, No. 3, May 2007.</p>
<p class="chapterendnote"><a id="calibre_link-1384"></a>[40] Nagai, K. “Pruning the Decimation-in-Time FFT Algorithm with Frequency Shift,” <em class="calibre7">IEEE Trans. on ASSP</em>, Vol. ASSP-34, August 1986, pp. 1008&ndash;1010.</p>
<p class="chapterendnote"><a id="calibre_link-3424"></a>[41] Skinner, D. “Pruning the Decimation-in-Time FFT Algorithm,” <em class="calibre7">IEEE Trans. on ASSP</em>, Vol. ASSP-24, April 1976, pp. 193&ndash;194.</p>
<p class="chapterendnote"><a id="calibre_link-3425"></a><a id="calibre_link-3426"></a>[42] Markel, J. D. “FFT Pruning,” <em class="calibre7">IEEE Trans on Audio Electroacoust</em>., Vol. AU-19, December 1971, pp. 305&ndash;311.</p>
<p class="chapterendnote"><a id="calibre_link-1385"></a>[43] Sreenivas, T., and Rao, P. “FFT Algorithm for Both Input and Ouput Pruning,” <em class="calibre7">IEEE Trans. on ASSP</em>, Vol. ASSP-27, June 1979, pp. 291&ndash;292.</p>
<p class="chapterendnote"><a id="calibre_link-1386"></a>[44] Lyons, R. “Program Aids Analysis of FFT Algorithms,” <em class="calibre7">EDN Magazine</em>, August 6, 1987.</p>
<p class="chapterendnote"><a id="calibre_link-1391"></a>[45] Goertzel, G. “An Algorithm for the Evaluation of Finite Trigonometric Series,” <em class="calibre7">American Math. Monthly,</em> Vol. 65, 1958, pp. 34&ndash;35.</p>
<p class="chapterendnote"><a id="calibre_link-3427"></a>[46] Proakis, J., and Manolakis, D. <em class="calibre7">Digital Signal Processing: Principles, Algorithms, and Applications,</em> 3rd ed., Prentice Hall, Upper Saddle River, New Jersey, 1996, pp. 480&ndash;481.</p>
<p class="chapterendnote"><a id="calibre_link-1392"></a>[47] Oppenheim, A., Schafer, R., and Buck, J. <em class="calibre7">Discrete-Time Signal Processing,</em> 2nd ed., Prentice Hall, Upper Saddle River, New Jersey, 1999, pp. 633&ndash;634.</p>
<p class="chapterendnote"><a id="calibre_link-1411"></a>[48] Farhang-Boroujeny, B., and Lim, Y. “A Comment on the Computational Complexity of Sliding FFT,” <em class="calibre7">IEEE Trans. Circuits and Syst. II,</em> Vol. 39, No. 12, December 1992, pp. 875&ndash;876.</p>
<p class="chapterendnote"><a id="calibre_link-1412"></a>[49] Farhang-Boroujeny, B., and Gazor, S. “Generalized Sliding FFT and Its Application to Implementation of Block LMS Adaptive Filters,” <em class="calibre7">IEEE Trans. Sig. Proc.</em>, Vol. 42, No. 3, March 1994, pp. 532&ndash;538.</p>
<p class="chapterendnote"><a id="calibre_link-1415"></a>[50] Douglas, S., and Soh, J. “A Numerically-Stable Sliding-Window Estimator and Its Application to Adaptive Filters,” <em class="calibre7">Proc. 31st Annual Asilomar Conf. on Signals, Systems, and Computers</em>, Pacific Grove, California, Vol. 1, November 1997, pp. 111&ndash;115.</p>
<p class="chapterendnote"><a id="calibre_link-1428"></a>[51] Crochiere, R., and Rabiner, L. <em class="calibre7">Multirate Digital Signal Processing</em>, Prentice Hall, Englewood Cliffs, New Jersey, 1983, pp. 315&ndash;319.</p>
<p class="chapterendnote"><a id="calibre_link-1429"></a>[52] Zoran Corp. “Vernier Spectral Analysis with the ZR34161 Vector Signal Processor,” <em class="calibre7">Tech. Note ZAN34003</em>, Santa Clara, California, 1989.</p>
<p class="chapterendnote"><a id="calibre_link-1430"></a>[53] Gumas, C. “Window-Presum FFT Achieves High-Dynamic Range, Resolution,” <em class="calibre7">Personal Engineering and Instrumentation News</em>, July 1997, pp. 58&ndash;64.</p>
<p class="chapterendnote"><a id="calibre_link-1438"></a>[54] Hack, T. “IQ Sampling Yields Flexible Demodulators,” <em class="calibre7">RF Design</em>, April 1991.</p>
<p class="chapterendnote"><a id="calibre_link-1439"></a>[55] Bateman, A. “Quadrature Frequency Discriminator,” <em class="calibre7">GlobalDSP Magazin</em>e, October 2002.</p>
<p class="chapterendnote"><a id="calibre_link-1446"></a>[56] <em class="calibre7"><a href="http://aulos.calarts.edu/pipermail/test/1998-March/001028.html">http://aulos.calarts.edu/pipermail/test/1998-March/001028.html</a>.</em></p>
<p class="chapterendnote"><a id="calibre_link-1453"></a>[57] Dick, C., and Harris, F. “FPGA Signal Processing Using Sigma-Delta Modulation,” <em class="calibre7">IEEE Signal Proc. Magazine</em>, Vol. 17, No. 1, January 2000.</p>
<p class="chapterendnote"><a id="calibre_link-1447"></a>[58] Bateman, A. “Implementing a Digital AC Coupling Filter,” <em class="calibre7">GlobalDSP Magazine</em>, February 2003.</p>
<p class="chapterendnote"><a id="calibre_link-1454"></a>[59] Shenoi, K. <em class="calibre7">Digital Signal Processing in Communications Systems,</em> Chapman &amp; Hall, New York, 1994, p. 275.</p>
<p class="chapterendnote"><a id="calibre_link-3428"></a>[60] Bristow-Johnson, R. “Subject: Fixed-PointDC Blocking Filter with Noise Shaping,” Usenet group <em class="calibre7">comp.dsp</em> post, June 22, 2000.</p>
<p class="chapterendnote"><a id="calibre_link-3429"></a><a id="calibre_link-1455"></a>[61] Bristow-Johnson, R. “Subject: Virtues of Noise Shaping,” Usenet group <em class="calibre7">comp.dsp</em> post, August 21, 2001.</p>
<p class="chapterendnote"><a id="calibre_link-1456"></a>[62] Ascari, L., et al. “Low Power Implementation of a Sigma Delta Decimation Filter for Cardiac Applications,” <em class="calibre7">IEEE Instrumentation and Measurement Technology Conference</em>, Budapest, Hungary, May 21&ndash;23, 2001, pp. 750&ndash;755.</p>
<p class="chapterendnote"><a id="calibre_link-1462"></a>[63] Gao, Y., et al. “Low-Power Implementation of a Fifth-Order Comb Decimation Filter for Multi-Standard Transceiver Applications,” Int. Conf. on Signal Proc. Applications and Technology (ICSPAT), Orlando, Florida, 1999.</p>
<p class="chapterendnote"><a id="calibre_link-1457"></a>[64] Gao, Y., et al. “A Comparison Design of Comb Decimators for Sigma-Delta Analog-to-Digital Converters,” <em class="calibre7">Int. Journal: Analog Integrated Circuits and Signal Processin</em>g, Kluwer Academic Publishers, ISSN: 0925&ndash;1030, 1999.</p>
<p class="chapterendnote"><a id="calibre_link-1464"></a>[65] Ballanger, M., et al. “Digital Filtering by Polyphase Network: Application to Sample-Rate Alteration and Filter Banks,” <em class="calibre7">IEEE Trans. on Acoust. Speech, and Signal Proc.</em>, Vol. ASSP-24, No. 2, April 1976, pp. 109&ndash;114.</p>
<p class="chapterendnote"><a id="calibre_link-3430"></a>[66] Brandt, B., and Wooley, B. “A Low-Power Area-Efficient Digital Filter for Decimation and Interpolation,” <em class="calibre7">IEEE Journ. of Solid-State Circuits</em>, Vol. 29, June 1994, pp. 679&ndash;687.</p>
<p class="chapterendnote"><a id="calibre_link-3431"></a>[67] Willson, A., Jr. “A Programmable Interpolation Filter for Digital Communications Applications,” Final report for MICRO Project 96&ndash;149, UCLA, 1996&ndash;1997.</p>
<p class="chapterendnote"><a id="calibre_link-3432"></a>[68] Dumonteix, Y., et al. “Low Power Comb Decimation Filter Using Polyphase Decomposition for Mono-Bit ΣΔ Analog-to-Digital Converters,” Int. Conf. on Signal Processing Applications and Technology (ICSPAT), San Jose, California, 2000.</p>
<p class="chapterendnote"><a id="calibre_link-1465"></a>[69] Yang, H., and Snelgrove, W. “High Speed Polyphase CIC Decimation Filters,” <em class="calibre7">IEEE Int. Symposium on Circuits and Systems</em>, Vol. 2, 1996, pp. 229&ndash;232.</p>
<p class="chapterendnote"><a id="calibre_link-1469"></a>[70] Jang, Y., and Yang, S. “Non-Recursive Cascaded Integrator-Comb Decimation Filters with Integer Multiple Factors,” 44th IEEE Midwest Symposium on Circuits and Systems (MWSCAS), Dayton, Ohio, August 2001.</p>
<p class="chapterendnote"><a id="calibre_link-1472"></a>[71] Dvorak, R. “Software Filter Boosts Signal-Measurement Stability, Precision,” <em class="calibre7">Electronic Design</em>, February 3, 2003.</p>
<p class="chapterendnote"><a id="calibre_link-1473"></a>[72] Lynn, P., and Fuerst, W. <em class="calibre7">Introductory Digital Signal Processing, with Computer Applications,</em> John Wiley and Sons, New York, 1997, pp. 285&ndash;297.</p>
<p class="chapterendnote"><a id="calibre_link-1477"></a>[73] Givens, M., private communication, October 12, 2004.</p>
<p class="chapterendnote"><a id="calibre_link-1487"></a>[74] Fraser, D. “Interpolation by the FFT Revisited&mdash;An Experimental Investigation,” <em class="calibre7">IEEE Trans. on Acoust. Speech, and Signal Proc.</em>, Vol. ASSP-37, No. 5, May 1989, pp. 665&ndash;676.</p>
<p class="chapterendnote"><a id="calibre_link-1490"></a>[75] Marple, S., Jr. “Computing the Discrete-Time ‘Analytic’ Signal via FFT,” <em class="calibre7">IEEE Trans. on Signal Proc.</em>, Vol. 47, No. 9, September 1999, pp. 2600&ndash;2603.</p>
<p class="chapterendnote"><a id="calibre_link-1493"></a>[76] Harris, F. “T102: Digital Signal Processing for Digital Modems,” DSP World Spring Design Conf., Santa Clara, California, April 1999.</p>
<p class="chapterendnote"><a id="calibre_link-3433"></a><a id="calibre_link-1494"></a>[77] Harris, F. “On the Design, Implementation, and Performance of a Microprocessor-Controlled AGC System for a Digital Receiver,” IEEE Military Communications Conf., San Diego, Caliornia, October 1988.</p>
<p class="chapterendnote"><a id="calibre_link-1496"></a>[78] Analog Devices, Inc. “80 MSPS, Dual-Channel WCDMA Receive Signal Processor (RSP) AD6634,” Data Sheet Rev. 0, 2002, pp. 28&ndash;34.</p>
<p class="chapterendnote"><a id="calibre_link-1502"></a>[79] Turner, C. “Recursive Discrete-Time Sinusoidal Oscillators,” <em class="calibre7">IEEE Signal Processing Magazine,</em> Vol. 20, No. 3, May 2003, pp. 103&ndash;111.</p>
<p class="chapterendnote"><a id="calibre_link-1504"></a>[80] Paillard, B., and Boudreau, A. “Fast, Continuous, Sinewave Generator,” <em class="calibre7">GlobalDSP On-line Magazine,</em> December 2003.</p>
<p class="chapterendnote"><a id="calibre_link-1507"></a>[81] Vassilevsky, V. “Efficient Multi-tone Detection,” <em class="calibre7">IEEE Signal Processing Magazine,</em> “DSP Tips &amp; Tricks” column, Vol. 24 , No. 2, March 2007.</p>
<p class="chapterendnote"><a id="calibre_link-964"></a>[82] Shiung, D., Ferng, H., and Lyons, R. “Filtering Tricks for FSK Demodulation,” <em class="calibre7">IEEE Signal Processing Magazine,</em> “DSP Tips &amp; Tricks” column, Vol. 22, No. 3, May 2005.</p>
<p class="chapterendnote"><a id="calibre_link-970"></a>[83] Spiegel, M. <em class="calibre7">Statistics,</em> Shaum’s Outline Series, McGraw-Hill, New York, 1961, p. 77.</p>
<p class="chapterendnote"><a id="calibre_link-976"></a>[84] Hadstate, J. “Subject: Re: Question about Computing a “Moving Variance,” Usenet group <em class="calibre7">comp.dsp</em> post, March 1, 2005.</p>
<p class="chapterendnote"><a id="calibre_link-979"></a>[85] Turner, C. “Subject: Re: Question About Computing a “Moving Variance,” Usenet group <em class="calibre7">comp.dsp</em> post, February 27, 2005.</p>
<p class="chapterendnote"><a id="calibre_link-981"></a>[86] Jackson, L. “On the Relationship Between Digital Hilbert Transformers and Certain Low-Pass Filters,” <em class="calibre7">IEEE Trans. on Acoust. Speech, and Signal Proc.,</em> Vol. ASSP-23, No. 4, August 1975.</p>
<p class="chapterendnote"><a id="calibre_link-982"></a>[87] Harris, F. <em class="calibre7">Multirate Signal Processing for Communication Systems</em>, Prentice Hall, Upper Saddle River, New Jersey, 2004, pp. 210&ndash;212.</p>
<p class="chapterendnote"><a id="calibre_link-994"></a>[88] Turner, C. “Subject: How Do You Rotate a Phasor by pi/8 Radians,” Usenet group <em class="calibre7">comp.dsp</em> post, May 29, 2002.</p>
<p class="chapterendnote"><a id="calibre_link-1002"></a>[89] Press, W., et al., <em class="calibre7">Numerical Recipes in C: The Art of Scientific Computing</em>, 2nd ed. Cambridge University Press, New York, 1992, p. 177.</p>
<p class="chapterendnote"><a id="calibre_link-1003"></a>[90] Losada, R., and Lyons, R. “Reducing CIC Filter Complexity,” <em class="calibre7">IEEE Signal Processing Magazine,</em> “DSP Tips and Tricks” column, Vol. 23, No. 4, July 2006.</p>
<p class="chapterendnote"><a id="calibre_link-1005"></a>[91] Ohlsson, H., et al. “Design of a Digital Down Converter Using High Speed Digital Filters,” in <em class="calibre7">Proc. Symp. on Gigahertz Electronics</em>, Gothenburg, Sweden, March 13&ndash;14, 2000, pp. 309&ndash;312.</p>
<p class="chapterendnote"><a id="calibre_link-1009"></a>[92] Turner, C. “Slope Filtering: An FIR Approach to Linear Regression,” <em class="calibre7">IEEE Signal Processing Magazine,</em> “DSP Tips &amp; Tricks” column, Vol. 25, No. 6, November 2008.</p>
<p class="chapterendnote"><a id="calibre_link-1014"></a>[93] Bell, D. “Subject: Re: Frequency Inversion,” Usenet group <em class="calibre7">comp.dsp</em> post, August 30, 2006.</p>
<p class="chapterendnote"><a id="calibre_link-1015"></a>[94] Adams, R. “Nonuniform Sampling of Audio Signals,” <em class="calibre7">J. Audio Eng. Soc.</em>, Vol. 40, No. 11, November 1992, pp. 886&ndash;894.</p>
<p class="chapterendnote"><a id="calibre_link-3434"></a><a id="calibre_link-1021"></a>[95] Bariska, A. “Recovering Periodically-Spaced Missing Samples,” <em class="calibre7">IEEE Signal Processing Magazine,</em> “DSP Tips and Tricks” column, Vol. 24, No. 6, November 2007.</p>
<p class="chapterendnote"><a id="calibre_link-1032"></a>[96] Moshe, S., and Hertz, D. “On Computing DFT of Real N-Point Vector and IDFT of DFT-Transformed Real N-Point Vector via Single DFT,” <em class="calibre7">IEEE Signal Processing Letters</em>, IEEE, Vol. 6, No. 6, June 1999, p. 141.</p>
<p class="chapterendnote"><a id="calibre_link-1035"></a>[97] Proakis, J., and Manolakis, D. <em class="calibre7">Digital Signal Processing: Principles, Algorithms, and Applications</em>, 3rd ed., Prentice Hall, Upper Saddle River, New Jersey, 1996, pp. 572&ndash;576.</p>
<p class="chapterendnote"><a id="calibre_link-1036"></a>[98] Oppenheim, A., and Schafer, R. <em class="calibre7">Discrete</em>-<em class="calibre7">Time Signal Processing</em>, 2nd ed., Prentice Hall, Englewood Cliffs, New Jersey, 1989, pp. 382&ndash;386.</p>
<p class="chapterendnote"><a id="calibre_link-1038"></a>[99] Gold, B., and Rader, C. “Effects of Parameter Quantization on the Poles of a Digital Filter,” <em class="calibre7">Proceedings of the IEEE</em>, Vol. 55, May 1967, pp. 688&ndash;689.</p>
<p class="chapterendnote"><a id="calibre_link-1039"></a>[100] Harris, F., and Lowdermilk, W. “Implementing Recursive Filters with Large Ratio of Sample Rate to Bandwidth,” in <em class="calibre7">Conference Record of the Forty-first Asilomar Conference on Signals, Systems and Computers</em>, Pacific Grove, California, November 4&ndash;7, 2007, pp. 1149&ndash;1153.</p>
</div>


</body></html>
