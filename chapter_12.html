<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="style_edited.css" rel="stylesheet" type="text/css" /><title>Understanding Digital Signal Processing</title>
<style type="text/css">
body {
  -webkit-text-size-adjust: 260%; /* text */
  zoom: 1.7; /* graphics */
  font-family: "BookerlyLCD";
}
a {
  color: #005090;
  text-decoration: none;
}
a {font-variant-numeric: oldstyle-nums proportional-nums;}
p.caption {font-variant-numeric: oldstyle-nums proportional-nums;}
</style>
</head><body>


<div class="calibre" id="calibre_link-572">
<p class="calibre3"><a id="calibre_link-2482"></a></p>
<h2 class="calibre8"><a id="calibre_link-2483" class="calibre5"></a>Contents</h2>
<p class="toc-chapter1"><strong class="calibre9"><a href="#calibre_link-4">12 DIGITAL DATA FORMATS AND THEIR EFFECTS</a></strong></p>
<p class="toc-section"><a href="#calibre_link-671">12.1 Fixed-Point Binary Formats</a></p>
<p class="toc-section"><a href="#calibre_link-672">12.2 Binary Number Precision and Dynamic Range</a></p>
<p class="toc-section"><a href="#calibre_link-516">12.3 Effects of Finite Fixed-Point Binary Word Length</a></p>
<p class="toc-section"><a href="#calibre_link-673">12.4 Floating-Point Binary Formats</a></p>
<p class="toc-section"><a href="#calibre_link-674">12.5 Block Floating-Point Binary Format</a></p>
<p class="toc-section1"><a href="#calibre_link-675">References</a></p>
<p class="toc-section1"><a href="#calibre_link-676">Chapter 12 Problems</a></p>

</div>


<div class="calibre" id="calibre_link-4">
<p class="calibre3"><a id="calibre_link-292"></a></p>
<h2 class="calibre8"><a id="calibre_link-2027" class="calibre5"></a>12 Digital Data Formats and Their Effects</h2>
<p class="image"><img src="images/001049.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">In digital signal processing, there are many ways to represent numerical data in computing hardware. These representations, known as <em class="calibre7">data formats</em>, have a profound effect on the accuracy and ease of implementation of any given signal processing algorithm. The simpler data formats enable uncomplicated hardware designs to be used at the expense of a restricted range of number representation and susceptibility to arithmetic errors. The more elaborate data formats are somewhat difficult to implement in hardware, but they allow us to manipulate very large and very small numbers while providing immunity to many problems associated with digital arithmetic. The data format chosen for any given application can mean the difference between processing success and failure&mdash;it’s where our algorithmic rubber meets the road.</p>
<p class="calibre3">In this chapter, we’ll introduce the most common types of <em class="calibre7">fixed-point</em> digital data formats and show why and when they’re used. Next, we’ll use analog-to-digital (A/D) converter operations to establish the precision and dynamic range afforded by these fixed-point formats along with the inherent errors encountered with their use. Finally, we’ll cover the interesting subject of <em class="calibre7">floating-point</em> binary formats.</p>
<p class="calibre3"><a id="calibre_link-671"></a></p>
<h3 class="calibre6">12.1 Fixed-Point Binary Formats</h3>
<p class="calibre3">Within digital hardware, numbers are represented by binary digits known as bits&mdash;in fact, the term <em class="calibre7">bit</em> originated from the words <em class="calibre7">Binary digIT.</em> A single bit can be in only one of two possible states: either a one or a zero.<sup class="calibre10"><a id="calibre_link-6"></a><a href="#calibre_link-5">†</a></sup> A six-bit <a id="calibre_link-2004"></a>binary number could, for example, take the form 101101, with the leftmost bit known as the <em class="calibre7">most significant bit</em> (msb); the rightmost bit is called the <em class="calibre7">least significant bit</em> (lsb). The number of bits in a binary number is known as the <em class="calibre7">word length</em>&mdash;hence 101101 has a word length of six. Like the decimal number system so familiar to us, the binary number system assumes a weight associated with each digit in the number. That weight is the base of the system (two for binary numbers and ten for decimal numbers) raised to an integral power. To illustrate this with a simple example, the decimal number 4631 is</p>
<p class="footnotes"><a id="calibre_link-5"></a><sup class="calibre11"><a href="#calibre_link-6">†</a></sup> Binary numbers are used because early electronic computer pioneers quickly realized that it was much more practical and reliable to use electrical devices (relays, vacuum tubes, transistors, etc.) that had only two states, <em class="calibre7">on</em> or <em class="calibre7">off</em>. Thus, the on/off state of a device could represent a single binary digit.</p>
<p class="caption"><a id="calibre_link-7"></a>(12-1)</p>
<p class="image"><img src="images/001523.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The factors 10<sup class="calibre10">3</sup>, 10<sup class="calibre10">2</sup>, 10<sup class="calibre10">1</sup>, and 10<sup class="calibre10">0</sup> are the digit weights in <a href="#calibre_link-7">Eq. (12-1)</a>. Similarly, the six-bit binary number 101101 is equal to decimal 45 as shown by</p>
<p class="caption"><a id="calibre_link-8"></a>(12-2)</p>
<p class="image"><img src="images/000344.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Using subscripts to signify the base of a number, we can write <a href="#calibre_link-8">Eq. (12-2)</a> as 101101<sub class="calibre12">2</sub> = 45<sub class="calibre12">10</sub>. <a href="#calibre_link-8">Equation (12-2)</a> shows us that, like decimal numbers, binary numbers use the <em class="calibre7">place value</em> system where the position of a digit signifies its weight. If we use <em class="calibre7">B</em> to denote a number system’s base, the place value representation of the four-digit number <em class="calibre7">a</em><sub class="calibre12">3</sub><em class="calibre7">a</em><sub class="calibre12">2</sub><em class="calibre7">a</em><sub class="calibre12">1</sub><em class="calibre7">a</em><sub class="calibre12">0</sub> is</p>
<p class="caption"><a id="calibre_link-9"></a>(12-3)</p>
<p class="image"><img src="images/001306.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">In <a href="#calibre_link-9">Eq. (12-3)</a>, <em class="calibre7">B<sup class="calibre10">n</sup></em> is the weight multiplier for the digit <em class="calibre7">a<sub class="calibre12">n</sub></em>, where 0 ≤ <em class="calibre7">a<sub class="calibre12">n</sub></em> ≤ <em class="calibre7">B</em>−1. (This place value system of representing numbers is very old&mdash;so old, in fact, that its origin is obscure. However, with its inherent positioning of the decimal or binary point, this number system is so convenient and powerful that its importance has been compared to that of the alphabet<a href="#calibre_link-10">[1]</a>.)</p>
<p class="calibre3"><a id="calibre_link-3150"></a></p>
<h4 class="calibre13">12.1.1 Octal Numbers</h4>
<p class="calibre3">As the use of minicomputers and microprocessors rapidly expanded in the 1960s, people grew tired of manipulating long strings of ones and zeros on paper and began to use more convenient ways to represent binary numbers. One way to express a binary number is an octal format, with its base of eight. (Of course, the only valid digits in the octal format are 0 to 7&mdash;the digits 8 and 9 have no meaning in octal representation.)</p>
<p class="calibre3">Converting from binary to octal is as simple as separating the binary number into three-bit groups starting from the right. For example, the binary number 10101001<sub class="calibre12">2</sub> can be converted to octal format as</p>
<p class="center"><strong class="calibre9">10101001<sub class="calibre12">2</sub></strong> →&nbsp;&nbsp;&nbsp;&nbsp;10 <sub class="calibre12">|</sub> 101 <sub class="calibre12">|</sub> 001 = 251<sub class="calibre12">8</sub>.</p>
<p class="calibre3"><a id="calibre_link-2005"></a>Thus the octal format enables us to represent an eight-digit binary value with a simpler three-digit octal value. However, the relentless march of technology is pushing octal numbers, like wooden tennis rackets, into extinction.</p>
<p class="calibre3"><a id="calibre_link-3151"></a></p>
<h4 class="calibre13">12.1.2 Hexadecimal Numbers</h4>
<p class="calibre3">Today the predominant binary number representation format is the hexadecimal number format using 16 as its base. Converting from binary to hexadecimal is done, this time, by separating the binary number into four-bit groups starting from the right. The binary number 10101001<sub class="calibre12">2</sub> is converted to hexadecimal format as</p>
<p class="center"><strong class="calibre9">10101001<sub class="calibre12">2</sub></strong> →&nbsp;&nbsp;&nbsp;&nbsp;1010 <sub class="calibre12">|</sub> 1001 = <em class="calibre7">A</em>9<sub class="calibre12">16</sub>.</p>
<p class="calibre3">If you haven’t seen the hexadecimal format used before, don’t let the <em class="calibre7">A</em>9 digits confuse you. In this format, the characters A, B, C, D, E, and F represent the digits whose decimal values are 10, 11, 12, 13, 14, and 15 respectively. We convert the two groups of bits above to two hexadecimal digits by starting with the left group of bits, 1010<sub class="calibre12">2</sub> = 10<sub class="calibre12">10</sub> = <em class="calibre7">A</em><sub class="calibre12">16</sub>, and 1001<sub class="calibre12">2</sub> = 9<sub class="calibre12">10</sub> = 9<sub class="calibre12">16</sub>. Hexadecimal format numbers also use the place value system, meaning that <em class="calibre7">A</em>9<sub class="calibre12">16</sub> = (<strong class="calibre9"><em class="calibre7">A</em></strong> · 16<sup class="calibre10">1</sup> + <strong class="calibre9">9</strong> · 16<sup class="calibre10">0</sup>). For convenience, then, we can represent the eight-digit 10101001<sub class="calibre12">2</sub> with the two-digit number <em class="calibre7">A</em>9<sub class="calibre12">16</sub>. <a href="#calibre_link-11">Table 12-1</a> lists the permissible digit representations in the number systems discussed thus far.</p>
<p class="caption"><a id="calibre_link-11"></a><strong class="calibre9">Table 12-1</strong> Allowable Digit Representations versus Number System Base</p>
<p class="image"><img src="images/001561.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">In the above example we used a subscripted 16 to signify a hexadecimal number. Note that it’s common, in the literature of binary number formats, to have hexadecimal numbers preceded by special characters to signify that indeed they are hexadecimal. You may see, for example, numbers like $A9 or 0xA9 where the “$” and “0x” characters specify the follow-on digits to be hexadecimal.</p>
<p class="calibre3"><a id="calibre_link-3152"></a></p>
<h4 class="calibre13">12.1.3 Sign-Magnitude Binary Format</h4>
<p class="calibre3">For binary numbers to be at all useful in practice, they must be able to represent negative values. Binary numbers do this by dedicating one of the bits in a binary word to indicate the sign of a number. Let’s consider a popular binary format known as <em class="calibre7">sign magnitude.</em> Here, we assume that a binary word’s leftmost bit is a sign bit and the remaining bits represent the magnitude of a number that is always positive. For example, we can say that the four-bit number 0011<sub class="calibre12">2</sub> is +3<sub class="calibre12">10</sub> and the binary number 1011<sub class="calibre12">2</sub> is equal to −3<sub class="calibre12">10</sub>, or</p>
<p class="image"><img src="images/001650.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2256"></a>Of course, using one of the bits as a sign bit reduces the magnitude of the numbers we can represent. If an unsigned binary number’s word length is <em class="calibre7">b</em> bits, the number of different values that can be represented is 2<em class="calibre7"><sup class="calibre10">b</sup></em>. An eight-bit word, for example, can represent 2<sup class="calibre10">8</sup> = 256 different integral values. With zero being one of the values we have to express, a <em class="calibre7">b</em>-bit unsigned binary word can represent integers from 0 to 2<em class="calibre7"><sup class="calibre10">b</sup></em>−1. The largest value represented by an unsigned eight-bit word is 2<sup class="calibre10">8</sup>−1 = 255<sub class="calibre12">10</sub> = 11111111<sub class="calibre12">2</sub>. In the sign-magnitude binary format a <em class="calibre7">b</em>-bit word can represent only a magnitude of ±2<sup class="calibre10"><em class="calibre7">b</em>−1</sup>−1, so the largest positive or negative value we can represent by an eight-bit sign-magnitude word is ±2<sup class="calibre10">8−1</sup>−1 = ±127.</p>
<p class="calibre3"><a id="calibre_link-3153"></a></p>
<h4 class="calibre13">12.1.4 Two’s Complement Format</h4>
<p class="calibre3">Another common binary number scheme, known as the <em class="calibre7">two’s complement</em> format, also uses the leftmost bit as a sign bit. The two’s complement format is the most convenient numbering scheme from a hardware design standpoint and has been used for decades. It enables computers to perform both addition and subtraction using the same hardware adder logic. To obtain the negative <a id="calibre_link-2255"></a>version of a positive two’s complement number, we merely complement (change a one to a zero, and change a zero to a one) each bit, add a binary one to the complemented word, and discard any bits carried beyond the original word length. For example, with 0011<sub class="calibre12">2</sub> representing a decimal 3 in two’s complement format, we obtain a negative decimal 3 through the following steps:</p>
<p class="image"><img src="images/000509.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">In the two’s complement format, a <em class="calibre7">b</em>-bit word can represent positive amplitudes as great as 2<sup class="calibre10"><em class="calibre7">b</em>−1</sup>−1, and negative amplitudes as large as −<em class="calibre7">2<sup class="calibre10">b</sup></em><sup class="calibre10">−1</sup>. <a href="#calibre_link-12">Table 12-2</a> shows four-bit word examples of sign-magnitude and two’s complement binary formats.</p>
<p class="caption"><a id="calibre_link-12"></a><strong class="calibre9">Table 12-2</strong> Integer Binary Number Formats</p>
<p class="image"><img src="images/000584.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">While using two’s complement numbers, we have to be careful when adding two numbers of different word lengths. Consider the case where a four-bit number is added to an eight-bit number:</p>
<p class="image"><img src="images/001369.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">No problem so far. The trouble occurs when our four-bit number is negative. Instead of adding a +3 to the +15, let’s try to add a −3 to the +15:</p>
<p class="image"><img src="images/000407.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The above arithmetic error can be avoided by performing what’s called a <em class="calibre7">sign-extend</em> operation on the four-bit number. This process, typically performed automatically in hardware, extends the sign bit of the four-bit negative number to the left, making it an eight-bit negative number. If we sign-extend the −3 and then perform the addition, we’ll get the correct answer:</p>
<p class="image"><img src="images/001258.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3154"></a></p>
<h4 class="calibre13">12.1.5 Offset Binary Format</h4>
<p class="calibre3">Another useful binary number scheme is known as the <em class="calibre7">offset binary</em> format. While this format is not as common as two’s complement, it still shows up in <a id="calibre_link-2010"></a>some hardware devices. <a href="#calibre_link-12">Table 12-2</a> shows offset binary format examples for four-bit words. Offset binary represents numbers by subtracting 2<sup class="calibre10"><em class="calibre7">b</em>−1</sup> from an unsigned binary value. For example, in the second row of <a href="#calibre_link-12">Table 12-2</a>, the offset binary number is 1110<sub class="calibre12">2</sub>. When this number is treated as an unsigned binary number, it’s equivalent to 14<sub class="calibre12">10</sub>. For four-bit words <em class="calibre7">b</em> = 4 and 2<sup class="calibre10"><em class="calibre7">b</em>−1</sup> = 8, so 14<sub class="calibre12">10</sub> − 8<sub class="calibre12">10</sub> = 6<sub class="calibre12">10</sub>, which is the decimal equivalent of 1110<sub class="calibre12">2</sub> in offset binary. The difference between the unsigned binary equivalent and the actual decimal equivalent of the offset binary numbers in <a href="#calibre_link-12">Table 12-2</a> is always −8. This kind of offset is sometimes referred to as a <em class="calibre7">bias</em> when the offset binary format is used. (It may interest the reader that we can convert back and forth between the two’s complement and offset binary formats merely by complementing a word’s most significant bit.)</p>
<p class="calibre3">The history, arithmetic, and utility of the many available number formats is a very broad field of study. A thorough and very readable discussion of the subject is given by Knuth in reference <a href="#calibre_link-13">[2]</a>.</p>
<p class="calibre3"><a id="calibre_link-1479"></a></p>
<h4 class="calibre13"><a id="calibre_link-2021"></a>12.1.6 Fractional Binary Numbers</h4>
<p class="calibre3">All of the binary numbers we’ve considered so far had integer decimal values. Noninteger decimal numbers, numbers with nonzero digits to the right of the decimal point, can also be represented with binary numbers if we use a <em class="calibre7">binary point</em>, also called a <em class="calibre7">radix point</em>, identical in function to our familiar decimal point. (As such, in the binary numbers we’ve discussed so far, the binary point is assumed to be fixed just to the right of the rightmost, lsb, bit.) For example, using the symbol ◊ to denote a binary point, the six-bit unsigned binary number 11<sub class="calibre12">◊</sub>0101<sub class="calibre12">2</sub> is equal to decimal 3.3125 as shown by</p>
<p class="caption"><a id="calibre_link-14"></a>(12-4)</p>
<p class="image"><img src="images/001597.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">For our 11<sub class="calibre12">◊</sub>0101<sub class="calibre12">2</sub> example in <a href="#calibre_link-14">Eq. (12-4)</a> the binary point is set between the second and third most significant bits and we call that binary number a <em class="calibre7">fractional</em> number. Having a stationary position for the binary point is why this binary number format is called <em class="calibre7">fixed-point binary</em>. The unsigned number 11<sub class="calibre12">◊</sub>0101<sub class="calibre12">2</sub> has two integer bits and four fractional bits, so, in the parlance of binary numbers, such a number is said to have a 2.4, “two dot four,” format (two integer bits and four fractional bits).</p>
<p class="calibre3">Two’s complement binary numbers can also have this <em class="calibre7">integer plus fraction</em> format, and <a href="#calibre_link-15">Table 12-3</a> shows, for example, the decimal value ranges for all possible eight-bit two’s complement fractional binary numbers. Notice how the 8.0-format row in <a href="#calibre_link-15">Table 12-3</a> shows the decimal values associated with an eight-bit two’s complement binary number whose binary point is to the right of the lsb, signifying an all-integer binary number. On the other hand, the 1.7-format row in <a href="#calibre_link-15">Table 12-3</a> shows the decimal values associated with an eight-bit two’s complement binary number whose binary point is just to the right of the msb (the sign bit), signifying an all-fraction binary number.</p>
<p class="caption"><a id="calibre_link-15"></a><strong class="calibre9">Table 12-3</strong> Eight-Bit, Two’s Complement, Fractional Format Values</p>
<p class="image"><img src="images/001446.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The decimal value range of a general fractional two’s complement binary number is</p>
<p class="caption"><a id="calibre_link-3155"></a>(12-5)</p>
<p class="image"><img src="images/000415.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where the “# of integer bits” notation means the number of bits to the left of the binary point and “# of fraction bits” means the number of bits to the right of the binary point.</p>
<p class="calibre3"><a href="#calibre_link-15">Table 12-3</a> teaches us two important lessons. First, we can place the implied binary point anywhere we wish in the eight-bit word, just so long as <a id="calibre_link-2095"></a>everyone accessing the data agrees on that binary point placement and the designer keeps track of that placement throughout all of the system’s arithmetic computations. Binary arithmetic hardware behavior does not depend on the “agreed upon” binary point placement. Stated in different words, binary point placement does not affect two’s complement binary arithmetic operations. That is, adding or multiplying two binary numbers will yield the same binary result regardless of the implied binary point location within the data words. We leave an example of this behavior as a homework problem.</p>
<p class="calibre3">Second, for a fixed number of bits, fractional two’s complement binary numbers allow us to represent decimal numbers with poor precision over a wide range of values, or we can represent decimal numbers with fine precision but only over a narrow range of values. In practice you must “pick your poison” by choosing the position of the binary point based on what’s more important to you, number range or number precision.</p>
<p class="calibre3">Due to their 16-bit internal data paths, it’s very common for programmable 16-bit DSP chips to use a 1.15 format (one integer bit to represent sign, and 15 fractional bits) to represent two’s complement numbers. These 16-bit signed <em class="calibre7">all-fraction</em> binary numbers are particularly useful because multiplying two such numbers results in an <em class="calibre7">all-fraction</em> product, avoiding any unpleasant binary <em class="calibre7">overflow</em> problems, to be discussed shortly. (Be aware that this 1.15 format is also called <em class="calibre7">Q15 format.</em>) Because the 1.15-format is so commonly used in programmable hardware, we give examples of it and other 16-bit formats in <a href="#calibre_link-16">Table 12-4</a>. In that table, the “resolution” is the decimal value of the format’s lsb.</p>
<p class="caption"><a id="calibre_link-16"></a><strong class="calibre9">Table 12-4</strong> 16-Bit Format Values</p>
<p class="image"><img src="images/000482.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Multiplication of two 1.15 binary words results in a 2.30-format (also called a <em class="calibre7">Q30-format</em>) fractional number. That 32-bit product word contains two <a id="calibre_link-3156"></a>sign bits and 30 fractional bits, with the msb being called an extended sign bit. We have two ways to convert (truncate) such a 32-bit product to the 1.15 format so that it can be stored as a 16-bit word. They are</p>
<p class="indenthangingb">• shifting the 32-bit word left by one bit and storing the upper 16 bits, and</p>
<p class="indenthangingb">• shifting the 32-bit word right by 15 bits and storing the lower 16 bits.</p>
<p class="calibre3"><a id="calibre_link-2096"></a>To conclude this fractional binary discussion, we provide the steps to convert a decimal number whose magnitude is less than one, such as an FIR digital filter coefficient, to the 1.15 binary format. As an example, to convert the decimal value 0.452 to the two’s complement 1.15 binary format:</p>
<p class="indenthangingn1">1. Multiply the absolute value of the original decimal number 0.452 by 32768 (2<sup class="calibre10">15</sup>), yielding a scaled decimal 14811.136.</p>
<p class="indenthangingn1">2. Round the value 14811.136 to an integer, using your preferred rounding method, producing a scaled decimal value of 14811.</p>
<p class="indenthangingn1">3. Convert the decimal 14811 to a binary integer and place the binary point to the right of the msb, yielding 0<sub class="calibre12">◊</sub>011 1001 1101 1011 (39DB<sub class="calibre12">16</sub>).</p>
<p class="indenthangingn1">4. If the original decimal value was positive, stop now. If the original decimal value was negative, implement a two’s complement conversion by inverting Step 3’s binary bits and add one.</p>
<p class="calibre3">If you, unfortunately, do not have software to perform the above positive decimal integer to 1.15 binary conversion in Step 3, here’s how the conversion can be done (painfully) by hand:</p>
<p class="indenthanging7">3.1. Divide 14811 by 2, obtaining integer 7405 plus a remainder of 0.5. Because the remainder is not zero, place a one as the lsb of the desired binary number. Our binary number is 1.</p>
<p class="indenthanging7">3.2. Divide 7405 by 2, obtaining integer 3702 plus a remainder of 0.5. Because the remainder is not zero, place a one as the bit to the left of the lsb bit established in Step 3.1 above. Our binary number is now 11.</p>
<p class="indenthanging7">3.3. Divide 3702 by 2, obtaining integer 1851 plus a remainder of zero. Because the remainder is zero, place a zero as the bit to the left of the bit established in Step 3.2 above. Our binary number is now 011.</p>
<p class="indenthanging7">3.4. Continue this process until the integer portion of the divide-by-two quotient is zero. Append zeros to the left of the binary word to extend its length to 16 bits.</p>
<p class="calibre3">Using the above steps to convert decimal 14811<sub class="calibre12">10</sub> to binary 1.15 format proceeds as shown in <a href="#calibre_link-17">Table 12-5</a>, producing our desired binary number of 0<sub class="calibre12">◊</sub>011 1001 1101 1011 (39DB<sub class="calibre12">16</sub>).</p>
<p class="caption"><a id="calibre_link-17"></a><strong class="calibre9">Table 12-5</strong> Decimal 14811 to Binary 1.15 Conversion Example</p>
<p class="image"><img src="images/001345.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-672"></a></p>
<h3 class="calibre6">12.2 Binary Number Precision and Dynamic Range</h3>
<p class="calibre3">As we implied earlier, for any binary number format, the number of bits in a data word is a key consideration. The more bits used in the word, the better the resolution of the number, and the larger the maximum value that can be <a id="calibre_link-3157"></a>represented.<sup class="calibre10"><a id="calibre_link-19"></a><a href="#calibre_link-18">†</a></sup> Assuming that a binary word represents the amplitude of a signal, digital signal processing practitioners find it useful to quantify the dynamic range of various binary number schemes. For a signed integer binary word length of <em class="calibre7">b</em>+1 bits (one sign bit and <em class="calibre7">b</em> magnitude bits), the dynamic range is defined by</p>
<p class="footnotes"><a id="calibre_link-18"></a><sup class="calibre11"><a href="#calibre_link-19">†</a></sup> Some computers use 64-bit words. Now, 2<sup class="calibre11">64</sup> is approximately equal to 1.8 · 10<sup class="calibre11">19</sup>&mdash;that’s a pretty large number. So large, in fact, that if we started incrementing a 64-bit counter once per second at the beginning of the universe (≈20 billion years ago), the most significant four bits of this counter would <em class="calibre7">still</em> be all zeros today.</p>
<p class="caption"><a id="calibre_link-68"></a>(12-6)</p>
<p class="image"><img src="images/000226.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-1948"></a>The dynamic range measured in dB is</p>
<p class="caption"><a id="calibre_link-20"></a>(12-6′)</p>
<p class="image"><img src="images/001673.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">When 2<em class="calibre7"><sup class="calibre10">b</sup></em> is much larger than 1, we can ignore the −1 in <a href="#calibre_link-20">Eq. (12-6′)</a> and state that</p>
<p class="caption"><a id="calibre_link-21"></a>(12-6″)</p>
<p class="image"><img src="images/001534.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a href="#calibre_link-21">Equation (12-6″)</a>, dimensioned in dB, tells us that the dynamic range of our number system is directly proportional to the word length. Thus, an eight-bit two’s complement word, with seven bits available to represent signal magnitude, has a dynamic range of 6.02 · 7 = 42.14 dB. Most people simplify <a href="#calibre_link-21">Eq. (12-6″)</a> by using the rule of thumb that the dynamic range is equal to “6 dB per bit.”</p>
<p class="calibre3"><a id="calibre_link-516"></a></p>
<h3 class="calibre6">12.3 Effects of Finite Fixed-Point Binary Word Length</h3>
<p class="calibre3">The effects of finite binary word lengths touch all aspects of digital signal processing. Using finite word lengths prevents us from representing values with infinite precision, increases the background noise in our spectral estimation techniques, creates nonideal digital filter responses, induces noise in analog-to-digital (A/D) converter outputs, and can (if we’re not careful) lead to wildly inaccurate arithmetic results. The smaller the word lengths, the greater these problems will be. Fortunately, these finite, word-length effects are rather well understood. We can predict their consequences and take steps to minimize any unpleasant surprises. The first finite, word-length effect we’ll cover is the errors that occur during the A/D conversion process.</p>
<p class="calibre3"><a id="calibre_link-3158"></a></p>
<h4 class="calibre13">12.3.1 A/D Converter Quantization Errors</h4>
<p class="calibre3">Practical A/D converters are constrained to have binary output words of finite length. Commercial A/D converters are categorized by their output word lengths, which are normally in the range from 8 to 16 bits. A typical A/D converter input analog voltage range is from −1 to +1 volt. If we used such an A/D converter having 8-bit output words, the least significant bit would represent</p>
<p class="caption"><a id="calibre_link-3159"></a>(12-7)</p>
<p class="image"><img src="images/001099.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">What this means is that we can represent continuous (analog) voltages perfectly as long as they’re integral multiples of 7.81 millivolts&mdash;any intermediate <a id="calibre_link-2257"></a>input voltage will cause the A/D converter to output a <em class="calibre7">best estimate</em> digital data value. The inaccuracies in this process are called <em class="calibre7">quantization errors</em> because an A/D output least significant bit is an indivisible quantity. We illustrate this situation in <a href="#calibre_link-22">Figure 12-1(a)</a>, where the continuous waveform is being digitized by an 8-bit A/D converter whose output is in the sign-magnitude format. When we start sampling at time <em class="calibre7">t</em> = 0, the continuous waveform happens to have a value of 31.25 millivolts (mv), and our A/D output data word will be exactly correct for sample <em class="calibre7">x</em>(0). At time <em class="calibre7">T</em> when we get the second A/D output word for sample <em class="calibre7">x</em>(1), the continuous voltage is between 0 and −7.81 mv. In this case, the A/D converter outputs a sample value of 10000001, representing −7.81 mv, even though the continuous input was not quite as negative as −7.81 mv. The 10000001 A/D output word contains some quantization error. Each successive sample contains quantization error because the A/D’s digitized <a id="calibre_link-2261"></a>output values must lie on the horizontal line in <a href="#calibre_link-22">Figure 12-1(a)</a>. The difference between the actual continuous input voltage and the A/D converter’s representation of the input is shown as the quantization error in <a href="#calibre_link-22">Figure 12-1(b)</a>. For an ideal A/D converter, the quantization error, a kind of <em class="calibre7">roundoff</em> noise, can never be greater than ±1/2 an lsb, or ±3.905 mv.</p>
<p class="caption"><a id="calibre_link-22"></a><strong class="calibre9">Figure 12-1</strong> Quantization errors: (a) digitized <em class="calibre7">x(n)</em> values of a continuous signal; (b) quantization error between the actual analog signal values and the digitized signal values.</p>
<p class="image"><img src="images/001375.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">While <a href="#calibre_link-22">Figure 12-1(b)</a> shows A/D quantization noise in the time domain, we can also illustrate this noise in the frequency domain. <a href="#calibre_link-23">Figure 12-2(a)</a> depicts a continuous sinewave of one cycle over the sample interval shown as the dashed line and a quantized version of the time-domain samples of that <a id="calibre_link-1950"></a>wave as the dots. Notice how the quantized version of the wave is constrained to have only integral values, giving it a <em class="calibre7">stair-step</em> effect oscillating above and below the true unquantized sinewave. The quantization here is four bits, meaning that we have a sign bit and three bits to represent the magnitude of the wave. With three bits, the maximum peak values for the wave are ±7. <a href="#calibre_link-23">Figure 12-2(b)</a> shows the discrete Fourier transform (DFT) of a discrete version of the sinewave whose time-domain sample values are not forced to be integers but have high precision. Notice in this case that the DFT has a nonzero value only at <em class="calibre7">m</em> = 1. On the other hand, <a href="#calibre_link-23">Figure 12-2(c)</a> shows the spectrum of the four-bit quantized samples in <a href="#calibre_link-23">Figure 12-2(a)</a>, where quantization effects have induced noise components across the entire spectral band. If the quantization noise depictions in <a href="#calibre_link-22">Figures 12-1(b)</a> and <a href="#calibre_link-23">12-2(c)</a> look random, that’s because they are. As it turns out, even though A/D quantization noise is random, we can still quantify its effects in a useful way.</p>
<p class="caption"><a id="calibre_link-23"></a><strong class="calibre9">Figure 12-2</strong> Quantization noise effects: (a) input sinewave applied to a 64-point DFT; (b) theoretical DFT magnitude of high-precision sinewave samples; (c) DFT magnitude of a sinewave quantized to four bits.</p>
<p class="image"><img src="images/000493.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">In the field of communications, people often use the notion of output signal-to-noise ratio, or SNR = (signal power)/(noise power), to judge the usefulness of a process or device. We can do likewise and obtain an important expression for the output SNR of an ideal A/D converter, <em class="calibre7">SNR</em><sub class="calibre12">A/D</sub>, accounting for finite word-length quantization effects. Because quantization noise is random, we can’t explicitly represent its power level, but we can use its statistical equivalent of variance to define <em class="calibre7">SNR</em><sub class="calibre12">A/D</sub> measured in dB as</p>
<p class="caption"><a id="calibre_link-30"></a>(12-8)</p>
<p class="image"><img src="images/000013.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Next, we’ll determine an A/D converter’s quantization noise variance relative to the converter’s maximum input peak voltage <em class="calibre7">V<sub class="calibre12">p</sub></em>. If the full-scale (−<em class="calibre7">V<sub class="calibre12">p</sub></em> to +<em class="calibre7">V<sub class="calibre12">p</sub></em> volts) continuous input range of a <em class="calibre7">b</em>-bit A/D converter is 2<em class="calibre7">Vp</em>, a single quantization level <em class="calibre7">q</em> is that voltage range divided by the number of possible A/D output binary values, or <em class="calibre7">q</em> = 2<em class="calibre7">V<sub class="calibre12">p</sub></em>/2<em class="calibre7"><sup class="calibre10">b</sup></em>. (In <a href="#calibre_link-22">Figure 12-1</a>, for example, the quantization level <em class="calibre7">q</em> is the lsb value of 7.81 mv.) A depiction of the likelihood of encountering any given quantization error value, called the probability density function <em class="calibre7">p(e)</em> of the quantization error, is shown in <a href="#calibre_link-24">Figure 12-3</a>.</p>
<p class="caption"><a id="calibre_link-24"></a><strong class="calibre9">Figure 12-3</strong> Probability density function of A/D conversion roundoff error (noise).</p>
<p class="image"><img src="images/001265.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">This simple rectangular function has much to tell us. It indicates that there’s an equal chance that any error value between −<em class="calibre7">q</em>/2 and +<em class="calibre7">q</em>/2 can occur. By definition, because probability density functions have an area of unity (i.e., the probability is 100 percent that the error will be somewhere under the curve), the amplitude of the <em class="calibre7">p(e)</em> density function must be the area <a id="calibre_link-3160"></a>divided by the width, or <em class="calibre7">p(e)</em> = 1/<em class="calibre7">q</em>. From <a href="#calibre_link-25">Figure D-7</a> and <a href="#calibre_link-26">Eq. (D-29)</a> in <a href="#calibre_link-27">Appendix D</a>, the variance of our uniform <em class="calibre7">p(e)</em> is</p>
<p class="caption"><a id="calibre_link-28"></a>(12-9)</p>
<p class="image"><img src="images/000857.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">We can now express the A/D noise error variance in terms of A/D parameters by replacing <em class="calibre7">q</em> in <a href="#calibre_link-28">Eq. (12-9)</a> with <em class="calibre7">q</em> = 2<em class="calibre7">V<sub class="calibre12">p</sub></em>/2<em class="calibre7"><sup class="calibre10">b</sup></em> to get</p>
<p class="caption"><a id="calibre_link-29"></a>(12-10)</p>
<p class="image"><img src="images/001176.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">OK, we’re halfway to our goal&mdash;with <a href="#calibre_link-29">Eq. (12-10)</a> giving us the denominator of <a href="#calibre_link-30">Eq. (12-8)</a>, we need the numerator. To arrive at a general result, let’s express the input signal in terms of its root mean square (rms), the A/D converter’s peak voltage, and a loading factor <em class="calibre7">LF</em> defined as</p>
<p class="caption"><a id="calibre_link-32"></a>(12-11)</p>
<p class="image"><img src="images/000736.jpg" alt="image" class="calibre2" /></p>
<p class="footnotes"><a id="calibre_link-3161"></a><sup class="calibre11">†</sup> As covered in <a href="#calibre_link-27">Appendix D</a>, <a href="#calibre_link-31">Section D.2</a>, although the variance σ<sup class="calibre11">2</sup> is associated with the power of a signal, the standard deviation is associated with the rms value of a signal.</p>
<p class="calibre3">With the loading factor defined as the input rms voltage over the A/D converter’s peak input voltage, we square and rearrange <a href="#calibre_link-32">Eq. (12-11)</a> to show the signal variance <img src="images/000298.jpg" alt="image" class="calibre2" /> as</p>
<p class="caption"><a id="calibre_link-33"></a>(12-12)</p>
<p class="image"><img src="images/001590.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3162"></a>Substituting <a href="#calibre_link-29">Eqs. (12-10)</a> and <a href="#calibre_link-33">(12-12)</a> in <a href="#calibre_link-30">Eq. (12-8)</a>,</p>
<p class="caption"><a id="calibre_link-34"></a>(12-13)</p>
<p class="image"><img src="images/001253.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a href="#calibre_link-34">Eq. (12-13)</a> gives us the S<em class="calibre7">NR</em><sub class="calibre12">A/D</sub> of an ideal <em class="calibre7">b</em>-bit A/D converter in terms of the loading factor and the number of bits <em class="calibre7">b</em>. <a href="#calibre_link-35">Figure 12-4</a> plots <a href="#calibre_link-34">Eq. (12-13)</a> for various A/D word lengths as a function of the loading factor. Notice that the loading factor in <a href="#calibre_link-35">Figure 12-4</a> is never greater than −3 dB, because the maximum continuous A/D input peak value must not be greater than <em class="calibre7">V<sub class="calibre12">p</sub></em> volts. Thus, for a sinusoid input, its rms value must not be greater than <img src="images/001272.jpg" alt="image" class="calibre2" /> volts (3 dB below <em class="calibre7">V<sub class="calibre12">p</sub></em>).</p>
<p class="caption"><a id="calibre_link-35"></a><strong class="calibre9">Figure 12-4</strong> <em class="calibre7">SNR</em><sub class="calibre12">A/D</sub> of ideal A/D converters as a function of loading factor in dB.</p>
<p class="image"><img src="images/001764.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">When the input sinewave’s peak amplitude is equal to the A/D converter’s full-scale voltage <em class="calibre7">V<sub class="calibre12">p</sub></em>, the full-scale <em class="calibre7">LF</em> is</p>
<p class="caption"><a id="calibre_link-3163"></a>(12-14)</p>
<p class="image"><img src="images/001774.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Under this condition, the maximum A/D output SNR from <a href="#calibre_link-34">Eq. (12-13)</a> is</p>
<p class="caption"><a id="calibre_link-36"></a>(12-15)</p>
<p class="image"><img src="images/001801.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-1946"></a>This discussion of SNR relative to A/D converters means three important things to us:</p>
<p class="indenthangingn1"><strong class="calibre9">1.</strong> An ideal A/D converter will have an <em class="calibre7">SNR</em><sub class="calibre12">A/D</sub> defined by <a href="#calibre_link-34">Eq. (12-13)</a>, so any discrete <em class="calibre7">x</em>(<em class="calibre7">n</em>) signal produced by a <em class="calibre7">b</em>-bit A/D converter can never have an SNR greater than <a href="#calibre_link-34">Eq. (12-13)</a>. (<a href="#calibre_link-27">Appendix D</a> dicusses methods for computing the SNR of discrete signals.) For example, let’s say we want to digitize a continuous signal whose SNR is 55 dB. Using an ideal eight-bit A/D converter with its full-scale <em class="calibre7">SNR</em><sub class="calibre12">A/D</sub> of 6.02 · 8 + 1.76 = 49.9 dB from <a href="#calibre_link-36">Eq. (12-15)</a>, the quantization noise will contaminate the digitized values, and the resultant digital signal’s SNR can be no better than 49.9 dB. We’ll have lost signal SNR through the A/D conversion process. (A ten-bit A/D, with its ideal <em class="calibre7">SNR</em><sub class="calibre12">A/D</sub> ≈ 62 dB, could be used to digitize a 55 dB SNR continuous signal to reduce the SNR degradation caused by quantization noise.) <a href="#calibre_link-34">Equations (12-13)</a> and <a href="#calibre_link-36">(12-15)</a> apply to ideal A/D converters and don’t take into account such additional A/D noise sources as aperture jitter error, missing output bit patterns, and other nonlinearities. So actual A/D converters are likely to have SNRs that are lower than that indicated by theoretical <a href="#calibre_link-34">Eq. (12-13)</a>. To be safe in practice, it’s sensible to assume that <em class="calibre7">SNR</em><sub class="calibre12">A/D-max</sub> is 3 to 6 dB lower than indicated by <a href="#calibre_link-36">Eq. (12-15)</a>.</p>
<p class="indenthangingn1"><strong class="calibre9">2.</strong> <a href="#calibre_link-36">Equation (12-15)</a> is often expressed in the literature, but it can be a little misleading because it’s imprudent to force an A/D converter’s input to full scale. It’s wise to drive an A/D converter to some level below full scale because inadvertent overdriving will lead to signal clipping and will induce distortion in the A/D’s output. So <a href="#calibre_link-36">Eq. (12-15)</a> is overly optimistic, and, in practice, A/D converter SNRs will be less than indicated by <a href="#calibre_link-36">Eq. (12-15)</a>. The best approximation for an A/D’s SNR is to determine the input signal’s rms value that will never (or rarely) overdrive the converter input, and plug that value into <a href="#calibre_link-32">Eq. (12-11)</a> to get the loading factor value for use in <a href="#calibre_link-34">Eq. (12-13)</a>.<sup class="calibre10"><a id="calibre_link-38"></a><a href="#calibre_link-37">†</a></sup> Again, using an A/D converter with a wider word length will alleviate this problem by increasing the available <em class="calibre7">SNR</em><sub class="calibre12">A/D</sub>.</p>
<p class="footnotes"><a id="calibre_link-37"></a><sup class="calibre11"><a href="#calibre_link-38">†</a></sup> By the way, some folks use the term <em class="calibre7">crest factor</em> to describe how hard an A/D converter’s input is being driven. The crest factor is the reciprocal of the loading factor, or <em class="calibre7">CF</em> = <em class="calibre7">V<sub class="calibre14">p</sub></em>/(rms of the input signal).</p>
<p class="indenthangingn1"><strong class="calibre9">3.</strong> Remember, now, real-world continuous signals always have their own inherent continuous SNR, so using an A/D converter whose <em class="calibre7">SNR</em><sub class="calibre12">A/D</sub> is a great deal larger than the continuous signal’s SNR serves no purpose. In this case, we would be wasting A/D converter bits by digitizing the analog signal’s noise to a high degree of accuracy, which does not improve <a id="calibre_link-1947"></a>our digital signal’s overall SNR. In general, we want the converter’s <em class="calibre7">SNR</em><sub class="calibre12">A/D</sub> value to be approximately 6 dB greater than an analog signal’s SNR.</p>
<p class="calibre3">A word of caution is appropriate here concerning our analysis of A/D converter quantization errors. The derivations of <a href="#calibre_link-34">Eqs. (12-13)</a> and <a href="#calibre_link-36">(12-15)</a> are based upon three assumptions:</p>
<p class="indenthangingn1"><strong class="calibre9">1.</strong> The cause of A/D quantization errors is a stationary random process; that is, the performance of the A/D converter does not change over time. Given the same continuous input voltage, we always expect an A/D converter to provide exactly the same output binary code.</p>
<p class="indenthangingn1"><strong class="calibre9">2.</strong> The probability density function of the A/D quantization error is uniform. We’re assuming that the A/D converter is ideal in its operation and all possible errors between −<em class="calibre7">q</em>/2 and +<em class="calibre7">q</em>/2 are equally likely. An A/D converter having stuck bits or missing output codes would violate this assumption. High-quality A/D converters being driven by continuous signals that cross many quantization levels will result in our desired uniform quantization noise probability density function.</p>
<p class="indenthangingn1"><strong class="calibre9">3.</strong> The A/D quantization errors are uncorrelated with the continuous input signal. If we were to digitize a single continuous sinewave whose frequency was harmonically related to the A/D sample rate, we’d end up sampling the same input voltage repeatedly and the quantization error sequence would not be random. The quantization error would be predictable and repetitive, and our quantization noise variance derivation would be invalid. In practice, complicated continuous signals such as music or speech, with their rich spectral content, avoid this problem.</p>
<p class="calibre3">To conclude our discussion of A/D converters, let’s consider one last topic. In the literature the reader is likely to encounter the expression</p>
<p class="caption"><a id="calibre_link-39"></a>(12-16)</p>
<p class="image"><img src="images/001247.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a href="#calibre_link-39">Equation (12-16)</a> is used by test equipment manufacturers to specify the sensitivity of test instruments using a <em class="calibre7">b</em><sub class="calibre12">eff</sub> parameter known as the number of <em class="calibre7">effective bits</em>, or effective number of bits (ENOB)[<a href="#calibre_link-40">3</a>&ndash;<a href="#calibre_link-41">8</a>]. <a href="#calibre_link-39">Equation (12-16)</a> is merely <a href="#calibre_link-36">Eq. (12-15)</a> solved for <em class="calibre7">b</em> and is based on the assumption that the A/D converter’s analog input peak-peak voltage spans roughly 90 percent of the converter’s full-scale voltage range. Test equipment manufacturers measure the actual SNR of their product, indicating its ability to capture continuous input signals relative to the instrument’s inherent noise characteristics. Given this true SNR, they use <a href="#calibre_link-39">Eq. (12-16)</a> to determine the <em class="calibre7">b</em><sub class="calibre12">eff</sub> value for advertisement in their product literature. The larger the <em class="calibre7">b</em><sub class="calibre12">eff</sub>, the greater the continuous voltage <a id="calibre_link-2259"></a>that can be accurately digitized relative to the equipment’s intrinsic quantization noise.</p>
<p class="calibre3"><a id="calibre_link-81"></a></p>
<h4 class="calibre13">12.3.2 Data Overflow</h4>
<p class="calibre3">The next finite, word-length effect we’ll consider is called <em class="calibre7">overflow</em>. Overflow is what happens when the result of an arithmetic operation has too many bits, or digits, to be represented in the hardware registers designed to contain that result. We can demonstrate this situation to ourselves rather easily using a simple four-function, eight-digit pocket calculator. The sum of a decimal 9.9999999 plus 1.0 is 10.9999999, but on an eight-digit calculator the sum is 10.999999 as</p>
<p class="image"><img src="images/000096.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The hardware registers, which contain the arithmetic result and drive the calculator’s display, can hold only eight decimal digits; so the least significant digit is discarded (of course). Although the above error is less than one part in ten million, overflow effects can be striking when we work with large numbers. If we use our calculator to add 99,999,999 plus 1, instead of getting the correct result of 100 million, we’ll get a result of 1. Now that’s an authentic overflow error!</p>
<p class="calibre3">Let’s illustrate overflow effects with examples more closely related to our discussion of binary number formats. First, adding two unsigned binary numbers is as straightforward as adding two decimal numbers. The sum of 42 plus 39 is 81, or</p>
<p class="image"><img src="images/000706.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">In this case, two 6-bit binary numbers required 7 bits to represent the results. The general rule is <em class="calibre7">the sum of</em> m <em class="calibre7">individual</em> b<em class="calibre7">-bit binary numbers can require as many as</em> [b <em class="calibre7">+ log<sub class="calibre12">2</sub>(</em>m<em class="calibre7">)</em>] <em class="calibre7">bits to represent the results</em>. So, for example, a 24-bit result register (accumulator) is needed to accumulate the sum of sixteen 20-bit binary numbers, or 20 + log<sub class="calibre12">2</sub>(16) = 24. The sum of 256 eight-bit words requires an accumulator whose word length is [8 + log<sub class="calibre12">2</sub>(256)], or 16 bits, to ensure that no overflow errors occur.</p>
<p class="calibre3"><a id="calibre_link-3164"></a>In the preceding example, if our accumulator word length was six bits, an overflow error occurs as</p>
<p class="image"><img src="images/000679.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Here, the most significant bit of the result overflowed the six-bit accumulator, and an error occurred.</p>
<p class="calibre3">With regard to overflow errors, the two’s complement binary format has two interesting characteristics. First, under certain conditions, overflow during the summation of two numbers causes no error. Second, with multiple summations, intermediate overflow errors cause no problems if the final magnitude of the sum of the <em class="calibre7">b</em>-bit two’s complement numbers is less than 2<sup class="calibre10"><em class="calibre7">b</em>−1</sup>. Let’s illustrate these properties by considering the four-bit two’s complement format in <a href="#calibre_link-42">Figure 12-5</a>, whose binary values are taken from <a href="#calibre_link-12">Table 12-2</a>.</p>
<p class="caption"><a id="calibre_link-42"></a><strong class="calibre9">Figure 12-5</strong> Four-bit two’s complement binary numbers.</p>
<p class="image"><img src="images/001142.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The first property of two’s complement overflow, which sometimes causes no errors, can be shown by the following examples:</p>
<p class="image"><a id="calibre_link-3165"></a><img src="images/001784.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Then again, the following examples show how two’s complement overflow sometimes does cause errors:</p>
<p class="image"><img src="images/000782.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The rule with two’s complement addition is <em class="calibre7">if the carry bit into the sign bit is the same as the overflow bit out of the sign bit, the overflow bit can be ignored, causing no errors; if the carry bit into the sign bit is different from the overflow bit out of the sign bit, the result is invalid</em>. An even more interesting property of two’s complement numbers is that a series of <em class="calibre7">b</em>-bit word summations can be performed where intermediate sums are invalid, but the final sum will be correct if its magnitude is less than 2<sup class="calibre10"><em class="calibre7">b</em>−1</sup>. We show this by the following example. If we add a +6 to a +7, and then add a −7, we’ll encounter an intermediate overflow error but our final sum will be correct, as</p>
<p class="image"><img src="images/001195.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3166"></a>The magnitude of the sum of the three four-bit numbers was less than 2<sup class="calibre10">4−1</sup> (&lt;8), so our result was valid. If we add a +6 to a +7, and next add a −5, we’ll encounter an intermediate overflow error, and our final sum will also be in error because its magnitude is not less than 8.</p>
<p class="image"><img src="images/000688.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Another situation where overflow problems are conspicuous is during the calculation of the fast Fourier transform (FFT). It’s difficult at first to imagine that multiplying complex numbers by sines and cosines can lead to excessive data word growth&mdash;particularly because sines and cosines are never greater than unity. Well, we can show how FFT data word growth occurs by considering a decimation-in-time FFT butterfly from <a href="#calibre_link-43">Figure 4-14(c)</a>, repeated here as <a href="#calibre_link-44">Figure 12-6(a)</a>, and grinding through a little algebra. The expression for the <em class="calibre7">x</em>’ output of this FFT butterfly, from <a href="#calibre_link-45">Eq. (4-26)</a>, is</p>
<p class="caption"><a id="calibre_link-46"></a>(12-17)</p>
<p class="image"><img src="images/000353.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-44"></a><strong class="calibre9">Figure 12-6</strong> Data overflow scenarios: (a) single decimation-in-time FFT butterfly; (b) 2nd-order IIR filter.</p>
<p class="image"><img src="images/001191.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Breaking up the butterfly’s <em class="calibre7">x</em> and <em class="calibre7">y</em> inputs into their real and imaginary parts and remembering that <img src="images/000856.jpg" alt="image" class="calibre2" />, we can express <a href="#calibre_link-46">Eq. (12-17)</a> as</p>
<p class="caption"><a id="calibre_link-47"></a>(12-18)</p>
<p class="image"><img src="images/000162.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">If we let α be the twiddle factor angle of 2π<em class="calibre7">k/N</em>, and recall that <em class="calibre7">e</em><sup class="calibre10">−<em class="calibre7">j</em>α</sup> = cos(α) − <em class="calibre7">j</em>sin(α), we can simplify <a href="#calibre_link-47">Eq. (12-18)</a> as</p>
<p class="caption"><a id="calibre_link-3167"></a>(12-19)</p>
<p class="image"><img src="images/001003.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2263"></a>If we look, for example, at just the real part of the <em class="calibre7">x</em>’ output, <em class="calibre7">x</em>’<sub class="calibre12">real</sub>, it comprises the three terms</p>
<p class="caption"><a id="calibre_link-3168"></a>(12-20)</p>
<p class="image"><img src="images/000049.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">If <em class="calibre7">x</em><sub class="calibre12">real</sub>, <em class="calibre7">y</em><sub class="calibre12">real</sub>, and <em class="calibre7">y</em><sub class="calibre12">imag</sub> are of unity value when they enter the butterfly and the twiddle factor angle α = 2π<em class="calibre7">k/N</em> happens to be π/4 = 45°, then, <em class="calibre7">x</em>’<sub class="calibre12">real</sub> can be greater than 2 as</p>
<p class="caption"><a id="calibre_link-3169"></a>(12-21)</p>
<p class="image"><img src="images/000899.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">So we see that the real part of a complex number can more than double in magnitude in a single stage of an FFT. The imaginary part of a complex number is equally likely to more than double in magnitude in a single FFT stage. Without mitigating this word growth problem, overflow errors could render an FFT algorithm useless.</p>
<p class="calibre3">Overflow problems can also be troublesome for fixed-point systems containing feedback as shown in <a href="#calibre_link-44">Figure 12-6(b)</a>. Examples of such networks are infinite impulse response (IIR) filters, cascaded integrator-comb (CIC) filters, and exponential averagers. The hardware register (accumulator) containing <em class="calibre7">w</em>(<em class="calibre7">n</em>) must have a binary word width that will hold data values as large as the network’s DC (zero Hz) gain <em class="calibre7">G</em> times the input signal, or <em class="calibre7">G</em> · <em class="calibre7">x</em>(<em class="calibre7">n</em>). To avoid data overflow, the number of bits in the <em class="calibre7">w</em>(<em class="calibre7">n</em>)-results register must be at least</p>
<p class="caption"><a id="calibre_link-3170"></a>(12-22)</p>
<p class="image"><img src="images/001384.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where <img src="images/000574.jpg" alt="image" class="calibre2" /> means that if log<sub class="calibre12">2</sub>(<em class="calibre7">G</em>) is not an integer, round it up to the next larger integer. (As a quick reminder, we can determine the DC gain of a digital network by substituting <em class="calibre7">z</em> = 1 in the network’s <em class="calibre7">z</em>-domain transfer function.)</p>
<p class="calibre3">OK, overflow problems are handled in one of two ways&mdash;by truncation or rounding&mdash;each inducing its own individual kind of quantization errors, as we shall see.</p>
<p class="calibre3"><a id="calibre_link-3171"></a></p>
<h4 class="calibre13">12.3.3 Truncation</h4>
<p class="calibre3">Truncation is the process where some number of least significant bits are discarded from a binary number. A practical example of truncation is the situation where the results of a processing system are 16-bit signal samples that must be passed on to a 12-bit digital-to-analog converter. To avoid overflowing the converter’s 12-bit input register, the least significant 4 bits of the 16-bit signal samples must be discarded. Thinking about decimal numbers, if we’re quantizing to decimal integer values, for example, the real value 1.2 would be quantized to 1.</p>
<p class="calibre3"><a id="calibre_link-3172"></a>An example of truncation to integer values is shown in <a href="#calibre_link-48">Figure 12-7(a)</a>, where all values of <em class="calibre7">x</em> in the range of 0 ≤ <em class="calibre7">x</em> &lt; 1 are set equal to 0, values of <em class="calibre7">x</em> in the range of 1 ≤ <em class="calibre7">x</em> &lt; 2 are set equal to 1, and so on. The quantization level (value), in that figure, is <em class="calibre7">q</em> = 1. The quantization error induced by this truncation is the vertical distance between the horizontal bold lines and the dashed diagonal line in <a href="#calibre_link-48">Figure 12-7(a)</a>.</p>
<p class="caption"><a id="calibre_link-48"></a><strong class="calibre9">Figure 12-7</strong> Truncation: (a) quantization nonlinearities; (b) error probability density function; (c) binary truncation.</p>
<p class="image"><img src="images/000020.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">As we did with A/D converter quantization errors, we can call upon the concept of probability density functions to characterize the quantization errors induced by truncation. The probability density function of truncation errors, in terms of the quantization level <em class="calibre7">q</em>, is shown in <a href="#calibre_link-48">Figure 12-7(b)</a>. In <a id="calibre_link-3173"></a><a href="#calibre_link-48">Figure 12-7(a)</a> the quantization level <em class="calibre7">q</em> is 1, so in this case we can have truncation errors as great as −1. Drawing upon our results from <a href="#calibre_link-49">Eqs. (D-11)</a> and <a href="#calibre_link-50">(D-12)</a> in <a href="#calibre_link-27">Appendix D</a>, the mean and variance of our uniform truncation error probability density function are expressed as</p>
<p class="caption"><a id="calibre_link-52"></a>(12-23)</p>
<p class="image"><img src="images/000201.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">and</p>
<p class="caption"><a id="calibre_link-3174"></a>(12-24)</p>
<p class="image"><img src="images/000827.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The notion of binary number truncation is shown in <a href="#calibre_link-48">Figure 12-7(c)</a>, where the ten-bit binary word <em class="calibre7">W</em> is to be truncated to six bits by discarding the four Truncate bits. So in this binary truncation situation, <em class="calibre7">q</em> in <a href="#calibre_link-48">Figure 12-7(b)</a> is equal to the least significant bit (lsb) value (bit R0) of the retained binary word.</p>
<p class="calibre3">In a sense, truncation error is the price we pay for the privilege of using integer binary arithmetic. One aspect of this is the error introduced when we use truncation to implement division by some integer power of two. A quick way of dividing a binary value by 2<em class="calibre7"><sup class="calibre10">K</sup></em> is to shift a binary word <em class="calibre7">K</em> bits to the right; that is, we’re truncating the data value (not the binary word width) by discarding the rightmost <em class="calibre7">K</em> bits after the right shift.</p>
<p class="calibre3">For example, let’s say we have the value 31 represented by the six-bit binary number 011111<sub class="calibre12">2</sub>, and we want to divide it by 16 through shifting the bits <em class="calibre7">K</em> = 4 places to the right and discarding those shifted bits. After the right shift we have a binary quotient of 000001<sub class="calibre12">2</sub>. Well, we see the significance of the problem because this type of division gave us a result of one instead of the correct quotient 31/16 = 1.9375. Our division-by-truncation error here is roughly 50 percent of the correct quotient. Had our original dividend been 63 represented by the six-bit binary number 111111<sub class="calibre12">2</sub>, dividing it by 16 through a four-bit shift would give us an answer of binary 000011<sub class="calibre12">2</sub>, or decimal three. The correct answer, of course, is 63/16 = 3.9375. In this case the percentage error is 0.9375/3.9375, or about 23.8 percent. So, the larger the dividend, the lower the truncation error.</p>
<p class="calibre3">If we study these kinds of errors, we’ll find that truncation error depends on three things: the number of value bits shifted and discarded, the values of the discarded bits (were those dropped bits ones or zeros?), and the magnitude of the binary number left over after shifting. Although a complete analysis of these truncation errors is beyond the scope of this book, a practical example of how division by truncation can cause serious numerical errors is given in reference <a href="#calibre_link-51">[9]</a>.</p>
<p class="calibre3">Unfortunately, truncation induces a DC bias (an error whose average is a nonzero negative number) on the truncated signal samples, as predicted by <a id="calibre_link-2260"></a><a href="#calibre_link-52">Eq. (12-23)</a>. We see this behavior in <a href="#calibre_link-48">Figure 12-7(b)</a> where the truncation error is always negative. Inducing a constant (DC) error to a signal sequence can be troublesome in many applications because the always-negative truncation error can grow to an unacceptable level in subsequent computations. So, in an effort to avoid overflow errors, rounding (discussed in the next section) is often preferred over truncation.</p>
<p class="calibre3"><a id="calibre_link-3175"></a></p>
<h4 class="calibre13">12.3.4 Data Rounding</h4>
<p class="calibre3">Rounding is where a binary number requiring truncation is slightly modified before the truncation operation is performed. Let’s review the behavior of rounding by first defining rounding as the process wherein a number is modified such that it is subsequently represented by, or <em class="calibre7">rounded off to</em>, its nearest quantization level. For example, if we’re quantizing to integer values, the decimal number 1.2 would be quantized to 1, and the number 1.6 would be quantized to 2. This is shown in <a href="#calibre_link-53">Figure 12-8(a)</a>, where all values of <em class="calibre7">x</em> in the range of −0.5 ≤ <em class="calibre7">x</em> &lt; 0.5 are set equal to 0, values of <em class="calibre7">x</em> in the range of 0.5 ≤ <em class="calibre7">x</em> &lt; 1.5 are set equal to 1, and so on.</p>
<p class="caption"><a id="calibre_link-53"></a><strong class="calibre9">Figure 12-8</strong> Rounding: (a) quantization nonlinearities; (b) error probability density function.</p>
<p class="image"><img src="images/000624.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2262"></a>The quantization error induced by such a rounding operation is the vertical distance between the bold horizontal lines and the dashed diagonal line in <a href="#calibre_link-53">Figure 12-8(a)</a>. The probability density function of the error induced by rounding, in terms of the quantization level <em class="calibre7">q</em>, is shown in <a href="#calibre_link-53">Figure 12-8(b)</a>. In <a href="#calibre_link-53">Figure 12-8(a)</a> the quantization level is <em class="calibre7">q</em> = 1, so in this case we can have quantization error magnitudes no greater than <em class="calibre7">q</em>/2, or 1/2. Using our <a href="#calibre_link-49">Eqs. (D-11)</a> and <a href="#calibre_link-50">(D-12)</a> results from <a href="#calibre_link-27">Appendix D</a>, the mean and variance of our uniform rounding probability density function are expressed as</p>
<p class="caption"><a id="calibre_link-54"></a>(12-25)</p>
<p class="image"><img src="images/001452.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">and</p>
<p class="caption"><a id="calibre_link-3176"></a>(12-26)</p>
<p class="image"><img src="images/000273.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The notion of binary number rounding can be described using <a href="#calibre_link-48">Figure 12-7(c)</a>, where the binary word <em class="calibre7">W</em> is to be truncated by discarding the four Truncate bits. With rounding, the binary word <em class="calibre7">W</em> is modified before the Truncate bits are discarded. So with binary rounding, <em class="calibre7">q</em> in <a href="#calibre_link-53">Figure 12-8(b)</a> is equal to the lsb value of the preserved binary word R0.</p>
<p class="calibre3">Let’s not forget: the purpose of rounding, its goal in life, is to avoid data overflow errors while reducing the DC bias error (an error whose average is not zero) induced by simple truncation. Rounding achieves this goal because, in theory, its average error is zero as shown by <a href="#calibre_link-54">Eq. (12-25)</a>. Next we discuss two popular methods of data rounding.</p>
<p class="calibre3">A common form of binary data rounding is straightforward to implement. Called <em class="calibre7">round-to-nearest,</em> it comprises the two-step process of adding one to the most significant (leftmost) of the lsb bits to be discarded, bit T3 of word <em class="calibre7">W</em> in <a href="#calibre_link-48">Figure 12-7(c)</a>, and then discarding the appropriate Truncate bits. For an example of this rounding method, let’s say we have 16-bit signal samples destined to be routed to a 12-bit digital-to-analog converter. To avoid overflowing the converter’s 12-bit input register, we add a binary value of 1000<sub class="calibre12">2</sub> (decimal 8<sub class="calibre12">10</sub> = 2<sup class="calibre10">3</sup>) to the original 16-bit sample value and then truncate (discard) the sum’s least significant 4 bits. As another example of round-to-nearest rounding, if a 32-bit “long” word is rounded to 16 bits, a value of 2<sup class="calibre10">15</sup> is added to the long word before discarding the sum’s 16 least significant bits.</p>
<p class="calibre3">Stated in different words, this round-to-nearest rounding method means: If the T3 bit is a one, increment the R bits by one. Then shift the R bits to the right, discarding the Truncate bits.</p>
<p class="calibre3">The round-to-nearest method does reduce the average (DC bias) of the quantization error induced by simple truncation; however the round-to-nearest method’s average error bias is close to but not exactly equal to zero. <a id="calibre_link-2258"></a>(That’s because the R bits, in <a href="#calibre_link-48">Figure 12-7(c)</a>, are always incremented when the value of the Truncate bits is equal to the value R0/2. This means that over time the R bits are rounded up slightly more often than they are rounded down.) With additional bit checking we can force the average rounding error to be exactly zero using a scheme called <em class="calibre7">convergent rounding.</em></p>
<p class="calibre3">Convergent rounding, also called <em class="calibre7">round to even,</em> is a slightly more complicated method of rounding, but one that yields zero-average rounding error on the rounded binary signal samples. Similar to the round-to-nearest method, convergent rounding does not always increment <a href="#calibre_link-48">Figure 12-7(c)</a>’s R bits (the value Retain) when the value of the Truncate bits is equal to R0/2. In the convergent rounding scheme, when Truncate = R0/2, the value Retain is only incremented if its original value was an odd number. This clever process is shown in <a href="#calibre_link-55">Figure 12-9</a>.</p>
<p class="caption"><a id="calibre_link-55"></a><strong class="calibre9">Figure 12-9</strong> Convergent rounding.</p>
<p class="image"><img src="images/000928.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">OK, here’s what we’ve learned about rounding: Relative to simple truncation, rounding requires more computations, but rounding both minimizes the constant-level (DC bias) quantization error induced by truncation alone, and rounding has a lower maximum quantization error. So rounding is often the preferred method used to avoid binary data overflow errors. The above two rounding methods can, by the way, be used in two’s complement number format systems.</p>
<p class="calibre3">As a practical rule, to retain maximum numerical precision, all necessary full-width binary arithmetic should be performed first and then rounding (or truncation) should be performed as the very last operation. For example, if we must add twenty 16-bit binary numbers followed by rounding the sum to 12 bits, we should perform the additions at full 16-bit precision and, as a final step, round the summation result to 12 bits.</p>
<p class="calibre3"><a id="calibre_link-2180"></a>In digital signal processing, statistical analysis of quantization error effects is complicated because quantization is a nonlinear process. Analytical results depend on the types of quantization errors, the magnitude of the data being represented, the numerical format used, and which of the many FFT or digital filter structures we are implementing. Be that as it may, digital signal processing experts have developed simplified error models whose analysis has proved useful. Although discussion of these analysis techniques and their results is beyond the scope of this introductory text, many references are available for the energetic reader[<a href="#calibre_link-56">10</a>&ndash;<a href="#calibre_link-57">18</a>]. (Reference <a href="#calibre_link-58">[11]</a> has an extensive reference list of its own on the topic of quantization error analysis.)</p>
<p class="calibre3">Again, the overflow problems using fixed-point binary formats&mdash;which we try to alleviate with truncation or rounding&mdash;arise because so many digital signal processing algorithms comprise large numbers of additions or multiplications. This obstacle, particularly in hardware implementations of digital filters and the FFT, is avoided by hardware designers through the use of floating-point binary number formats.</p>
<p class="calibre3"><a id="calibre_link-673"></a></p>
<h3 class="calibre6">12.4 Floating-Point Binary Formats</h3>
<p class="calibre3">Floating-point binary formats allow us to overcome most of the limitations of precision and dynamic range mandated by fixed-point binary formats, particularly in reducing the ill effects of overflow<a href="#calibre_link-59">[19]</a>. Floating-point formats segment a data word into two parts: a mantissa <em class="calibre7">m</em> and an exponent <em class="calibre7">e</em>. Using these parts, the value of a binary floating-point number <em class="calibre7">n</em> is evaluated as</p>
<p class="caption"><a id="calibre_link-61"></a>(12-27)</p>
<p class="image"><img src="images/000551.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">that is, the number’s value is the product of the mantissa and 2 raised to the power of the exponent. (<em class="calibre7">Mantissa</em> is a somewhat unfortunate choice of terms because it has a meaning here very different from that in the mathematics of logarithms. Mantissa originally meant the decimal fraction of a logarithm.<sup class="calibre10"><a id="calibre_link-62"></a><a href="#calibre_link-60">†</a></sup> However, due to its abundance in the literature we’ll continue using the term <em class="calibre7">mantissa</em> here.) Of course, both the mantissa and the exponent in <a href="#calibre_link-61">Eq. (12-27)</a> can be either positive or negative numbers.</p>
<p class="footnotes"><a id="calibre_link-60"></a><sup class="calibre11"><a href="#calibre_link-62">†</a></sup> For example, the common logarithm (log to the base 10) of 256 is 2.4082. The 2 to the left of the decimal point is called the characteristic of the logarithm and the 4082 digits are called the mantissa. The 2 in 2.4082 does not mean that we multiply .4082 by 10<sup class="calibre11">2</sup>. The 2 means that we take the antilog of .4082 to get 2.56 and multiply that by 10<sup class="calibre11">2</sup> to get 256.</p>
<p class="calibre3">Let’s assume that a <em class="calibre7">b</em>-bit floating-point number will use <em class="calibre7">b<sub class="calibre12">e</sub></em> bits for the fixed-point signed exponent and <em class="calibre7">b<sub class="calibre12">m</sub></em> bits for the fixed-point signed mantissa. <a id="calibre_link-2024"></a>The greater the number of <em class="calibre7">b<sub class="calibre12">e</sub></em> bits used, the larger the dynamic range of the number. The more bits used for b<em class="calibre7"><sub class="calibre12">m</sub></em>, the better the resolution, or precision, of the number. Early computer simulations conducted by the developers of <em class="calibre7">b</em>-bit floating-point formats indicated that the best trade-off occurred with <em class="calibre7">b<sub class="calibre12">e</sub></em> ≈ <em class="calibre7">b</em>/4 and <em class="calibre7">b<sub class="calibre12">m</sub></em> ≈ 3<em class="calibre7">b</em>/4. We’ll see that for typical 32-bit floating-point formats used today, <em class="calibre7">b<sub class="calibre12">e</sub></em> ≈ 8 bits and <em class="calibre7">b<sub class="calibre12">m</sub></em> ≈ 24 bits.</p>
<p class="calibre3">To take advantage of a mantissa’s full dynamic range, most implementations of floating-point numbers treat the mantissa as a fractional fixed-point binary number, shift the mantissa bits to the right or left, so that the most significant bit is a one, and adjust the exponent accordingly. The process of shifting a binary bit pattern so that the most significant bit is a one is called <em class="calibre7">bit normalization.</em> When normalized, the mantissa bits are typically called the <em class="calibre7">fraction</em> of the floating-point number, instead of the mantissa. For example, the decimal value 3.6875<sub class="calibre12">10</sub> can be represented by the fractional binary number 11.1011<sub class="calibre12">2</sub>. If we use a two-bit exponent with a six-bit fraction floating-point word, we can just as well represent 11.1011<sub class="calibre12">2</sub> by shifting it to the right two places and setting the exponent to two as</p>
<p class="caption"><a id="calibre_link-63"></a>(12-28)</p>
<p class="image"><img src="images/001410.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The floating-point word above can be evaluated to retrieve our decimal number again as</p>
<p class="caption"><a id="calibre_link-3177"></a>(12-29)</p>
<p class="image"><img src="images/000389.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">After some experience using floating-point normalization, users soon realized that always having a one in the most significant bit of the fraction was wasteful. That redundant one was taking up a single bit position in all data words and serving no purpose. So practical implementations of floating-point formats discard that one, assume its existence, and increase the useful number of fraction bits by one. This is why the term <em class="calibre7">hidden bit</em> is used to describe some floating-point formats. While increasing the fraction’s precision, this scheme uses less memory because the hidden bit is merely accounted for in the <a id="calibre_link-2105"></a>hardware arithmetic logic. Using a hidden bit, the fraction in <a href="#calibre_link-63">Eq. (12-28)</a>’s floating-point number is shifted to the left one place and would now be</p>
<p class="caption"><a id="calibre_link-3178"></a>(12-30)</p>
<p class="image"><img src="images/000964.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Recall that the exponent and mantissa bits were fixed-point signed binary numbers, and we’ve discussed several formats for representing signed binary numbers, i.e., sign magnitude, two’s complement, and offset binary. As it turns out, all three signed binary formats are used in industry-standard floating-point formats. The most common floating-point formats, all using 32-bit words, are listed in <a href="#calibre_link-64">Table 12-6</a>.</p>
<p class="caption"><a id="calibre_link-64"></a><strong class="calibre9">Table 12-6</strong> Floating&ndash;Point Number Formats</p>
<p class="image"><img src="images/000379.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2264"></a>The IEEE P754 floating-point format is the most popular because so many manufacturers of floating-point integrated circuits comply with this standard[<a href="#calibre_link-41">8</a>,<a href="#calibre_link-65">20</a>&ndash;<a href="#calibre_link-66">22</a>]. Its exponent <em class="calibre7">e</em> is offset binary (biased exponent), and its fraction is a sign-magnitude binary number with a hidden bit that’s assumed to be 2<sup class="calibre10">0</sup>. The decimal value of a normalized IEEE P754 floating-point number is evaluated as</p>
<p class="caption"><a id="calibre_link-3179"></a>(12-31)</p>
<p class="image"><img src="images/000041.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where <em class="calibre7">f</em> is the decimal-formatted value of the fractional bits divided by 2<sup class="calibre10">23</sup>. Value <em class="calibre7">e</em> is the decimal value of the floating-point number’s exponent bits.</p>
<p class="calibre3">The IBM floating-point format differs somewhat from the other floating-point formats because it uses a base of 16 rather than 2. Its exponent is offset binary, and its fraction is sign magnitude with no hidden bit. The decimal value of a normalized IBM floating-point number is evaluated as</p>
<p class="caption"><a id="calibre_link-3180"></a>(12-32)</p>
<p class="image"><img src="images/000414.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The DEC floating-point format uses an offset binary exponent, and its fraction is sign magnitude with a hidden bit that’s assumed to be 2<sup class="calibre10">−1</sup>. The decimal value of a normalized DEC floating-point number is evaluated as</p>
<p class="caption"><a id="calibre_link-3181"></a>(12-33)</p>
<p class="image"><img src="images/000224.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">MIL-STD 1750A is a United States Military Airborne floating-point standard. Its exponent <em class="calibre7">e</em> is a two’s complement binary number residing in the least significant eight bits. MIL-STD 1750A’s fraction is also a two’s complement number (with no hidden bit), and that’s why no sign bit is specifically indicated in <a href="#calibre_link-64">Table 12-6</a>. The decimal value of a MIL-STD 1750A floating-point number is evaluated as</p>
<p class="caption"><a id="calibre_link-3182"></a>(12-34)</p>
<p class="image"><img src="images/001671.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Notice how the floating-point formats in <a href="#calibre_link-64">Table 12-6</a> all have word lengths of 32 bits. This was not accidental. Using 32-bit words makes these formats easier to handle using 8-, 16-, and 32-bit hardware processors. That fact not withstanding and given the advantages afforded by floating-point number formats, these formats do require a significant amount of logical comparisons and branching to correctly perform arithmetic operations. Reference <a href="#calibre_link-67">[23]</a> provides useful flow charts showing what procedural steps must be taken when floating-point numbers are added and multiplied.</p>
<p class="calibre3"><a id="calibre_link-3183"></a></p>
<h4 class="calibre13"><a id="calibre_link-2035"></a>12.4.1 Floating-Point Dynamic Range</h4>
<p class="calibre3">Attempting to determine the dynamic range of an arbitrary floating-point number format is a challenging exercise. We start by repeating the expression for a number system’s dynamic range from <a href="#calibre_link-68">Eq. (12-6)</a> as</p>
<p class="caption"><a id="calibre_link-72"></a>(12-35)</p>
<p class="image"><img src="images/000121.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">When we attempt to determine the largest and smallest possible values for a floating-point number format, we quickly see that they depend on such factors as</p>
<p class="indenthangingb">• the position of the binary point</p>
<p class="indenthangingb">• whether a hidden bit is used or not (If used, its position relative to the binary point is important.)</p>
<p class="indenthangingb">• the base value of the floating-point number format</p>
<p class="indenthangingb">• the signed binary format used for the exponent and the fraction (For example, recall from <a href="#calibre_link-12">Table 12-2</a> that the binary two’s complement format can represent larger negative numbers than the sign-magnitude format.)</p>
<p class="indenthangingb">• how unnormalized fractions are handled, if at all (<em class="calibre7">Unnormalized,</em> also called <em class="calibre7">gradual underflow,</em> means a nonzero number that’s less than the minimum normalized format but can still be represented when the exponent and hidden bit are both zero.)</p>
<p class="indenthangingb">• how exponents are handled when they’re either all ones or all zeros. (For example, the IEEE P754 format treats a number having an all-ones exponent and a nonzero fraction as an invalid number, whereas the DEC format handles a number having a sign = 1 and a zero exponent as a special instruction instead of a valid number.)</p>
<p class="calibre3">Trying to develop a dynamic range expression that accounts for all the possible combinations of the above factors is impractical. What we can do is derive a rule-of-thumb expression for dynamic range that’s often used in practice[<a href="#calibre_link-41">8</a>,<a href="#calibre_link-66">22</a>,<a href="#calibre_link-69">24</a>].</p>
<p class="calibre3">Let’s assume the following for our derivation: the exponent is a <em class="calibre7">b<sub class="calibre12">e</sub></em>-bit offset binary number, the fraction is a normalized sign-magnitude number having a sign bit and <em class="calibre7">b<sub class="calibre12">m</sub></em> magnitude bits, and a hidden bit is used just left of the binary point. Our hypothetical floating-point word takes the following form:</p>
<p class="image"><img src="images/000300.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3184"></a>First we’ll determine what the largest value can be for our floating-point word. The largest fraction is a one in the hidden bit, and the remaining <em class="calibre7">b<sub class="calibre12">m</sub></em> fraction bits are all ones. This would make fraction <em class="calibre7">f</em> = [1 + (1 − 2<sup class="calibre10">−<em class="calibre7">bm</em></sup>)]. The first 1 in this expression is the hidden bit to the left of the binary point, and the value in parentheses is all <em class="calibre7">b<sub class="calibre12">m</sub></em> bits equal to ones to the right of the binary point. The greatest positive value we can have for the <em class="calibre7">b<sub class="calibre12">e</sub></em>-bit offset binary exponent is 2<sup class="calibre10">(2<sup class="calibre18"><em class="calibre7">b<sub class="calibre19">e</sub></em>−1</sup>−1)</sup>. So the largest value that can be represented with the floating-point number is the largest fraction raised to the largest positive exponent, or</p>
<p class="caption"><a id="calibre_link-70"></a>(12-36)</p>
<p class="image"><img src="images/000960.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The smallest value we can represent with our floating-point word is a one in the hidden bit times two raised to the exponent’s most negative value, 2<sup class="calibre10">−(2<em class="calibre7">b</em><sub class="calibre15">e</sub>−1)</sup>, or</p>
<p class="caption"><a id="calibre_link-71"></a>(12-37)</p>
<p class="image"><img src="images/000599.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Plugging <a href="#calibre_link-70">Eqs. (12-36)</a> and <a href="#calibre_link-71">(12-37)</a> into <a href="#calibre_link-72">Eq. (12-35)</a>,</p>
<p class="caption"><a id="calibre_link-73"></a>(12-38)</p>
<p class="image"><img src="images/000543.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Now here’s where the thumb comes in&mdash;when <em class="calibre7">b<sub class="calibre12">m</sub></em> is large, say over seven, the 2<sup class="calibre10">−<em class="calibre7">b<sub class="calibre15">m</sub></em></sup> value approaches zero; that is, as <em class="calibre7">b<sub class="calibre12">m</sub></em> increases, the all-ones fraction (1 − 2<sup class="calibre10">−<em class="calibre7">b<sub class="calibre15">m</sub></em></sup>) value in the numerator approaches 1. Assuming this, <a href="#calibre_link-73">Eq. (12-38)</a> becomes</p>
<p class="caption"><a id="calibre_link-74"></a>(12-39)</p>
<p class="image"><img src="images/001710.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Using <a href="#calibre_link-74">Eq. (12-39)</a>, we can estimate, for example, the dynamic range of the single-precision IEEE P754 standard floating-point format with its eight-bit exponent:</p>
<p class="caption"><a id="calibre_link-3185"></a>(12-40)</p>
<p class="image"><img src="images/000004.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3186"></a>Although we’ve introduced the major features of the most common floating-point formats, there are still more details to learn about floating-point numbers. For the interested reader, the references given in this section provide a good place to start.</p>
<p class="calibre3"><a id="calibre_link-674"></a></p>
<h3 class="calibre6">12.5 Block Floating-Point Binary Format</h3>
<p class="calibre3">A marriage of fixed-point and floating-point binary formats is known as <em class="calibre7">block floating point</em>. This scheme is used, particularly in dedicated FFT integrated circuits, when large arrays, or blocks, of associated data are to be manipulated mathematically. Block floating-point schemes begin by examining all the words in a block of data, normalizing the largest-valued word’s fraction, and establishing the correct exponent. This normalization takes advantage of the fraction’s full dynamic range. Next, the fractions of the remaining data words are shifted appropriately, so that they can use the exponent of the largest word. In this way, all of the data words use the same exponent value to conserve hardware memory.</p>
<p class="calibre3">In FFT implementations, the arithmetic is performed treating the block normalized data values as fixed-point binary. However, when an addition causes an overflow condition, all of the data words are shifted one bit to the right (division by two), and the exponent is incremented by one. As the reader may have guessed, block floating-point formats have increased dynamic range and avoid the overflow problems inherent in fixed-point formats but do not reach the performance level of true floating-point formats[<a href="#calibre_link-41">8</a>,<a href="#calibre_link-75">25</a>,<a href="#calibre_link-76">26</a>].</p>
<p class="calibre3"><a id="calibre_link-675"></a></p>
<h3 class="calibre6">References</h3>
<p class="chapterendnote"><a id="calibre_link-10"></a>[1] Neugebauer, O. “The History of Ancient Astronomy,” <em class="calibre7">Journal of Near Eastern Studies,</em> Vol. 4, 1945, p. 12.</p>
<p class="chapterendnote"><a id="calibre_link-13"></a>[2] Knuth, D. E. <em class="calibre7">The Art of Computer Programming: Seminumerical Methods</em>, Vol. 2, Addison-Wesley, Reading, Massachusetts, 1981, <a href="#calibre_link-77">Section 4.1</a>, p. 179.</p>
<p class="chapterendnote"><a id="calibre_link-40"></a>[3] Kester, W. “Peripheral Circuits Can Make or Break Sampling-ADC Systems,” <em class="calibre7">EDN Magazine</em>, October 1, 1992.</p>
<p class="chapterendnote"><a id="calibre_link-3187"></a>[4] Grove, M. “Measuring Frequency Response and Effective Bits Using Digital Signal Processing Techniques,” <em class="calibre7">Hewlett</em>-<em class="calibre7">Packard Journal,</em> February 1992.</p>
<p class="chapterendnote"><a id="calibre_link-3188"></a>[5] Tektronix. “Effective Bits Testing Evaluates Dynamic Range Performance of Digitizing Instruments,” <em class="calibre7">Tektronix Application Note,</em> No. 45W-7527, December 1989.</p>
<p class="chapterendnote"><a id="calibre_link-3189"></a>[6] Ushani, R. “Subranging ADCs Operate at High Speed with High Resolution,” <em class="calibre7">EDN Magazine</em>, April 11, 1991.</p>
<p class="chapterendnote"><a id="calibre_link-3190"></a><a id="calibre_link-3191"></a>[7] Demler, M. “Time-Domain Techniques Enhance Testing of High-Speed ADCs,” <em class="calibre7">EDN Magazine</em>, March 30, 1992.</p>
<p class="chapterendnote"><a id="calibre_link-41"></a>[8] Hilton, H. “A 10-MHz Analog-to-Digital Converter with 110-dB Linearity,” <em class="calibre7">Hewlett-Packard Journal</em>, October 1993.</p>
<p class="chapterendnote"><a id="calibre_link-51"></a>[9] Lyons, R. G. “Providing Software Flexibility for Optical Processor Noise Analysis,” <em class="calibre7">Computer Design</em>, July 1978, p. 95.</p>
<p class="chapterendnote"><a id="calibre_link-56"></a>[10] Knuth, D. E. <em class="calibre7">The Art of Computer Programming: Seminumerical Methods</em>, Vol. 2, Addison-Wesley, Reading, Massachusetts, 1981, <a href="#calibre_link-78">Section 4.2</a>, p. 198.</p>
<p class="chapterendnote"><a id="calibre_link-58"></a>[11] Rabiner, L. R., and Gold, B. <em class="calibre7">Theory and Application of Digital Signal Processing</em>, <a href="#calibre_link-79">Chapter 5</a>, Prentice Hall, Englewood Cliffs, New Jersey, 1975, p. 353.</p>
<p class="chapterendnote"><a id="calibre_link-3192"></a>[12] Jackson, L. B. “An Analysis of Limit Cycles Due to Multiplicative Rounding in Recursive Digital Filters,” <em class="calibre7">Proc. 7th Allerton Conf. Circuit System Theory</em>, 1969, pp. 69&ndash;78.</p>
<p class="chapterendnote"><a id="calibre_link-3193"></a>[13] Kan, E. P. F., and Aggarwal, J. K. “Error Analysis of Digital Filters Employing Floating Point Arithmetic,” <em class="calibre7">IEEE Trans. Circuit Theory</em>, Vol. CT-18, November 1971, pp. 678&ndash;686.</p>
<p class="chapterendnote"><a id="calibre_link-3194"></a>[14] Crochiere, R. E. “Digital Ladder Structures and Coefficient Sensitivity,” <em class="calibre7">IEEE Trans. Audio Electroacoustics</em>, Vol. AU-20, October 1972, pp. 240&ndash;246.</p>
<p class="chapterendnote"><a id="calibre_link-3195"></a>[15] Jackson, L. B. “On the Interaction of Roundoff Noise and Dynamic Range in Digital Filters,” <em class="calibre7">Bell System Technical Journal</em>, Vol. 49, February 1970, pp. 159&ndash;184.</p>
<p class="chapterendnote"><a id="calibre_link-3196"></a>[16] Roberts, R. A., and Mullis, C. T. <em class="calibre7">Digital Signal Processing</em>, Addison-Wesley, Reading, Massachusetts, 1987, p. 277.</p>
<p class="chapterendnote"><a id="calibre_link-3197"></a>[17] Jackson, L. B. “Roundoff Noise Analysis for Fixed-Point Digital Filters Realized in Cascade or Parallel Form,” <em class="calibre7">IEEE Trans. Audio Electroacoustics</em>, Vol. AU-18, June 1970, pp. 107&ndash;122.</p>
<p class="chapterendnote"><a id="calibre_link-57"></a>[18] Oppenheim, A. V., and Schafer, R. W. <em class="calibre7">Discrete</em>-<em class="calibre7">Time Signal Processing</em>, Prentice Hall, Englewood Cliffs, New Jersey, 1989, Sections 9.7 and 9.8.</p>
<p class="chapterendnote"><a id="calibre_link-59"></a>[19] Larimer, J., and Chen, D. “Fixed or Floating? A Pointed Question in DSPs,” <em class="calibre7">EDN Magazine</em>, August 3, 1995.</p>
<p class="chapterendnote"><a id="calibre_link-65"></a>[20] Ashton, C. “Floating Point Math Handles Iterative and Recursive Algorithms,” <em class="calibre7">EDN Magazine</em>, January 9, 1986.</p>
<p class="chapterendnote"><a id="calibre_link-3198"></a>[21] Windsor, B., and Wilson, J. “Arithmetic Duo Excels in Computing Floating Point Products,” <em class="calibre7">Electronic Design</em>, May 17, 1984.</p>
<p class="chapterendnote"><a id="calibre_link-66"></a>[22] Windsor, W. A. “IEEE Floating Point Chips Implement DSP Architectures,” <em class="calibre7">Computer Design</em>, January 1985.</p>
<p class="chapterendnote"><a id="calibre_link-67"></a>[23] Texas Instruments Inc. <em class="calibre7">Digital Signal Processing Applications with the TMS320 Family: Theory, Algorithms, and Implementations</em>, SPRA012A, Texas Instruments, Dallas, Texas, 1986.</p>
<p class="chapterendnote"><a id="calibre_link-69"></a>[24] Strauss, W. I. “Integer or Floating Point? Making the Choice,” <em class="calibre7">Computer Design Magazine</em>, April 1, 1990, p. 85.</p>
<p class="chapterendnote"><a id="calibre_link-3199"></a><a id="calibre_link-75"></a>[25] Oppenheim, A. V., and Weinstein, C. J. “Effects of Finite Register Length in Digital Filtering and the Fast Fourier Transform,” <em class="calibre7">Proceedings of the IEEE</em>, August 1972, pp. 957&ndash;976.</p>
<p class="chapterendnote"><a id="calibre_link-76"></a>[26] Woods, R. E. “Transform-Based Processing: How Much Precision Is Needed?” <em class="calibre7">ESD: The Electronic System Design Magazine</em>, February 1987.</p>
<p class="calibre3"><a id="calibre_link-676"></a></p>
<h3 class="calibre6"><a id="calibre_link-3200" class="calibre5"></a>Chapter 12 Problems</h3>
<p class="indenthanging6"><strong class="calibre9">12.1</strong> Given their specified format, convert the following integer binary numbers to decimal format:</p>
<p class="indenthangingn2"><strong class="calibre9">(a)</strong> 1100 0111, unsigned,</p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> 1100 0111, sign magnitude,</p>
<p class="indenthangingn2"><strong class="calibre9">(c)</strong> 1100 0111, two’s complement,</p>
<p class="indenthangingn2"><strong class="calibre9">(d)</strong> 1100 0111, offset binary.</p>
<p class="indenthanging6"><strong class="calibre9">12.2</strong> Convert the following unsigned integer binary numbers, given here in hexadecimal format, to decimal:</p>
<p class="indenthangingn2"><strong class="calibre9">(a)</strong> $A231,</p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> 0x71F.</p>
<p class="indenthanging6"><strong class="calibre9">12.3</strong> Given the hexadecimal integer numbers $07 and $E2 in two’s complement format, what is the decimal value of $07 minus $E2? Show your work.</p>
<p class="indenthanging6"><strong class="calibre9">12.4</strong> Sign-extend the following two’s complement integer numbers, given in hexadecimal format, to 16 bits and express the results in hexadecimal format:</p>
<p class="indenthangingn2"><strong class="calibre9">(a)</strong> $45,</p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> $B3.</p>
<p class="indenthanging6"><strong class="calibre9">12.5</strong> Show that the binary addition operation</p>
<p class="indentpara5"><img src="images/000236.jpg" alt="image" class="calibre2" /></p>
<p class="indentpara5">gives the correct decimal results when the two binary addends and the sum are in the following two’s complement fractional formats:</p>
<p class="indenthangingn2"><strong class="calibre9">(a)</strong> 7.1 (7 integer bits and 1 fractional bit),</p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> 6.2 (6 integer bits and 2 fractional bits),</p>
<p class="indenthangingn2"><strong class="calibre9">(c)</strong> 4.4 (4 integer bits and 4 fractional bits).</p>
<p class="indenthanging6"><strong class="calibre9">12.6</strong> Microchip Technology Inc. produces a microcontroller chip (Part #PIC24F) that accommodates 16-bit data words. When using a two’s complement integer number format, what are the most positive and most negative decimal numbers that can be represented by the microcontroller’s data word?</p>
<p class="indenthanging6"><a id="calibre_link-3201"></a><strong class="calibre9">12.7</strong> Consider four-bit unsigned binary words using a 2.2 (“two dot two”) “integer plus fraction” format. List all 16 possible binary words in this format and give their decimal equivalents.</p>
<p class="indenthanging6"><strong class="calibre9">12.8</strong> The annual residential property tax in California is 0.0165 times the assessed dollar value of the property. What is this 0.0165 tax rate factor in a two’s complement 1.15 format? Give the answer in both binary and hexadecimal representations. Show how you arrived at your solution.</p>
<p class="indenthanging6"><strong class="calibre9">12.9</strong> The decimal number 1/3 cannot be represented exactly with a finite number of decimal digits, nor with a finite number of binary bits. What would be the base of a number system that would allow decimal 1/3 to be exactly represented with a finite number of digits?</p>
<p class="indenthanging6"><strong class="calibre9">12.10</strong> If the number 4273<sub class="calibre12">6</sub> is in a base 6 numbering system, what would be its decimal value?</p>
<p class="indenthanging6"><strong class="calibre9">12.11</strong> Think about a 32-bit two’s complement fixed-point binary number having 31 fractional bits (a “1.31” two’s complement number). This number format is very common in today’s high-performance programmable DSP chips.</p>
<p class="indenthangingn2"><strong class="calibre9">(a)</strong> What is the most positive decimal value that can be represented by such a binary number? Show how you arrived at your solution.</p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> What is the most negative decimal value?</p>
<p class="indenthanging6"><strong class="calibre9">12.12</strong> As of this writing, Analog Devices Inc. produces an integrated circuit (Part #AD9958), called a <em class="calibre7">direct digital synthesizer</em>, that generates high-precision analog sinewaves. The AD9958 uses a 31-bit binary word to control the device’s output frequency. When the control word is at its minimum value, the device’s output frequency is zero Hz. When the control word is at its maximum value, the output frequency is 250 MHz. What is the frequency resolution (the frequency step size) of this sinusoidal signal generator in Hz?</p>
<p class="indenthanging6"><strong class="calibre9">12.13</strong> The first commercial audio compact disc (CD) players used 16-bit samples to represent an analog audio signal. Their sample rate was <em class="calibre7">f<sub class="calibre12">s</sub></em> = 44.1 kHz. Those 16-bit samples were applied to a digital-to-analog (D/A) converter whose analog output was routed to a speaker. What is the combined data output rate of the digital portion, measured in bytes (8-bit binary words) per second, of a stereo CD player?</p>
<p class="indenthanging6"><strong class="calibre9">12.14</strong> When implementing a digital filter using a fixed-point binary number format, care must be taken to avoid arithmetic overflow errors. With that notion in mind, if the <em class="calibre7">x</em>(<em class="calibre7">n</em>) input samples in <a href="#calibre_link-80">Figure P12-14</a> are eight-bit binary words, <a id="calibre_link-3202"></a>how many bits are needed to represent the <em class="calibre7">y</em>(<em class="calibre7">n</em>) output sequence to avoid any data overflow errors? Show how you arrived at your answer.</p>
<p class="caption"><a id="calibre_link-80"></a><strong class="calibre9">Figure P12-14</strong></p>
<p class="image"><img src="images/001610.jpg" alt="image" class="calibre2" /></p>
<p class="indentpara5"><strong class="calibre9">Hint:</strong> Review the last portion of the text’s <a href="#calibre_link-81">Section 12.3.2</a>.</p>
<p class="indenthanging6"><strong class="calibre9">12.15</strong> Review the brief description of <em class="calibre7"><a href="#calibre_link-82">allpass filters</a></em> in <a href="#calibre_link-83">Appendix F</a>. One form of an allpass filter is shown in <a href="#calibre_link-84">Figure P12-15(a)</a>. For the filter to have the desired constant magnitude response over its full operating frequency, coefficient <em class="calibre7">A</em> must be equal to</p>
<p class="image"><img src="images/001127.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-84"></a><strong class="calibre9">Figure P12-15</strong></p>
<p class="image"><img src="images/000633.jpg" alt="image" class="calibre2" /></p>
<p class="indentpara5">If the filter is designed such that <em class="calibre7">B</em> = 2.5, show why we cannot achieve the desired constant frequency magnitude response when coefficients <em class="calibre7">A</em> and <em class="calibre7">B</em> are quantized using four-bit unsigned binary words in a 2.2 (“two dot two”) “integer plus fraction” format, where <em class="calibre7">A</em><sub class="calibre12">Q</sub> and <em class="calibre7">B</em><sub class="calibre12">Q</sub> are the quantized coefficients as shown in <a href="#calibre_link-84">Figure P12-15(b)</a>.</p>
<p class="indenthanging6"><a id="calibre_link-3203"></a><strong class="calibre9">12.16</strong> National Semiconductors Inc. produces a digital tuner chip (Part #CLC5903), used for building digital receivers, that has the capability to amplify its output signal by shifting its binary signal sample values to the left by as few as one bit to as many as seven bits. What is the maximum gain, measured in dB (decibels), of this tuner’s bit-shifting amplification capability?</p>
<p class="indenthanging6"><strong class="calibre9">12.17</strong> <a href="#calibre_link-85">Figure P12-17</a> shows an algorithm that approximates the operation of dividing a sign-magnitude binary number <em class="calibre7">x</em>(<em class="calibre7">n</em>) by an integer value <em class="calibre7">K</em>. (A block containing the “&mdash;&gt; 2” symbol means truncation by way of a binary right shift by two bits.) What is the value of integer <em class="calibre7">K</em>? Show your work.</p>
<p class="caption"><a id="calibre_link-85"></a><strong class="calibre9">Figure P12-17</strong></p>
<p class="image"><img src="images/001380.jpg" alt="image" class="calibre2" /></p>
<p class="indenthanging6"><strong class="calibre9">12.18</strong> When using programmable DSP chips, multiplication is a simple straightforward operation. However, when using field-programmable gate arrays (FPGAs), multiplier hardware is typically difficult to implement and should be avoided whenever possible. <a href="#calibre_link-86">Figure P12-18</a> shows how we can multiply a binary <em class="calibre7">x</em>(<em class="calibre7">n</em>) input sequence by 54, without the need for multiplier hardware. What are the values for <em class="calibre7">A</em> and <em class="calibre7">B</em> in <a href="#calibre_link-86">Figure P12-18</a> so that <em class="calibre7">y</em>(<em class="calibre7">n</em>) equals 54 times <em class="calibre7">x</em>(<em class="calibre7">n</em>)?</p>
<p class="caption"><a id="calibre_link-86"></a><strong class="calibre9">Figure P12-18</strong></p>
<p class="image"><img src="images/000527.jpg" alt="image" class="calibre2" /></p>
<p class="indenthanging6"><a id="calibre_link-3204"></a><strong class="calibre9">12.19</strong> Consider the network shown in <a href="#calibre_link-87">Figure P12-19</a> which approximates a 2nd-order differentiation operation. In many DSP implementations (using field-programmable gate arrays, for example) it is advantageous to minimize the number of multiplications. Assuming that all the sequences in <a href="#calibre_link-87">Figure P12-19</a> use a binary two’s complement integer number format, what data bit manipulations must be implemented to eliminate the two multipliers?</p>
<p class="caption"><a id="calibre_link-87"></a><strong class="calibre9">Figure P12-19</strong></p>
<p class="image"><img src="images/001385.jpg" alt="image" class="calibre2" /></p>
<p class="indenthanging6"><strong class="calibre9">12.20</strong> Agilent Inc. produces an A/D converter (Model #DP1400) whose sample rate is 2×10<sup class="calibre10">9</sup> samples/second (<em class="calibre7">f<sub class="calibre12">s</sub></em> = 2 GHz). This digitizer provides super-fine time resolution samples of analog signals whose durations are <em class="calibre7">T</em> = 5×10<sup class="calibre10">−6</sup> seconds (5 microseconds) as shown in <a href="#calibre_link-88">Figure P12-20</a>. If each converter output sample is stored in one memory location of a computer, how many memory locations are required to store the converter’s <em class="calibre7">x</em>(<em class="calibre7">n</em>) output sequence representing the 5-microsecond-duration <em class="calibre7">x</em>(<em class="calibre7">t</em>) signal?</p>
<p class="caption"><a id="calibre_link-88"></a><strong class="calibre9">Figure P12-20</strong></p>
<p class="image"><img src="images/000426.jpg" alt="image" class="calibre2" /></p>
<p class="indenthanging6"><strong class="calibre9">12.21</strong> Here is a problem often encountered by DSP engineers. Assume we sample exactly three cycles of a continuous <em class="calibre7">x</em>(<em class="calibre7">t</em>) sinewave resulting in a block of 1024 <a id="calibre_link-3205"></a><em class="calibre7">x</em>(<em class="calibre7">n</em>) time samples and compute a 1024-point fast Fourier transform (FFT) to obtain the FFT magnitude samples. Also assume that we repeat the sampling and FFT magnitude computations many times and average the FFT magnitude sequences to produce the average magnitude samples, |<em class="calibre7">X</em><sub class="calibre12">ave</sub>(<em class="calibre7">m</em>)|, shown in <a href="#calibre_link-89">Figure P12-21</a>. (We averaged multiple FFT magnitude sequences to increase the accuracy, by reducing the variance, of our final |<em class="calibre7">X</em><sub class="calibre12">ave</sub>(<em class="calibre7">m</em>)| sequence.) If the A/D converter produces ten-bit binary words in sign-magnitude format and has an input full-scale bipolar voltage range of ±5 volts, what is the peak value of the continuous <em class="calibre7">x</em>(<em class="calibre7">t</em>) sinewave? Justify your answer.</p>
<p class="caption"><a id="calibre_link-89"></a><strong class="calibre9">Figure P12-21</strong></p>
<p class="image"><img src="images/001276.jpg" alt="image" class="calibre2" /></p>
<p class="indenthanging6"><strong class="calibre9">12.22</strong> Suppose we have a 12-bit A/D converter that operates over an input voltage range of ±5 volts (10 volts peak-peak). Assume the A/D converter is <em class="calibre7">ideal</em> in its operation and its transfer function is that shown in <a href="#calibre_link-90">Figure P12-22</a> where the tick mark spacing of the <em class="calibre7">x</em>(<em class="calibre7">t</em>) and <em class="calibre7">x</em>(<em class="calibre7">n</em>) axes is the converter’s quantization-level <em class="calibre7">q</em>.</p>
<p class="caption"><a id="calibre_link-90"></a><strong class="calibre9">Figure P12-22</strong></p>
<p class="image"><img src="images/000313.jpg" alt="image" class="calibre2" /></p>
<p class="indenthangingn2"><a id="calibre_link-3206"></a><strong class="calibre9">(a)</strong> What is the A/D converter’s quantization-level <em class="calibre7">q</em> (least significant bit) voltage?</p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> What are the A/D converter’s maximum positive and maximum negative quantization error voltages?</p>
<p class="indenthangingn2"><strong class="calibre9">(c)</strong> If we apply a 7-volt peak-peak sinusoidal voltage to the converter’s analog input, what A/D output signal-to-quantization noise value, <em class="calibre7">SNR</em><sub class="calibre12">A/D</sub> in dB, should we expect? Show how you arrived at your answer.</p>
<p class="indenthanging6"><strong class="calibre9">12.23</strong> Suppose an A/D converter manufacturer applies a 10-volt peak-peak sinusoidal voltage to their 12-bit converter’s analog input, conducts careful testing, and measures the converter’s overall signal-to-noise level to be 67 dB. What is the <em class="calibre7">effective number of bits</em> value, <em class="calibre7">b</em><sub class="calibre12">eff</sub>, for their A/D converter?</p>
<p class="indenthanging6"><strong class="calibre9">12.24</strong> Let’s reinforce our understanding of the quantization errors induced by typical A/D converters.</p>
<p class="indenthangingn2"><strong class="calibre9">(a)</strong> <a href="#calibre_link-91">Figure P12-24</a> shows the quantized <em class="calibre7">x</em>(<em class="calibre7">n</em>) output integer values of truncating and rounding A/D converters as a function of their continuous <em class="calibre7">x</em>(<em class="calibre7">t</em>) input voltage. It’s sensible to call those bold <em class="calibre7">stair-step</em> curves the “transfer functions” of the A/D converters. The curves are normalized to the A/D converter’s quantization-level voltage <em class="calibre7">q</em>, such that an <em class="calibre7">x</em>(<em class="calibre7">t</em>) value of 2 represents a voltage of 2<em class="calibre7">q</em> volts. Draw the curves of the quantization error as a function of the continuous <em class="calibre7">x</em>(<em class="calibre7">t</em>) input for both truncating and rounding A/D converters.</p>
<p class="caption"><a id="calibre_link-91"></a><strong class="calibre9">Figure P12-24</strong></p>
<p class="image"><img src="images/001155.jpg" alt="image" class="calibre2" /></p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> Fill in the following table of important A/D converter quantization error properties in terms of the A/D converters’ quantization-level voltage <em class="calibre7">q</em>.</p>
<p class="image"><a id="calibre_link-3207"></a><img src="images/001228.jpg" alt="image" class="calibre2" /></p>
<p class="indenthanging6"><strong class="calibre9">12.25</strong> Assume we want to digitize the output voltage of a temperature measurement system, monitoring the internal temperature of an automobile radiator, as shown in <a href="#calibre_link-92">Figure P12-25</a>. The system’s manufacturer states that its output voltage <em class="calibre7">v</em>(<em class="calibre7">t</em>) will represent the thermocouple’s junction temperature with an accuracy of 2 degrees Fahrenheit (1.1 degrees Celsius), and its operating range covers temperatures as low as just-freezing water to twice the temperature of boiling water. To accommodate the precision and operating range of the temperature measurement system, how many bits, <em class="calibre7">b</em>, do we need for our A/D converter? Show your work.</p>
<p class="caption"><a id="calibre_link-92"></a><strong class="calibre9">Figure P12-25</strong></p>
<p class="image"><img src="images/001215.jpg" alt="image" class="calibre2" /></p>
<p class="indenthanging6"><strong class="calibre9">12.26</strong> One useful way to test the performance of A/D converters is to apply a specific analog signal to the A/D converter’s analog input and perform a histogram of the converter’s output samples. For example, if an analog squarewave-like signal is applied to an A/D converter, the converter’s output sequence might be that shown in the left panel of <a href="#calibre_link-93">Figure P12-26(a)</a>, and the histogram of the converter’s output samples is shown in the right panel of <a href="#calibre_link-93">Figure P12-26(a)</a>. That histogram shows that there are many converter output samples whose values are −0.2, and many converter output samples whose values are 0.5, and no sample values other than −0.2 and 0.5. The shape of the histogram curve will indicate any severe defects in the converter’s performance.</p>
<p class="caption"><a id="calibre_link-93"></a><strong class="calibre9">Figure P12-26</strong></p>
<p class="image"><img src="images/001043.jpg" alt="image" class="calibre2" /></p>
<p class="indentpara5">If a triangular analog signal is applied to an A/D converter, the converter’s output sequence would be that shown in the left panel of <a href="#calibre_link-93">Figure P12-26(b)</a> <a id="calibre_link-3208"></a>and the histogram of the converter’s output samples is shown in the right panel of <a href="#calibre_link-93">Figure P12-26(b)</a>. This histogram shows that there are (ideally) an equal number of samples at all amplitudes between −1 and +1, which happens to indicate correct converter behavior.</p>
<p class="indentpara5">In the testing of high-frequency A/D converters, high-frequency analog square and triangular waves are difficult to generate, so A/D converter engineers use high-frequency analog sinewaves to test their converters. Assuming that an analog sinewave is used as an input for A/D converter histogram testing and the converter output samples are those shown in the left panel of <a href="#calibre_link-93">Figure P12-26(c)</a>, draw a rough sketch of the histogram of converter output samples.</p>
<p class="indenthanging6"><strong class="calibre9">12.27</strong> In the text we discussed how to use the concept of a uniform probability density function (PDF), described in <a href="#calibre_link-94">Section D.3</a> of <a href="#calibre_link-27">Appendix D</a>, to help us determine the variance (a measure of power) of random A/D-converter <a id="calibre_link-3209"></a>quantization noise. Sometimes we want to generate random noise samples, for testing purposes, that have a uniform PDF such as that shown in <a href="#calibre_link-95">Figure P12-27</a>. What is the value of <em class="calibre7">A</em> for a uniform PDF random sequence whose variance is equal to 2?</p>
<p class="caption"><a id="calibre_link-95"></a><strong class="calibre9">Figure P12-27</strong></p>
<p class="image"><img src="images/000099.jpg" alt="image" class="calibre2" /></p>
<p class="indenthanging6"><strong class="calibre9">12.28</strong> Assume we have a single numerical data sample value in floating-point binary format. What two bit manipulation methods exist to multiply that sample by 4 without using any multiplier hardware circuitry?</p>
<p class="indenthanging6"><strong class="calibre9">12.29</strong> Convert the following IEEE P754 floating-point number, given here in hexadecimal format, to a decimal number:</p>
<p class="indentpara5">$C2ED0000</p>
<p class="indentpara5">Show your work.</p>
<p class="indentpara5"><strong class="calibre9">Hint:</strong> Don’t forget to account for the hidden one in the IEEE P754 format.</p>
</div>


</body></html>
