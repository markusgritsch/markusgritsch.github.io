<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="style.css" rel="stylesheet" type="text/css" /><title>Understanding Digital Signal Processing</title>
<style type="text/css">
body {
  -webkit-text-size-adjust: 260%; /* text */
  zoom: 1.8; /* graphics */
  font-family: "BookerlyLCD";
}
a {
  color: #005090;
  text-decoration: none;
}
a {font-variant-numeric: oldstyle-nums proportional-nums;}
p.caption {font-variant-numeric: oldstyle-nums proportional-nums;}
</style>
</head><body>


<div class="calibre" id="calibre_link-572">
<p class="calibre3"><a id="calibre_link-2482"></a></p>
<h2 class="calibre8"><a id="calibre_link-2483" class="calibre5"></a>Contents</h2>
<p class="toc-chapter"><strong class="calibre9"><a href="#calibre_link-452">4 THE FAST FOURIER TRANSFORM</a></strong></p>
<p class="toc-section"><a href="#calibre_link-77">4.1 Relationship of the FFT to the DFT</a></p>
<p class="toc-section"><a href="#calibre_link-78">4.2 Hints on Using FFTs in Practice</a></p>
<p class="toc-section"><a href="#calibre_link-601">4.3 Derivation of the Radix-2 FFT Algorithm</a></p>
<p class="toc-section"><a href="#calibre_link-602">4.4 FFT Input/Output Data Index Bit Reversal</a></p>
<p class="toc-section"><a href="#calibre_link-603">4.5 Radix-2 FFT Butterfly Structures</a></p>
<p class="toc-section"><a href="#calibre_link-604">4.6 Alternate Single-Butterfly Structures</a></p>
<p class="toc-section1"><a href="#calibre_link-605">References</a></p>

</div>


<div class="calibre" id="calibre_link-452">
<p class="calibre3"><a id="calibre_link-288"></a></p>
<h2 class="calibre8"><a id="calibre_link-2088" class="calibre5"></a>4 The Fast Fourier Transform</h2>
<p class="image"><img src="images/001636.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Although the DFT is the most straightforward mathematical procedure for determining the frequency content of a time-domain sequence, it’s terribly inefficient. As the number of points in the DFT is increased to hundreds, or thousands, the amount of necessary number crunching becomes excessive. In 1965 a paper was published by Cooley and Tukey describing a very efficient algorithm to implement the DFT<a href="#calibre_link-453">[1]</a>. That algorithm is now known as the <em class="calibre7">fast Fourier transform</em> (FFT).<sup class="calibre10"><a id="calibre_link-455"></a><a href="#calibre_link-454">†</a></sup> Before the advent of the FFT, thousand-point DFTs took so long to perform that their use was restricted to the larger research and university computer centers. Thanks to Cooley, Tukey, and the semiconductor industry, 1024-point DFTs can now be performed in a few seconds on home computers.</p>
<p class="footnotes"><a id="calibre_link-454"></a><sup class="calibre11"><a href="#calibre_link-455">†</a></sup> Actually, the FFT has an interesting history. While analyzing X-ray scattering data, a couple of physicists in the 1940s were taking advantage of the symmetries of sines and cosines using a mathematical method based on a technique published in the early 1900s. Remarkably, over 20 years passed before the FFT was (re)discovered. Reference <a href="#calibre_link-456">[2]</a> tells the full story.</p>
<p class="calibre3">Volumes have been written about the FFT, and, as for no other innovation, the development of this algorithm transformed the discipline of digital signal processing by making the power of Fourier analysis affordable. In this chapter, we’ll show why the most popular FFT algorithm (called the <em class="calibre7">radix-2</em> FFT) is superior to the classical DFT algorithm, present a series of recommendations to enhance our use of the FFT in practice, and provide a list of sources for FFT routines in various software languages. We conclude this chapter, for those readers wanting to know the internal details, with a derivation of the radix-2 FFT and introduce several different ways in which this FFT is implemented.</p>
<p class="calibre3"><a id="calibre_link-77"></a></p>
<h3 class="calibre6"><a id="calibre_link-2131" class="calibre5"></a>4.1 Relationship of the FFT to the DFT</h3>
<p class="calibre3">Although many different FFT algorithms have been developed, in this section we’ll see why the radix-2 FFT algorithm is so popular and learn how it’s related to the classical DFT algorithm. The radix-2 FFT algorithm is a very efficient process for performing DFTs under the constraint that the DFT size be an integral power of two. (That is, the number of points in the transform is <em class="calibre7">N</em> = 2<em class="calibre7"><sup class="calibre10">k</sup></em>, where <em class="calibre7">k</em> is some positive integer.) Let’s see just why the radix-2 FFT is the favorite spectral analysis technique used by signal processing practitioners.</p>
<p class="calibre3">Recall that our DFT Example 1 in <a href="#calibre_link-457">Section 3.1</a> illustrated the number of redundant arithmetic operations necessary for a simple 8-point DFT. (For example, we ended up calculating the product of 1.0607 · 0.707 four separate times.) On the other hand, the radix-2 FFT eliminates these redundancies and greatly reduces the number of necessary arithmetic operations. To appreciate the FFT’s efficiency, let’s consider the number of complex multiplications necessary for our old friend, the expression for an <em class="calibre7">N</em>-point DFT,</p>
<p class="caption"><a id="calibre_link-458"></a>(4-1)</p>
<p class="image"><img src="images/000454.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">For an 8-point DFT, <a href="#calibre_link-458">Eq. (4-1)</a> tells us that we’d have to perform <em class="calibre7">N</em><sup class="calibre10">2</sup> or 64 complex multiplications. (That’s because we assume, in the general case, that <em class="calibre7">x</em>(<em class="calibre7">n</em>) are complex-valued samples and for each of the eight <em class="calibre7">X</em>(<em class="calibre7">m</em>)s we have to sum eight complex products as <em class="calibre7">n</em> goes from 0 to 7.) As we’ll verify in later sections of this chapter, the number of complex multiplications, for an <em class="calibre7">N</em>-point FFT, is approximately</p>
<p class="caption"><a id="calibre_link-511"></a>(4-2)</p>
<p class="image"><img src="images/001310.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">(We say approximately because some multiplications turn out to be multiplications by +1 or −1, which amount to mere sign changes.) Well, this (<em class="calibre7">N</em>/2)log<sub class="calibre12">2</sub><em class="calibre7">N</em> value is a significant reduction from the <em class="calibre7">N</em><sup class="calibre10">2</sup> complex multiplications required by <a href="#calibre_link-458">Eq. (4-1)</a>, particularly for large <em class="calibre7">N</em>. To show just how significant, <a href="#calibre_link-459">Figure 4-1</a> compares the number of complex multiplications required by DFTs and radix-2 FFTs as a function of the number of input data points <em class="calibre7">N</em>. When <em class="calibre7">N</em> = 512, for example, the DFT requires 114 times the number of complex multiplications than needed by the FFT. When <em class="calibre7">N</em> = 8192, the DFT must calculate 1260 complex multiplications for <em class="calibre7">each</em> complex multiplication in the FFT!</p>
<p class="caption"><a id="calibre_link-459"></a><strong class="calibre9">Figure 4-1</strong> Number of complex multiplications in the DFT and the radix-2 FFT as a function of <em class="calibre7">N</em>.</p>
<p class="image"><img src="images/001281.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Here’s my favorite example of the efficiency of the radix-2 FFT. Say you perform a two-million-point FFT (<em class="calibre7">N</em> = 2,097,152) on your desktop computer and it takes 10 seconds. A two-million-point DFT, on the other hand, using your computer, will take more than three weeks! The publication and dissemination of the radix-2 FFT algorithm was, arguably, the most important event in digital signal processing.</p>
<p class="calibre3"><a id="calibre_link-2184"></a>It’s appropriate now to make clear that the FFT is not an approximation of the DFT. It’s exactly equal to the DFT; it <em class="calibre7">is</em> the DFT. Moreover, all of the performance characteristics of the DFT described in the previous chapter, output symmetry, linearity, output magnitudes, leakage, scalloping loss, etc., also describe the behavior of the FFT.</p>
<p class="calibre3"><a id="calibre_link-78"></a></p>
<h3 class="calibre6">4.2 Hints on Using FFTs in Practice</h3>
<p class="calibre3">Based on how useful FFTs are, here’s a list of practical pointers, or tips, on acquiring input data samples and using the radix-2 FFT to analyze real-world signals or data.</p>
<p class="calibre3"><a id="calibre_link-2625"></a></p>
<h4 class="calibre13">4.2.1 Sample Fast Enough and Long Enough</h4>
<p class="calibre3">When digitizing continuous signals with an A/D converter, for example, we know, from <a href="#calibre_link-287">Chapter 2</a>, that our sampling rate must be greater than twice the bandwidth of the continuous A/D input signal to prevent frequency-domain aliasing. Depending on the application, practitioners typically sample at 2.5 to 4 times the signal bandwidth. If we know that the bandwidth of the continuous signal is not too large relative to the maximum sample rate of our A/D converter, it’s easy to avoid aliasing. If we don’t know the continuous A/D input signal’s bandwidth, how do we tell if we’re having aliasing problems? Well, we should mistrust any FFT results that have <a id="calibre_link-2440"></a>significant spectral components at frequencies near half the sample rate. Ideally, we’d like to work with signals whose spectral amplitudes decrease with increasing frequency. Be very suspicious of aliasing if there are any spectral components whose frequencies appear to depend on the sample rate. If we suspect that aliasing is occurring or that the continuous signal contains broadband noise, we’ll have to use an analog lowpass filter prior to A/D conversion. The cutoff frequency of the lowpass filter must, of course, be greater than the frequency band of interest but less than half the sample rate.</p>
<p class="calibre3">Although we know that an <em class="calibre7">N</em>-point radix-2 FFT requires <em class="calibre7">N</em> = 2<em class="calibre7"><sup class="calibre10">k</sup></em> input samples, just how many samples must we collect before we perform our FFT? The answer is that the data collection time interval must be long enough to satisfy our desired FFT frequency resolution for the given sample rate <em class="calibre7">f<sub class="calibre12">s</sub></em>. The data collection time interval is the reciprocal of the desired FFT frequency resolution, and the longer we sample at a fixed <em class="calibre7">f<sub class="calibre12">s</sub></em> sample rate, the finer our frequency resolution will be; that is, the total data collection time interval is <em class="calibre7">N</em>/<em class="calibre7">f<sub class="calibre12">s</sub></em> seconds, and our <em class="calibre7">N</em>-point FFT bin-to-bin (sample-to-sample) frequency resolution is <em class="calibre7">f<sub class="calibre12">s</sub></em>/<em class="calibre7">N</em> Hz. So, for example, if we need a spectral resolution of 5 Hz, then <em class="calibre7">f<sub class="calibre12">s</sub></em>/<em class="calibre7">N</em> = 5 Hz, and</p>
<p class="caption"><a id="calibre_link-2626"></a>(4-3)</p>
<p class="image"><img src="images/000345.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">In this case, if <em class="calibre7">f<sub class="calibre12">s</sub></em> is, say, 10 kHz, then <em class="calibre7">N</em> must be at least 2000, and we’d choose <em class="calibre7">N</em> equal to 2048 because this number is a power of two.</p>
<p class="calibre3"><a id="calibre_link-2627"></a></p>
<h4 class="calibre13">4.2.2 Manipulating the Time Data Prior to Transformation</h4>
<p class="calibre3">When using the radix-2 FFT, if we don’t have control over the length of our time-domain data sequence, and that sequence length is not an integral power of two, we have two options. We could discard enough data samples so that the remaining FFT input sequence length is some integral power of two. This scheme is not recommended because ignoring data samples degrades our resultant frequency-domain resolution. (The larger <em class="calibre7">N</em> is, the better our frequency resolution, right?) A better approach is to append enough zero-valued samples to the end of the time data sequence to match the number of points of the next largest radix-2 FFT. For example, if we have 1000 time samples to transform, rather than analyzing only 512 of them with a 512-point FFT, we should add 24 trailing zero-valued samples to the original sequence and use a 1024-point FFT. (This <em class="calibre7">zero-padding</em> technique is discussed in more detail in <a href="#calibre_link-460">Section 3.11</a>.)</p>
<p class="calibre3">FFTs suffer the same ill effects of spectral leakage that we discussed for the DFT in <a href="#calibre_link-461">Section 3.8</a>. We can multiply the time data by a window function to alleviate this leakage problem. Be prepared, though, for the frequency resolution degradation inherent when windows are used. By the way, if appending <a id="calibre_link-2020"></a>zeros is necessary to extend a time sequence, we have to make sure that we append the zeros <em class="calibre7">after</em> multiplying the original time data sequence by a window function. Applying a window function to the appended zeros will distort the resultant window and worsen our FFT leakage problems.</p>
<p class="calibre3">Although windowing will reduce leakage problems, it will not eliminate them altogether. Even when windowing is employed, high-level spectral components can obscure nearby low-level spectral components. This is especially evident when the original time data has a nonzero average, i.e., it’s riding on a DC bias. When the FFT is performed in this case, a large-amplitude DC spectral component at 0 Hz will overshadow its spectral neighbors. We can eliminate this problem by calculating the average of the time sequence and subtracting that average value from each sample in the original sequence. (The averaging and subtraction process must be performed before windowing.) This technique makes the new time sequence’s average (mean) value equal to zero and eliminates any high-level, zero Hz component in the FFT results.</p>
<p class="calibre3"><a id="calibre_link-2628"></a></p>
<h4 class="calibre13">4.2.3 Enhancing FFT Results</h4>
<p class="calibre3">If we’re using the FFT to detect signal energy in the presence of noise and enough time-domain data is available, we can improve the sensitivity of our processing by averaging multiple FFTs. This technique, discussed in <a href="#calibre_link-462">Section 11.3</a>, can be implemented to detect signal energy that’s actually below the average noise level; that is, given enough time-domain data, we can detect signal components that have negative signal-to-noise ratios.</p>
<p class="calibre3">If our original time-domain data is real-valued only, we can take advantage of the 2<em class="calibre7">N</em>-Point Real FFT technique in <a href="#calibre_link-463">Section 13.5</a> to speed up our processing; that is, a 2<em class="calibre7">N</em>-point real sequence can be transformed with a single <em class="calibre7">N</em>-point complex radix-2 FFT. Thus we can get the frequency resolution of a 2<em class="calibre7">N</em>-point FFT for just about the computational price of performing a standard <em class="calibre7">N</em>-point FFT. Another FFT speed enhancement is the possible use of the frequency-domain windowing technique discussed in <a href="#calibre_link-464">Section 13.3</a>. If we need the FFT of unwindowed time-domain data and, at the same time, we also want the FFT of that same time data with a window function applied, we don’t have to perform two separate FFTs. We can perform the FFT of the unwindowed data, and then we can perform frequency-domain windowing to reduce spectral leakage on any, or all, of the FFT bin outputs.</p>
<p class="calibre3"><a id="calibre_link-2629"></a></p>
<h4 class="calibre13">4.2.4 Interpreting FFT Results</h4>
<p class="calibre3">The first step in interpreting FFT results is to compute the absolute frequency of the individual FFT bin centers. Like the DFT, the FFT bin spacing is the ratio of the sampling rate (<em class="calibre7">f<sub class="calibre12">s</sub></em>) over the number of points in the FFT, or <em class="calibre7">f<sub class="calibre12">s</sub></em>/<em class="calibre7">N</em>. With our FFT output designated by <em class="calibre7">X</em>(<em class="calibre7">m</em>), where <em class="calibre7">m</em> = 0, 1, 2, 3, . . ., <em class="calibre7">N</em>−1, the <a id="calibre_link-2406"></a>absolute frequency of the <em class="calibre7">m</em>th bin center is <em class="calibre7">mf<sub class="calibre12">s</sub></em>/<em class="calibre7">N</em>. If the FFT’s input time samples are real, only the <em class="calibre7">X</em>(<em class="calibre7">m</em>) outputs from <em class="calibre7">m</em> = 0 to <em class="calibre7">m</em> = <em class="calibre7">N</em>/2 are independent. So, in this case, we need determine only the absolute FFT bin frequencies for <em class="calibre7">m</em> over the range of 0 ≤ <em class="calibre7">m</em> ≤ <em class="calibre7">N</em>/2. If the FFT input samples are complex, all <em class="calibre7">N</em> of the FFT outputs are independent, and we should compute the absolute FFT bin frequencies for <em class="calibre7">m</em> over the full range of 0 ≤ <em class="calibre7">m</em> ≤ <em class="calibre7">N</em>−1.</p>
<p class="calibre3">If necessary, we can determine the true amplitude of time-domain signals from their FFT spectral results. To do so, we have to keep in mind that radix-2 FFT outputs are complex and of the form</p>
<p class="caption"><a id="calibre_link-2630"></a>(4-4)</p>
<p class="image"><img src="images/001188.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Also, the FFT output magnitude samples,</p>
<p class="caption"><a id="calibre_link-2631"></a>(4-5)</p>
<p class="image"><img src="images/000230.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">are all inherently multiplied by the factor <em class="calibre7">N</em>/2, as described in <a href="#calibre_link-465">Section 3.4</a>, when the input samples are real. If the FFT input samples are complex, the scaling factor is <em class="calibre7">N</em>. So to determine the correct amplitudes of the time-domain sinusoidal components, we’d have to divide the FFT magnitudes by the appropriate scale factor, <em class="calibre7">N</em>/2 for real inputs and <em class="calibre7">N</em> for complex inputs.</p>
<p class="calibre3">If a window function was used on the original time-domain data, some of the FFT input samples will be attenuated. This reduces the resultant FFT output magnitudes from their true unwindowed values. To calculate the correct amplitudes of various time-domain sinusoidal components, then, we’d have to further divide the FFT magnitudes by the appropriate processing loss factor associated with the window function used. Processing loss factors for the most popular window functions are listed in reference <a href="#calibre_link-466">[3]</a>.</p>
<p class="calibre3">Should we want to determine the power spectrum <em class="calibre7">X</em><sub class="calibre12">PS</sub>(<em class="calibre7">m</em>) of an FFT result, we’d calculate the magnitude-squared values using</p>
<p class="caption"><a id="calibre_link-2632"></a>(4-6)</p>
<p class="image"><img src="images/001073.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Doing so would allow us to compute the power spectrum in dB with</p>
<p class="caption"><a id="calibre_link-2633"></a>(4-7)</p>
<p class="image"><img src="images/000130.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The normalized power spectrum in decibels can be calculated using</p>
<p class="caption"><a id="calibre_link-467"></a>(4-8)</p>
<p class="image"><img src="images/000967.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2190"></a>or</p>
<p class="caption"><a id="calibre_link-468"></a>(4-9)</p>
<p class="image"><img src="images/000017.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">In <a href="#calibre_link-467">Eqs. (4-8)</a> and <a href="#calibre_link-468">(4-9)</a>, the term |<em class="calibre7">X</em>(<em class="calibre7">m</em>)|<sub class="calibre12">max</sub> is the largest FFT output magnitude sample. In practice, we find that plotting <em class="calibre7">X</em><sub class="calibre12">dB</sub>(<em class="calibre7">m</em>) is very informative because of the enhanced low-magnitude resolution afforded by the logarithmic decibel scale, as described in <a href="#calibre_link-296">Appendix E</a>. If either <a href="#calibre_link-467">Eq. (4-8)</a> or <a href="#calibre_link-468">Eq. (4-9)</a> is used, no compensation need be performed for the above-mentioned <em class="calibre7">N</em> or <em class="calibre7">N</em>/2 FFT scale or window processing loss factors. Normalization through division by (|<em class="calibre7">X</em>(<em class="calibre7">m</em>)|<sub class="calibre12">max</sub>)<sup class="calibre10">2</sup> or |<em class="calibre7">X</em>(<em class="calibre7">m</em>)|<sub class="calibre12">max</sub> eliminates the effect of any absolute FFT or window scale factors.</p>
<p class="calibre3">Knowing that the phase angles <em class="calibre7">X</em><sub class="calibre12">ø</sub>(<em class="calibre7">m</em>) of the individual FFT outputs are given by</p>
<p class="caption"><a id="calibre_link-469"></a>(4-10)</p>
<p class="image"><img src="images/000860.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">it’s important to watch out for <em class="calibre7">X</em><sub class="calibre12">real</sub>(<em class="calibre7">m</em>) values that are equal to zero. That would invalidate our phase-angle calculations in <a href="#calibre_link-469">Eq. (4-10)</a> due to division by a zero condition. In practice, we want to make sure that our calculations (or software compiler) detect occurrences of <em class="calibre7">X</em><sub class="calibre12">real</sub>(<em class="calibre7">m</em>) = 0 and set the corresponding <em class="calibre7">X</em><sub class="calibre12">ø</sub>(<em class="calibre7">m</em>) to 90° if <em class="calibre7">X</em><sub class="calibre12">imag</sub>(<em class="calibre7">m</em>) is positive, set <em class="calibre7">X</em><sub class="calibre12">ø</sub>(<em class="calibre7">m</em>) to 0° if <em class="calibre7">X</em><sub class="calibre12">imag</sub>(<em class="calibre7">m</em>) is zero, and set <em class="calibre7">X</em><sub class="calibre12">ø</sub>(<em class="calibre7">m</em>) to −90° if <em class="calibre7">X</em><sub class="calibre12">imag</sub>(<em class="calibre7">m</em>) is negative. While we’re on the subject of FFT output phase angles, be aware that FFT outputs containing significant noise components can cause large fluctuations in the computed <em class="calibre7">X</em><sub class="calibre12">ø</sub>(<em class="calibre7">m</em>) phase angles. This means that the <em class="calibre7">X</em><sub class="calibre12">ø</sub>(<em class="calibre7">m</em>) samples are only meaningful when the corresponding |<em class="calibre7">X</em>(<em class="calibre7">m</em>)| is well above the average FFT output noise level.</p>
<p class="calibre3"><a id="calibre_link-601"></a></p>
<h3 class="calibre6">4.3 Derivation of the Radix-2 FFT Algorithm</h3>
<p class="calibre3">This section and those that follow provide a detailed description of the internal data structures and operations of the radix-2 FFT for those readers interested in developing software FFT routines or designing FFT hardware. To see just exactly how the FFT evolved from the DFT, we return to the equation for an <em class="calibre7">N</em>-point DFT,</p>
<p class="caption"><a id="calibre_link-470"></a>(4-11)</p>
<p class="image"><img src="images/001718.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2634"></a>A straightforward derivation of the FFT proceeds with the separation of the input data sequence <em class="calibre7">x</em>(<em class="calibre7">n</em>) into two parts. When <em class="calibre7">x</em>(<em class="calibre7">n</em>) is segmented into its even and odd indexed elements, we can, then, break <a href="#calibre_link-470">Eq. (4-11)</a> into two parts as</p>
<p class="caption"><a id="calibre_link-2635"></a>(4-12)</p>
<p class="image"><img src="images/000050.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Pulling the constant phase angle outside the second summation,</p>
<p class="caption"><a id="calibre_link-471"></a>(4-13)</p>
<p class="image"><img src="images/000937.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Well, here the equations become so long and drawn out that we’ll use a popular notation to simplify things. We’ll define</p>
<p class="caption"><a id="calibre_link-2636"></a>(4-13′)</p>
<p class="image"><img src="images/001303.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">to represent the complex phase-angle factor that is constant with <em class="calibre7">N</em>. So, <a href="#calibre_link-471">Eq. (4-13)</a> becomes</p>
<p class="caption"><a id="calibre_link-472"></a>(4-14)</p>
<p class="image"><img src="images/000122.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Because <img src="images/000161.jpg" alt="image" class="calibre2" />, we can substitute <em class="calibre7">W<sub class="calibre12">N</sub></em><sub class="calibre12">/2</sub> for <img src="images/000432.jpg" alt="image" class="calibre2" /> in <a href="#calibre_link-472">Eq. (4-14)</a>, as</p>
<p class="caption"><a id="calibre_link-473"></a>(4-15)</p>
<p class="image"><img src="images/001113.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where <em class="calibre7">m</em> is in the range 0 to <em class="calibre7">N</em>/2−1. Index <em class="calibre7">m</em> has that reduced range because each of the two <em class="calibre7">N</em>/2-point DFTs on the right side of <a href="#calibre_link-473">Eq. (4-15)</a> are periodic in <em class="calibre7">m</em> with period <em class="calibre7">N</em>/2.</p>
<p class="calibre3">So we now have two <em class="calibre7">N</em>/2 summations whose results can be combined to give us the first <em class="calibre7">N</em>/2 samples of an <em class="calibre7">N</em>-point DFT. We’ve reduced some of the necessary number crunching in <a href="#calibre_link-473">Eq. (4-15)</a> relative to <a href="#calibre_link-470">Eq. (4-11)</a> because the <em class="calibre7">W</em> terms in the two summations of <a href="#calibre_link-473">Eq. (4-15)</a> are identical. There’s a further benefit in breaking the <em class="calibre7">N</em>-point DFT into two parts because the upper half of the DFT outputs is easy to calculate. Consider the <em class="calibre7">X</em>(<em class="calibre7">m</em>+<em class="calibre7">N</em>/2) output. If we plug <em class="calibre7">m</em>+<em class="calibre7">N</em>/2 in for <em class="calibre7">m</em> in <a href="#calibre_link-473">Eq. (4-15)</a>, then</p>
<p class="caption"><a id="calibre_link-2197"></a><a id="calibre_link-474"></a>(4-16)</p>
<p class="image"><img src="images/000725.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">It looks like we’re complicating things, right? Well, just hang in there for a moment. We can now simplify the phase-angle terms inside the summations because</p>
<p class="caption"><a id="calibre_link-475"></a>(4-17)</p>
<p class="image"><img src="images/001074.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">for any integer <em class="calibre7">n</em>. Looking at the so-called <em class="calibre7">twiddle factor</em> in front of the second summation in <a href="#calibre_link-474">Eq. (4-16)</a>, we can simplify it as</p>
<p class="caption"><a id="calibre_link-476"></a>(4-18)</p>
<p class="image"><img src="images/000052.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">OK, using <a href="#calibre_link-475">Eqs. (4-17)</a> and <a href="#calibre_link-476">(4-18)</a>, we represent <a href="#calibre_link-474">Eq. (4-16)</a>’s <em class="calibre7">X</em>(<em class="calibre7">m</em>+<em class="calibre7">N</em>/2) as</p>
<p class="caption"><a id="calibre_link-477"></a>(4-19)</p>
<p class="image"><img src="images/001436.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Now, let’s repeat <a href="#calibre_link-473">Eqs. (4-15)</a> and <a href="#calibre_link-477">(4-19)</a> to see the similarity:</p>
<p class="caption"><a id="calibre_link-478"></a>(4-20)</p>
<p class="image"><img src="images/000254.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">and</p>
<p class="caption"><a id="calibre_link-479"></a>(4-20′)</p>
<p class="image"><img src="images/000885.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">So here we are. We need not perform any sine or cosine multiplications to get <em class="calibre7">X</em>(<em class="calibre7">m</em>+<em class="calibre7">N</em>/2). We just change the sign of the twiddle factor <img src="images/001526.jpg" alt="image" class="calibre2" /> and use the results of the two summations from <em class="calibre7">X</em>(<em class="calibre7">m</em>) to get <em class="calibre7">X</em>(<em class="calibre7">m</em>+<em class="calibre7">N</em>/2). Of course, <em class="calibre7">m</em> goes from 0 to (<em class="calibre7">N</em>/2)−1 in <a href="#calibre_link-478">Eq. (4-20)</a>, which means to compute an <em class="calibre7">N</em>-point DFT, we actually perform two <em class="calibre7">N</em>/2-point DFTs&mdash;one <em class="calibre7">N</em>/2-point DFT on the even-indexed <em class="calibre7">x</em>(<em class="calibre7">n</em>) samples and one <em class="calibre7">N</em>/2-point DFT on the odd-indexed <em class="calibre7">x</em>(<em class="calibre7">n</em>) samples. For <em class="calibre7">N</em> = 8, <a href="#calibre_link-478">Eqs. (4-20)</a> and <a href="#calibre_link-479">(4-20′)</a> are implemented as shown in <a href="#calibre_link-480">Figure 4-2</a>.</p>
<p class="caption"><a id="calibre_link-480"></a><strong class="calibre9">Figure 4-2</strong> FFT implementation of an 8-point DFT using two 4-point DFTs.</p>
<p class="image"><img src="images/000319.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2637"></a>Because −<em class="calibre7">e</em><sup class="calibre10">−<em class="calibre7">j</em>2π<em class="calibre7">m</em>/<em class="calibre7">N</em></sup> = <em class="calibre7">e</em><sup class="calibre10">−<em class="calibre7">j</em>2π(<em class="calibre7">m</em>+N/2)/<em class="calibre7">N</em></sup>, the negative <em class="calibre7">W</em> twiddle factors before the second summation in <a href="#calibre_link-479">Eq. (4-20′)</a> are implemented with positive <em class="calibre7">W</em> twiddle factors that follow the lower DFT in <a href="#calibre_link-480">Figure 4-2</a>.</p>
<p class="calibre3">If we simplify <a href="#calibre_link-478">Eqs. (4-20)</a> and <a href="#calibre_link-479">(4-20′)</a> to the form</p>
<p class="caption"><a id="calibre_link-481"></a>(4-21)</p>
<p class="image"><img src="images/001502.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">and</p>
<p class="caption"><a id="calibre_link-482"></a>(4-21′)</p>
<p class="image"><img src="images/000666.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">we can go further and think about breaking the two 4-point DFTs into four 2-point DFTs. Let’s see how we can subdivide the upper 4-point DFT in <a href="#calibre_link-480">Figure 4-2</a> <a id="calibre_link-2037"></a>whose four outputs are <em class="calibre7">A</em>(<em class="calibre7">m</em>) in <a href="#calibre_link-481">Eqs. (4-21)</a> and <a href="#calibre_link-482">(4-21′)</a>. We segment the inputs to the upper 4-point DFT into their odd and even components:</p>
<p class="caption"><a id="calibre_link-2638"></a>(4-22)</p>
<p class="image"><img src="images/001518.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Because <img src="images/001002.jpg" alt="image" class="calibre2" />, we can express <em class="calibre7">A</em>(<em class="calibre7">m</em>) in the form of two <em class="calibre7">N</em>/4-point DFTs, as</p>
<p class="caption"><a id="calibre_link-483"></a>(4-23)</p>
<p class="image"><img src="images/001575.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Notice the similarity between <a href="#calibre_link-483">Eqs. (4-23)</a> and <a href="#calibre_link-478">(4-20)</a>. This capability to subdivide an <em class="calibre7">N</em>/2-point DFT into two <em class="calibre7">N</em>/4-point DFTs gives the FFT its capacity to greatly reduce the number of necessary multiplications to implement DFTs. (We’re going to demonstrate this shortly.) Following the same steps we used to obtained <em class="calibre7">A</em>(<em class="calibre7">m</em>), we can show that <a href="#calibre_link-481">Eq.(4-21)</a>’s <em class="calibre7">B</em>(<em class="calibre7">m</em>) is</p>
<p class="caption"><a id="calibre_link-484"></a>(4-24)</p>
<p class="image"><img src="images/001343.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">For our <em class="calibre7">N</em> = 8 example, <a href="#calibre_link-483">Eqs. (4-23)</a> and <a href="#calibre_link-484">(4-24)</a> are implemented as shown in <a href="#calibre_link-485">Figure 4-3</a>. The FFT’s well-known <em class="calibre7">butterfly</em> pattern of signal flows is certainly evident, and we see the further shuffling of the input data in <a href="#calibre_link-485">Figure 4-3</a>. The twiddle factor <img src="images/000995.jpg" alt="image" class="calibre2" /> in <a href="#calibre_link-483">Eqs. (4-23)</a> and <a href="#calibre_link-484">(4-24)</a>, for our <em class="calibre7">N</em> = 8 example, ranges from <img src="images/000898.jpg" alt="image" class="calibre2" /> to <img src="images/001752.jpg" alt="image" class="calibre2" /> because the <em class="calibre7">m</em> index, for <em class="calibre7">A</em>(<em class="calibre7">m</em>) and <em class="calibre7">B</em>(<em class="calibre7">m</em>), goes from 0 to 3. For any <em class="calibre7">N</em>-point DFT, we can break each of the <em class="calibre7">N</em>/2-point DFTs into two <em class="calibre7">N</em>/4-point DFTs to further reduce the number of sine and cosine multiplications. Eventually, we would arrive at an array of 2-point DFTs where no further computational savings could be realized. This is why the number of points in our FFTs is constrained to be some power of two and why this FFT algorithm is referred to as the radix-2 FFT.</p>
<p class="caption"><a id="calibre_link-485"></a><strong class="calibre9">Figure 4-3</strong> FFT implementation of an 8-point DFT as two 4-point DFTs and four 2-point DFTs.</p>
<p class="image"><img src="images/001162.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Moving right along, let’s go one step further, and then we’ll be finished with our <em class="calibre7">N</em> = 8-point FFT derivation. The 2-point DFT functions in <a href="#calibre_link-485">Figure 4-3</a> cannot be partitioned into smaller parts&mdash;we’ve reached the end of our DFT reduction process, arriving at the butterfly of a single 2-point DFT as shown in <a href="#calibre_link-486">Figure 4-4</a>. From the definition of <em class="calibre7">W<sub class="calibre12">N</sub></em>, <img src="images/000778.jpg" alt="image" class="calibre2" /> and <img src="images/001633.jpg" alt="image" class="calibre2" />. So the 2-point DFT blocks in <a href="#calibre_link-485">Figure 4-3</a> can be replaced by the butterfly in <a href="#calibre_link-486">Figure 4-4</a> to give us a full 8-point FFT implementation of the DFT as shown in <a href="#calibre_link-487">Figure 4-5</a>.</p>
<p class="caption"><a id="calibre_link-2639"></a><a id="calibre_link-486"></a><strong class="calibre9">Figure 4-4</strong> Single 2-point DFT butterfly.</p>
<p class="image"><img src="images/000207.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-487"></a><strong class="calibre9">Figure 4-5</strong> Full decimation-in-time FFT implementation of an 8-point DFT.</p>
<p class="image"><img src="images/001052.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2640"></a>OK, we’ve gone through a fair amount of algebraic foot shuffling here. To verify that the derivation of the FFT is valid, we can apply the 8-point data sequence of <a href="#calibre_link-134">Chapter 3</a>’s DFT Example 1 to the 8-point FFT represented by <a href="#calibre_link-487">Figure 4-5</a>. The data sequence representing <em class="calibre7">x</em>(<em class="calibre7">n</em>) = sin(2π1000<em class="calibre7">nt<sub class="calibre12">s</sub></em>) + 0.5sin(2π2000<em class="calibre7">nt<sub class="calibre12">s</sub></em>+3π/4) is</p>
<p class="caption"><a id="calibre_link-488"></a>(4-25)</p>
<p class="image"><img src="images/001368.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2641"></a>We begin grinding through this example by applying the input values from <a href="#calibre_link-488">Eq. (4-25)</a> to <a href="#calibre_link-487">Figure 4-5</a>, giving the data values shown on left side of <a href="#calibre_link-489">Figure 4-6</a>. The outputs of the second stage of the FFT are</p>
<p class="caption"><a id="calibre_link-489"></a><strong class="calibre9">Figure 4-6</strong> Eight-point FFT of Example 1 from <a href="#calibre_link-457">Section 3.1</a>.</p>
<p class="image"><img src="images/000652.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2026"></a>Calculating the outputs of the third stage of the FFT to arrive at our final answer:</p>
<p class="image"><img src="images/000660.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">So, happily, the FFT gives us the correct results, and again we remind the reader that the FFT is not an approximation to a DFT; it is the DFT with a reduced number of necessary arithmetic operations. You’ve seen from the above example that the 8-point FFT example required less effort than the 8-point DFT Example 1 in <a href="#calibre_link-457">Section 3.1</a>. Some authors like to explain this arithmetic reduction by the redundancies inherent in the twiddle factors <img src="images/001526.jpg" alt="image" class="calibre2" />. They illustrate this with the <em class="calibre7">starburst</em> pattern in <a href="#calibre_link-490">Figure 4-7</a> showing the equivalencies of some of the twiddle factors in an 8-point DFT.</p>
<p class="caption"><a id="calibre_link-490"></a><strong class="calibre9">Figure 4-7</strong> Cyclic redundancies in the twiddle factors of an 8-point FFT.</p>
<p class="image"><img src="images/001509.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-602"></a></p>
<h3 class="calibre6">4.4 FFT Input/Output Data Index Bit Reversal</h3>
<p class="calibre3">OK, let’s look into some of the special properties of the FFT that are important to FFT software developers and FFT hardware designers. Notice that <a href="#calibre_link-487">Figure 4-5</a> was titled “Full decimation-in-time FFT implementation of an 8-point DFT.” The <em class="calibre7">decimation-in-time</em> phrase refers to how we broke the DFT input samples into odd and even parts in the derivation of <a href="#calibre_link-478">Eqs. (4-20)</a>, <a href="#calibre_link-483">(4-23)</a>, and <a href="#calibre_link-484">(4-24)</a>. This time decimation leads to the scrambled order of the input data’s index <em class="calibre7">n</em> in <a href="#calibre_link-487">Figure 4-5</a>. The pattern of this shuffled order can be understood <a id="calibre_link-2642"></a>with the help of <a href="#calibre_link-491">Table 4-1</a>. The shuffling of the input data is known as <em class="calibre7">bit reversal</em> because the scrambled order of the input data index can be obtained by reversing the bits of the binary representation of the normal input data index order. Sounds confusing, but it’s really not&mdash;<a href="#calibre_link-491">Table 4-1</a> illustrates the input index bit reversal for our 8-point FFT example. Notice the normal index order in the left column of <a href="#calibre_link-491">Table 4-1</a> and the scrambled order in the right column that corresponds to the final decimated input index order in <a href="#calibre_link-487">Figure 4-5</a>. We’ve transposed the original binary bits representing the normal index order by reversing their positions. The most significant bit becomes the least <a id="calibre_link-2039"></a>significant bit and the least significant bit becomes the most significant bit, the next to the most significant bit becomes the next to the least significant bit, and the next to the least significant bit becomes the next to the most significant bit, and so on.<sup class="calibre10"><a id="calibre_link-493"></a><a href="#calibre_link-492">†</a></sup></p>
<p class="footnotes"><a id="calibre_link-492"></a><sup class="calibre11"><a href="#calibre_link-493">†</a></sup> Many that are first shall be last; and the last first. [Mark 10:31]</p>
<p class="caption"><a id="calibre_link-491"></a><strong class="calibre9">Table 4-1</strong> Input Index Bit Reversal for an 8-Point FFT</p>
<p class="image"><img src="images/000023.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-603"></a></p>
<h3 class="calibre6">4.5 Radix-2 FFT Butterfly Structures</h3>
<p class="calibre3">Let’s explore the butterfly signal flows of the decimation-in-time FFT a bit further. To simplify the signal flows, let’s replace the twiddle factors in <a href="#calibre_link-487">Figure 4-5</a> with their equivalent values referenced to <img src="images/001526.jpg" alt="image" class="calibre2" />, where <em class="calibre7">N</em> = 8. We can show just the exponents <em class="calibre7">m</em> of <img src="images/001526.jpg" alt="image" class="calibre2" />, to get the FFT structure shown in <a href="#calibre_link-494">Figure 4-8</a>. That is, <img src="images/001496.jpg" alt="image" class="calibre2" /> from <a href="#calibre_link-487">Figure 4-5</a> is equal to <img src="images/001654.jpg" alt="image" class="calibre2" /> and is shown as a 2 in <a href="#calibre_link-494">Figure 4-8</a>, <img src="images/000534.jpg" alt="image" class="calibre2" /> from <a href="#calibre_link-487">Figure 4-5</a> is equal to <img src="images/001283.jpg" alt="image" class="calibre2" /> and is shown as a 4 in <a href="#calibre_link-494">Figure 4-8</a>, etc. The 1s and −1s in the first stage of <a href="#calibre_link-487">Figure 4-5</a> are replaced in <a href="#calibre_link-494">Figure 4-8</a> by 0s and 4s, respectively. Other than the twiddle factor notation, <a href="#calibre_link-494">Figure 4-8</a> is identical to <a href="#calibre_link-487">Figure 4-5</a>. We can shift around the signal nodes in <a href="#calibre_link-487">Figure 4-5</a> and arrive at an 8-point decimation-in-time FFT as shown in <a href="#calibre_link-495">Figure 4-9</a>. Notice that the input data in <a href="#calibre_link-495">Figure 4-9</a> is in its normal order and the output data indices are bit-reversed. In this case, a bit-reversal operation needs to be performed at the output of the FFT to unscramble the frequency-domain results.</p>
<p class="caption"><a id="calibre_link-494"></a><strong class="calibre9">Figure 4-8</strong> Eight-point decimation-in-time FFT with bit-reversed inputs.</p>
<p class="image"><img src="images/000544.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-495"></a><strong class="calibre9">Figure 4-9</strong> Eight-point decimation-in-time FFT with bit-reversed outputs.</p>
<p class="image"><img src="images/001400.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a href="#calibre_link-496">Figure 4-10</a> shows an FFT signal-flow structure that avoids the bit-reversal problem altogether, and the graceful weave of the traditional FFT butterflies is replaced with a tangled, but effective, configuration.</p>
<p class="caption"><a id="calibre_link-496"></a><strong class="calibre9">Figure 4-10</strong> Eight-point decimation-in-time FFT with inputs and outputs in normal order.</p>
<p class="image"><img src="images/000442.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Not too long ago, hardware implementations of the FFT spent most of their time (clock cycles) performing multiplications, and the bit-reversal process necessary to access data in memory wasn’t a significant portion of the overall FFT computational problem. Now that high-speed multiplier/accumulator integrated circuits can multiply two numbers in a single clock cycle, FFT data multiplexing and memory addressing have become much more important. This has led to the development of efficient algorithms to perform bit reversal[<a href="#calibre_link-497">7</a>&ndash;<a href="#calibre_link-498">10</a>].</p>
<p class="calibre3">There’s another derivation for the FFT that leads to butterfly structures looking like those we’ve already covered, but the twiddle factors in the butterflies are different. This alternate FFT technique is known as the decimation-in-frequency algorithm. Where the decimation-in-time FFT algorithm is based on subdividing the input data into its odd and even components, the decimation-in-frequency FFT algorithm is founded upon calculating the odd and even output frequency samples separately. The derivation of the decimation-in-frequency algorithm is straightforward and included in many tutorial papers and textbooks, so we won’t go through the derivation here[<a href="#calibre_link-499">4</a>,<a href="#calibre_link-500">5</a>,<a href="#calibre_link-501">15</a>,<a href="#calibre_link-502">16</a>]. We <a id="calibre_link-2643"></a>will, however, illustrate decimation-in-frequency butterfly structures (analogous to the structures in <a href="#calibre_link-494">Figures 4-8</a> through <a href="#calibre_link-496">4-10</a>) in <a href="#calibre_link-503">Figures 4-11</a> though <a href="#calibre_link-504">4-13</a>.</p>
<p class="caption"><a id="calibre_link-503"></a><strong class="calibre9">Figure 4-11</strong> Eight-point decimation-in-frequency FFT with bit-reversed inputs.</p>
<p class="image"><img src="images/001292.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-505"></a><strong class="calibre9">Figure 4-12</strong> Eight-point decimation-in-frequency FFT with bit-reversed outputs.</p>
<p class="image"><img src="images/000331.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-504"></a><strong class="calibre9">Figure 4-13</strong> Eight-point decimation-in-frequency FFT with inputs and outputs in normal order.</p>
<p class="image"><img src="images/001174.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">So an equivalent decimation-in-frequency FFT structure exists for each decimation-in-time FFT structure. It’s important to note that the number of necessary multiplications to implement the decimation-in-frequency FFT algorithms is the same as the number necessary for the decimation-in-time FFT algorithms. There are so many different FFT butterfly structures described in the literature that it’s easy to become confused about which structures are <a id="calibre_link-2644"></a>decimation-in-time and which are decimation-in-frequency. Depending on how the material is presented, it’s easy for a beginner to fall into the trap of believing that decimation-in-time FFTs always have their inputs bit-reversed and decimation-in-frequency FFTs always have their outputs bit-reversed. This is not true, as the above figures show. Decimation-in-time or -frequency is determined by whether the DFT inputs or outputs are partitioned when deriving a particular FFT butterfly structure from the DFT equations.</p>
<p class="calibre3"><a id="calibre_link-604"></a></p>
<h3 class="calibre6"><a id="calibre_link-2040" class="calibre5"></a>4.6 Alternate Single-Butterfly Structures</h3>
<p class="calibre3">Let’s take one more look at a single butterfly. The FFT butterfly structures in <a href="#calibre_link-494">Figures 4-8</a>, <a href="#calibre_link-495">4-9</a>, <a href="#calibre_link-503">4-11</a>, and <a href="#calibre_link-505">4-12</a> are the direct result of the derivations of the decimation-in-time and decimation-in-frequency algorithms. Although it’s not very obvious at first, the twiddle factor exponents shown in these structures do have a consistent pattern. Notice how they always take the general <a id="calibre_link-2645"></a>forms shown in <a href="#calibre_link-43">Figure 4-14(a)</a>.<sup class="calibre10"><a id="calibre_link-507"></a><a href="#calibre_link-506">†</a></sup> To implement the decimation-in-time butterfly of <a href="#calibre_link-43">Figure 4-14(a)</a>, we’d have to perform two complex multiplications and two complex additions. Well, there’s a better way. Consider the decimation-in-time butterfly in <a href="#calibre_link-43">Figure 4-14(a)</a>. If the top input is <em class="calibre7">x</em> and the bottom input is <em class="calibre7">y</em>, the top butterfly output would be</p>
<p class="footnotes"><a id="calibre_link-506"></a><sup class="calibre11"><a href="#calibre_link-507">†</a></sup> Remember, for simplicity the butterfly structures in <a href="#calibre_link-494">Figures 4-8</a> through <a href="#calibre_link-504">4-13</a> show only the twiddle factor exponents, <em class="calibre7">k</em> and <em class="calibre7">k</em>+<em class="calibre7">N</em>/2, and not the entire complex twiddle factors.</p>
<p class="caption"><a id="calibre_link-43"></a><strong class="calibre9">Figure 4-14</strong> Decimation-in-time and decimation-in-frequency butterfly structures: (a) original form; (b) simplified form; (c) optimized form.</p>
<p class="image"><img src="images/000215.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-45"></a>(4-26)</p>
<p class="image"><img src="images/001652.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">and the bottom butterfly output would be</p>
<p class="caption"><a id="calibre_link-508"></a>(4-27)</p>
<p class="image"><img src="images/000461.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2038"></a>Fortunately, the operations in <a href="#calibre_link-45">Eqs. (4-26)</a> and <a href="#calibre_link-508">(4-27)</a> can be simplified because the two twiddle factors are related by</p>
<p class="caption"><a id="calibre_link-2646"></a>(4-28)</p>
<p class="image"><img src="images/001083.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">So we can replace the <img src="images/001514.jpg" alt="image" class="calibre2" /> twiddle factors in <a href="#calibre_link-43">Figure 4-14(a)</a> with <img src="images/001333.jpg" alt="image" class="calibre2" /> to give us the simplified butterflies shown in <a href="#calibre_link-43">Figure 4-14(b)</a>. Because the twiddle factors in <a href="#calibre_link-43">Figure 4-14(b)</a> differ only by their signs, the optimized butterflies in <a href="#calibre_link-43">Figure 4-14(c)</a> can be used. Notice that these <em class="calibre7">optimized</em> butterflies require two complex additions but only one complex multiplication, thus reducing our computational workload.<sup class="calibre10"><a id="calibre_link-510"></a><a href="#calibre_link-509">†</a></sup></p>
<p class="footnotes"><a id="calibre_link-509"></a><sup class="calibre11"><a href="#calibre_link-510">†</a></sup> It’s because there are (<em class="calibre7">N</em>/2)log<sub class="calibre14">2</sub><em class="calibre7">N</em> butterflies in an <em class="calibre7">N</em>-point FFT that we said the number of complex multiplications performed by an FFT is (<em class="calibre7">N</em>/2)log<sub class="calibre14">2</sub><em class="calibre7">N</em> in <a href="#calibre_link-511">Eq. (4-2)</a>.</p>
<p class="calibre3">We’ll often see the optimized butterfly structures of <a href="#calibre_link-43">Figure 4-14(c)</a> in the literature instead of those in <a href="#calibre_link-43">Figure 4-14(a)</a>. These optimized butterflies give us an easy way to recognize decimation-in-time and decimation-in-frequency algorithms. <em class="calibre7">W</em>hen we do come across the optimized butterflies from <a href="#calibre_link-43">Figure 4-14(c)</a>, we’ll know that the algorithm is decimation-in-time if the twiddle factor precedes the −1, or else the algorithm is decimation-in-frequency if the twiddle factor follows the −1.</p>
<p class="calibre3">Sometimes we’ll encounter FFT structures in the literature that use the notation shown in <a href="#calibre_link-512">Figure 4-15</a>[<a href="#calibre_link-500">5</a>, <a href="#calibre_link-513">12</a>]. These wingless butterflies are equivalent to those shown in <a href="#calibre_link-43">Figure 4-14(c)</a>. The signal-flow convention in <a href="#calibre_link-512">Figure 4-15</a> is such that the plus output of a circle is the sum of the two samples that enter the circle from the left, and the minus output of a circle is the difference of the samples that enter the circle. So the outputs of the decimation-in-time butterflies in <a href="#calibre_link-43">Figures 4-14(c)</a> and <a href="#calibre_link-512">4-15(a)</a> are given by</p>
<p class="caption"><a id="calibre_link-2647"></a>(4-29)</p>
<p class="image"><img src="images/001727.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-512"></a><strong class="calibre9">Figure 4-15</strong> Alternate FFT butterfly notation: (a) decimation in time; (b) decimation in frequency.</p>
<p class="image"><img src="images/001061.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2189"></a>The outputs of the decimation-in-frequency butterflies in <a href="#calibre_link-43">Figures 4-14(c)</a> and <a href="#calibre_link-512">4-15(b)</a> are</p>
<p class="caption"><a id="calibre_link-2648"></a>(4-30)</p>
<p class="image"><img src="images/000525.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">So which FFT structure is the best one to use? It depends on the application, the hardware implementation, and convenience. If we’re using a software routine to perform FFTs on a general-purpose computer, we usually don’t have a lot of choices. Most folks just use whatever existing FFT routines happen to be included in their commercial software package. Their code may be optimized for speed, but you never know. Examination of the software code may be necessary to see just how the FFT is implemented. If we <em class="calibre7">feel the need for speed</em>, we should check to see if the software calculates the sines and cosines each time it needs a twiddle factor. Trigonometric calculations normally take many machine cycles. It may be possible to speed up the algorithm by calculating the twiddle factors ahead of time and storing them in a table. That way, they can be <em class="calibre7">looked up,</em> instead of being calculated each time they’re needed in a butterfly. If we’re writing our own software routine, checking for butterfly output data overflow and careful magnitude scaling may allow our FFT to be performed using integer arithmetic that can be faster on some machines.<sup class="calibre10"><a id="calibre_link-515"></a><a href="#calibre_link-514">†</a></sup> Care must be taken, however, when using integer arithmetic; some Reduced Instruction Set Computer (RISC) processors actually take longer to perform integer calculations because they’re specifically designed to operate on floating-point numbers.</p>
<p class="footnotes"><a id="calibre_link-514"></a><sup class="calibre11"><a href="#calibre_link-515">†</a></sup> Overflow is what happens when the result of an arithmetic operation has too many bits, or digits, to be represented in the hardware registers designed to contain that result. FFT data overflow is described in <a href="#calibre_link-516">Section 12.3</a>.</p>
<p class="calibre3">If we’re using commercial array processor hardware for our calculations, the code in these processors is <em class="calibre7">always</em> optimized because their purpose in life is high speed. Array processor manufacturers typically publicize their products by specifying the speed at which their machines perform a 1024-point FFT. Let’s look at some of our options in selecting a particular FFT structure in case we’re designing special-purpose hardware to implement an FFT.</p>
<p class="calibre3">The FFT butterfly structures previously discussed typically fall into one of two categories: in-place FFT algorithms and double-memory FFT algorithms. An in-place algorithm is depicted in <a href="#calibre_link-487">Figure 4-5</a>. The output of a butterfly operation can be stored in the same hardware memory locations that previously held the butterfly’s input data. No intermediate storage is necessary. This way, for an <em class="calibre7">N</em>-point FFT, only 2<em class="calibre7">N</em> memory locations are needed. (The 2 comes from the fact that each butterfly node represents a data value that has both a real and an imaginary part.) The rub with the in-place <a id="calibre_link-2025"></a>algorithms is that data routing and memory addressing are rather complicated. A double-memory FFT structure is that depicted in <a href="#calibre_link-496">Figure 4-10</a>. With this structure, intermediate storage is necessary because we no longer have the standard butterflies, and 4<em class="calibre7">N</em> memory locations are needed. However, data routing and memory address control are much simpler in double-memory FFT structures than the in-place technique. The use of high-speed, floating-point integrated circuits to implement pipelined FFT architectures takes better advantage of their pipelined structure when the double-memory algorithm is used<a href="#calibre_link-517">[13]</a>.</p>
<p class="calibre3">There’s another class of FFT structures, known as constant-geometry algorithms, that make the addressing of memory both simple and constant for each stage of the FFT. These structures are of interest to those folks who build special-purpose FFT hardware devices[<a href="#calibre_link-499">4</a>,<a href="#calibre_link-518">14</a>]. From the standpoint of general hardware the decimation-in-time algorithms are optimum for real input data sequences, and decimation-in-frequency is appropriate when the input is complex<a href="#calibre_link-519">[6]</a>. When the FFT input data is symmetrical in time, special FFT structures exist to eliminate unnecessary calculations. These special butterfly structures based on input data symmetry are described in the literature<a href="#calibre_link-501">[15]</a>.</p>
<p class="calibre3">For two-dimensional FFT applications, such as processing photographic images, the decimation-in-frequency algorithms appear to be the optimum choice<a href="#calibre_link-502">[16]</a>. Your application may be such that FFT input and output bit reversal is not an important factor. Some FFT applications allow manipulating a bit-reversed FFT output sequence in the frequency domain without having to unscramble the FFT’s output data. Then an inverse transform that’s expecting bit-reversed inputs will give a time-domain output whose data sequence is correct. This situation avoids the need to perform any bit reversals at all. Multiplying two FFT outputs to implement convolution or correlation are examples of this possibility.<sup class="calibre10"><a id="calibre_link-523"></a><a href="#calibre_link-520">†</a></sup> As we can see, finding the optimum FFT algorithm and hardware architecture for an FFT is a fairly complex problem to solve, but the literature provides guidance[<a href="#calibre_link-499">4</a>,<a href="#calibre_link-521">17</a>,<a href="#calibre_link-522">18</a>].</p>
<p class="footnotes"><a id="calibre_link-520"></a><sup class="calibre11"><a href="#calibre_link-523">†</a></sup> See <a href="#calibre_link-524">Section 13.10</a> for an example of using the FFT to perform convolution.</p>
<p class="calibre3"><a id="calibre_link-605"></a></p>
<h3 class="calibre6">References</h3>
<p class="chapterendnote"><a id="calibre_link-453"></a>[1] Cooley, J., and Tukey, J. “An Algorithm for the Machine Calculation of Complex Fourier Series,” <em class="calibre7">Math. Comput</em>., Vol. 19, No. 90, April 1965, pp. 297&ndash;301.</p>
<p class="chapterendnote"><a id="calibre_link-456"></a>[2] Cooley, J., Lewis, P., and Welch, P. “Historical Notes on the Fast Fourier Transform,” <em class="calibre7">IEEE Trans. on Audio and Electroacoustics,</em> Vol. AU-15, No. 2, June 1967.</p>
<p class="chapterendnote"><a id="calibre_link-2649"></a><a id="calibre_link-466"></a>[3] Harris, F. J. “On the Use of Windows for Harmonic Analysis with the Discrete Fourier Transform,” <em class="calibre7">Proceedings of the IEEE,</em> Vol. 66, No. 1, January 1978, p. 54.</p>
<p class="chapterendnote"><a id="calibre_link-499"></a>[4] Oppenheim, A. V., and Schafer, R. W. <em class="calibre7">Discrete-Time Signal Processing</em>, Prentice Hall, Englewood Cliffs, New Jersey, 1989, p. 608.</p>
<p class="chapterendnote"><a id="calibre_link-500"></a>[5] Rabiner, L. R., and Gold, B. <em class="calibre7">Theory and Application of Digital Signal Processing</em>, Prentice Hall, Englewood Cliffs, New Jersey, 1975, p. 367.</p>
<p class="chapterendnote"><a id="calibre_link-519"></a>[6] Sorenson, H. V., Jones, D. L., Heideman, M. T., and Burrus, C. S. “Real-Valued Fast Fourier Transform Algorithms,” <em class="calibre7">IEEE Trans. on Acoust. Speech, and Signal Proc.,</em> Vol. ASSP-35, No. 6, June 1987.</p>
<p class="chapterendnote"><a id="calibre_link-497"></a>[7] Evans, D. “An Improved Digit-Reversal Permutation Algorithm for the Fast Fourier and Hartley Transforms,” <em class="calibre7">IEEE Trans. on Acoust. Speech, and Signal Proc.,</em> Vol. ASSP-35, No. 8, August 1987.</p>
<p class="chapterendnote"><a id="calibre_link-2650"></a>[8] Burrus, C. S. “Unscrambling for Fast DFT Algorithms,” <em class="calibre7">IEEE Trans. on Acoust. Speech, and Signal Proc.,</em> Vol. 36, No. 7, July 1988.</p>
<p class="chapterendnote"><a id="calibre_link-2651"></a>[9] Rodriguez, J. J. “An Improved FFT Digit-Reversal Algorithm,” <em class="calibre7">IEEE Trans. on Acoust. Speech, and Signal Proc.,</em> Vol. ASSP-37, No. 8, August 1989.</p>
<p class="chapterendnote"><a id="calibre_link-498"></a>[10] Land, A. “Bit Reverser Scrambles Data for FFT,” <em class="calibre7">EDN,</em> March 2, 1995.</p>
<p class="chapterendnote"><a id="calibre_link-2652"></a>[11] JG-AE Subcommittee on Measurement Concepts, “What Is the Fast Fourier Transform?,” <em class="calibre7">IEEE Trans. on Audio and Electroacoustics,</em> Vol. AU-15, No. 2, June 1967.</p>
<p class="chapterendnote"><a id="calibre_link-513"></a>[12] Cohen, R., and Perlman, R. “500 kHz Single Board FFT System Incorporates DSP Optimized Chips,” <em class="calibre7">EDN</em>, October 31, 1984.</p>
<p class="chapterendnote"><a id="calibre_link-517"></a>[13] Eldon, J., and Winter, G. E. “Floating-Point Chips Carve Out FFT Systems,” <em class="calibre7">Electronic Design</em>, August 4, 1983.</p>
<p class="chapterendnote"><a id="calibre_link-518"></a>[14] Lamb, K. “CMOS Building Blocks Shrink and Speed Up FFT Systems,” <em class="calibre7">Electronic Design</em>, August 6, 1987.</p>
<p class="chapterendnote"><a id="calibre_link-501"></a>[15] Markel, J. D. “FFT Pruning,” <em class="calibre7">IEEE Trans. on Audio and Electroacoustics,</em> Vol. AU-19, No. 4, December 1971.</p>
<p class="chapterendnote"><a id="calibre_link-502"></a>[16] Wu, H. R., and Paoloni, F. J. “The Structure of Vector Radix Fast Fourier Transforms,” <em class="calibre7">IEEE Trans. on Acoust. Speech, and Signal Proc.,</em> Vol. ASSP-37, No. 8, August 1989.</p>
<p class="chapterendnote"><a id="calibre_link-521"></a>[17] Ali, Z. M. “High Speed FFT Processor,” <em class="calibre7">IEEE Trans. on Communications,</em> Vol. COM-26, No. 5, May 1978.</p>
<p class="chapterendnote"><a id="calibre_link-522"></a>[18] Bergland, G. “Fast Fourier Transform Hardware Implementations&mdash;An Overview,” <em class="calibre7">IEEE Trans. on Audio and Electroacoustics,</em> Vol. AU-17, June 1969.</p>
<p class="calibre3"><a id="calibre_link-606"></a></p>
<h3 class="calibre6"><a id="calibre_link-2653" class="calibre5"></a>Chapter 4 Problems</h3>
<p class="indenthanging"><strong class="calibre9">4.1</strong> Thinking about the FFT:</p>
<p class="indenthangingn"><strong class="calibre9">(a)</strong> How do the results differ between performing an <em class="calibre7">N</em>-point FFT and performing an <em class="calibre7">N</em>-point discrete Fourier transform (DFT) on the same set of time samples?</p>
<p class="indenthangingn"><strong class="calibre9">(b)</strong> What is the restriction on the number of time samples, <em class="calibre7">N</em>, in performing an <em class="calibre7">N</em>-point radix-2 FFT?</p>
<p class="indenthanging"><strong class="calibre9">4.2</strong> Assume we want to compute an <em class="calibre7">N</em>-point FFT of an <em class="calibre7">x</em>(<em class="calibre7">n</em>) audio signal from a compact disc (CD), with the FFT’s output frequency-domain sample spacing no greater than 1 Hz. If <em class="calibre7">x</em>(<em class="calibre7">n</em>)’s sample rate is <em class="calibre7">f<sub class="calibre12">s</sub></em> = 44.1 kHz, what is the number of necessary time samples, <em class="calibre7">N</em>, applied to the FFT?</p>
<p class="indenthanging"><strong class="calibre9">4.3</strong> Assume we have an <em class="calibre7">x</em>(<em class="calibre7">n</em>) time-domain sequence, whose length is 3800 samples, on which we want to perform an FFT. The 3800 time samples represent a total signal collection-interval duration of 2 seconds.</p>
<p class="indenthangingn"><strong class="calibre9">(a)</strong> How many zero-valued samples must be appended (<em class="calibre7">zero padding</em>) to <em class="calibre7">x</em>(<em class="calibre7">n</em>) in order to implement an FFT?</p>
<p class="indenthangingn"><strong class="calibre9">(b)</strong> After the FFT is performed, what is the spacing, measured in Hz, between the frequency-domain FFT samples?</p>
<p class="indenthangingn"><strong class="calibre9">(c)</strong> In the case of lowpass sampling, what is the highest-frequency spectral component permitted in the original analog <em class="calibre7">x</em>(<em class="calibre7">t</em>) signal such that no aliasing errors occur in <em class="calibre7">x</em>(<em class="calibre7">n</em>)?</p>
<p class="indenthanging"><strong class="calibre9">4.4</strong> This problem illustrates the computational savings afforded by the FFT over that of the discrete Fourier transform (DFT). Suppose we wanted to perform a spectrum analysis on a time-domain sequence whose length is 32768 (2<sup class="calibre10">15</sup>) samples. Estimate the ratio of the number of complex multiplications needed by a 32768-point DFT over the number of complex multiplies needed by a 32768-point FFT. (Assume that one of the text’s <em class="calibre7">optimized</em> <a href="#calibre_link-43">Figure 4-14(c)</a> butterflies, requiring one complex multiply per butterfly operation, is used to implement the FFT.)</p>
<p class="indenthanging"><strong class="calibre9">4.5</strong> Think about the system in <a href="#calibre_link-525">Figure P4-5</a> using an FFT to measure the amplitude of the <em class="calibre7">p</em>(<em class="calibre7">t</em>) signal. The output of the mixer, the product <em class="calibre7">p</em>(<em class="calibre7">t</em>)<em class="calibre7">q</em>(<em class="calibre7">t</em>), contains the sum of two sinusoids whose amplitudes are proportional to the peak value of <em class="calibre7">p</em>(<em class="calibre7">t</em>). The frequencies of those sinusoids are 50 Hz and 2050 Hz. The lowpass filter rejects the 2050 Hz signal. Due to imperfections in the mixer, signal <em class="calibre7">p</em>(<em class="calibre7">t</em>)<em class="calibre7">q</em>(<em class="calibre7">t</em>) is riding on a constant DC (zero Hz) bias represented as value <em class="calibre7">D</em>. This scenario results in an <em class="calibre7">x</em>(<em class="calibre7">n</em>) time sequence whose average value is 17.</p>
<p class="indenthangingn"><a id="calibre_link-2654"></a><strong class="calibre9">(a)</strong> What is the minimum value for the analog-to-digital converter’s <em class="calibre7">f<sub class="calibre12">s</sub></em> sample rate to satisfy the Nyquist criterion?</p>
<p class="indenthangingn"><strong class="calibre9">(b)</strong> If we collect 2048 filter output samples and perform a 2048-point FFT, what will be the magnitude of the FFT’s <em class="calibre7">X</em>(0) sample?</p>
<p class="caption"><a id="calibre_link-525"></a><strong class="calibre9">Figure P4-5</strong></p>
<p class="image"><img src="images/001185.jpg" alt="image" class="calibre2" /></p>
<p class="indenthanging"><strong class="calibre9">4.6</strong> Assume you’ve purchased a high-performance commercial <em class="calibre7">real-time</em> spectrum analyzer that contains an analog-to-digital converter so that the analyzer can accept analog (continuous) <em class="calibre7">x</em>(<em class="calibre7">t</em>) input signals. The analyzer can perform a 1024-point FFT in 50 microseconds and has two banks of memory in which the analog-to-digital converter samples are stored as shown in <a href="#calibre_link-526">Figure P4-6(a)</a>. An FFT is performed on 1024 <em class="calibre7">x</em>(<em class="calibre7">n</em>) signal samples stored in Memory Bank 1 while 1024 new <em class="calibre7">x</em>(<em class="calibre7">n</em>) time samples are being loaded into Memory Bank 2.</p>
<p class="caption"><a id="calibre_link-526"></a><strong class="calibre9">Figure P4-6</strong></p>
<p class="image"><img src="images/001615.jpg" alt="image" class="calibre2" /></p>
<p class="indentpara">At the completion of the first FFT, the analyzer waits until Memory Bank 2 is filled with 1024 samples and then begins performing an FFT on the data in that second memory. During the second FFT computation still newer <em class="calibre7">x</em>(<em class="calibre7">n</em>) time samples are loaded into Memory Bank 1. Thus the analyzer can compute 1024 FFT results as often as once every 50 microseconds, and that is the <a id="calibre_link-2655"></a>meaning of the phrase “real-time spectrum analyzer.” Here’s your problem: In a <em class="calibre7">lowpass sampling</em> scenario what is the maximum one-sided bandwidth <em class="calibre7">B</em><sub class="calibre12">max</sub> of the analog <em class="calibre7">x</em>(<em class="calibre7">t</em>) input signal for which the analyzer can perform real-time FFTs without discarding (ignoring) any discrete <em class="calibre7">x</em>(<em class="calibre7">n</em>) samples? (The definition of bandwidth <em class="calibre7">B</em><sub class="calibre12">max</sub> is shown in <a href="#calibre_link-526">Figure P4-6(b)</a>.)</p>
<p class="indenthanging"><strong class="calibre9">4.7</strong> Here’s an interesting problem. Assume we performed lowpass sampling of an analog <em class="calibre7">x</em>(<em class="calibre7">t</em>) signal, at a sample rate of <em class="calibre7">f<sub class="calibre12">s</sub></em> = 20 kHz, obtaining a discrete sequence <em class="calibre7">x</em><sub class="calibre12">1</sub>(<em class="calibre7">n</em>). Next we perform an FFT on <em class="calibre7">x</em><sub class="calibre12">1</sub>(<em class="calibre7">n</em>) to obtain the |<em class="calibre7">X</em><sub class="calibre12">1</sub>(<em class="calibre7">m</em>)| FFT magnitude results presented in <a href="#calibre_link-527">Figure P4-7(a)</a>. There we see our signal of interest in the range of 0 to 4 kHz, but we detect a high-magnitude narrowband spectral noise signal centered at 5 kHz.</p>
<p class="caption"><a id="calibre_link-527"></a><strong class="calibre9">Figure P4-7</strong></p>
<p class="image"><img src="images/001327.jpg" alt="image" class="calibre2" /></p>
<p class="indentpara">Experimenting, as every good engineer should, we change the sampling rate to <em class="calibre7">f′<sub class="calibre12">s</sub></em> = 19 kHz, obtaining a new discrete sequence <em class="calibre7">x</em><sub class="calibre12">2</sub>(<em class="calibre7">n</em>). Performing an FFT on <em class="calibre7">x</em><sub class="calibre12">2</sub>(<em class="calibre7">n</em>), we obtain the |<em class="calibre7">X</em><sub class="calibre12">2</sub>(<em class="calibre7">m</em>)| FFT magnitude results presented in <a href="#calibre_link-527">Figure P4-7(b)</a>. In our new spectral results we see our signal of interest remains in the frequency range of 0 to 4 kHz, but the narrowband spectral noise signal is now centered near 4 kHz! (If this ever happens to you in practice, to quote Veronica in the 1986 movie <em class="calibre7">The Fly,</em> “Be afraid. Be very afraid.”) Describe the characteristic of the analog <em class="calibre7">x</em>(<em class="calibre7">t</em>) that would account for the unexpected shift in center frequency of the narrowband noise in the |<em class="calibre7">X</em><sub class="calibre12">2</sub>(<em class="calibre7">m</em>)| FFT results.</p>
<p class="indenthanging"><a id="calibre_link-2656"></a><strong class="calibre9">4.8</strong> In the text’s derivation of the radix-2 FFT, to simplify the algebraic notation we represented unity-magnitude complex numbers (what we called “twiddle factors”) in the following form:</p>
<p class="image"><img src="images/001408.jpg" alt="image" class="calibre2" /></p>
<p class="indentpara">If <em class="calibre7">k</em> = 3 and <em class="calibre7">N</em> = 16:</p>
<p class="indenthangingn"><strong class="calibre9">(a)</strong> Express α as a complex number in polar (complex exponential) form.</p>
<p class="indenthangingn"><strong class="calibre9">(b)</strong> Express α as a complex number in rectangular form.</p>
<p class="indenthanging"><strong class="calibre9">4.9</strong> Reviewing the 8-point FFT signal-flow diagram in the text’s <a href="#calibre_link-487">Figure 4-5</a>:</p>
<p class="indenthangingn"><strong class="calibre9">(a)</strong> Which <em class="calibre7">x</em>(<em class="calibre7">n</em>) input samples affect the value of the FFT’s <em class="calibre7">X</em>(2) output sample?</p>
<p class="indenthangingn"><strong class="calibre9">(b)</strong> Which <em class="calibre7">x</em>(<em class="calibre7">n</em>) input samples affect the value of the FFT’s <em class="calibre7">X</em>(5) output sample?</p>
<p class="indenthanging"><strong class="calibre9">4.10</strong> <a href="#calibre_link-528">Figure P4-10</a> shows a 4-point FFT using standard decimation-in-time butterflies. Redraw that FFT using <em class="calibre7">optimized</em> decimation-in-time butterflies as shown in the text’s <a href="#calibre_link-43">Figure 4-14(c)</a>. In your drawing provide the correct indices for the <em class="calibre7">X</em>(<em class="calibre7">m</em>) output samples.</p>
<p class="caption"><a id="calibre_link-528"></a><strong class="calibre9">Figure P4-10</strong></p>
<p class="image"><img src="images/001069.jpg" alt="image" class="calibre2" /></p>
<p class="indenthanging"><strong class="calibre9">4.11</strong> Being able to compute individual twiddle factors within an FFT can be important when implementing specialized FFTs, such as <em class="calibre7">pruned</em> FFTs. (Pruned FFTs are FFTs where we need not compute all <em class="calibre7">N</em> FFT output samples[Pruned FFT&ndash;1-Pruned FFT 4]). <a href="#calibre_link-529">Figure P4-11</a> shows the signal-flow diagram of a standard 8-point <em class="calibre7">decimation-in-time</em> (DIT) FFT with bit-reversed inputs. As in the text’s <a href="#calibre_link-494">Figure 4-8</a>, the number on an arrow is the integer <em class="calibre7">k</em> of a butterfly’s</p>
<p class="image"><img src="images/000447.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-529"></a><strong class="calibre9">Figure P4-11</strong></p>
<p class="image"><img src="images/000762.jpg" alt="image" class="calibre2" /></p>
<p class="indentpara">twiddle factor. Notice that the number of unique twiddle factors is different in each of the three stages. The values of the <em class="calibre7">R</em> unique twiddle factors in the <em class="calibre7">q</em>th stage of a general <em class="calibre7">N</em>-point DIT FFT are given by</p>
<p class="center"><a id="calibre_link-2657"></a><em class="calibre7">k</em>th twiddle factor of <em class="calibre7">q</em>th stage = <img src="images/001299.jpg" alt="image" class="calibre2" />, for <em class="calibre7">k</em> = 0,1,2,..., <em class="calibre7">R</em> − 1.</p>
<p class="indentpara">What are the expressions for the above <em class="calibre7">R</em> and <em class="calibre7">P</em> factors in terms of the FFT’s <em class="calibre7">q</em> stage number?</p>
<p class="indentpara"><strong class="calibre9">Hint:</strong> Use the 8-point FFT in <a href="#calibre_link-529">Figure P4-11</a> as a guide to find <em class="calibre7">R</em> and <em class="calibre7">P</em>.</p>
<p class="indenthanging"><strong class="calibre9">4.12</strong> Let’s become more familiar with the interesting internal computations of a radix-2 FFT. <a href="#calibre_link-530">Figure P4-12</a> shows the signal-flow diagram of a standard <a id="calibre_link-2658"></a>8-point <em class="calibre7">decimation-in-time</em> FFT with bit-reversed outputs. In that figure, as in the text’s <a href="#calibre_link-495">Figure 4-9</a>, the number on an arrow is the integer <em class="calibre7">k</em> of a butterfly’s <em class="calibre7">e</em><sup class="calibre10">−<em class="calibre7">j</em>2π<em class="calibre7">k</em>/8</sup> twiddle factor.</p>
<p class="caption"><a id="calibre_link-530"></a><strong class="calibre9">Figure P4-12</strong></p>
<p class="image"><img src="images/000380.jpg" alt="image" class="calibre2" /></p>
<p class="indenthangingn"><strong class="calibre9">(a)</strong> Redraw <a href="#calibre_link-530">Figure P4-12</a>, replacing the <em class="calibre7">k</em> factors with the butterflies’ full complex twiddle factors in rectangular notation.</p>
<p class="indenthangingn"><strong class="calibre9">(b)</strong> Regarding your solution to the above Part (a), comment on any interesting properties of the twiddle factors in the FFT’s first and second stages.</p>
<p class="indenthanging"><strong class="calibre9">4.13</strong> To reiterate the meaning and correctness of the FFT butterfly structures in the text, we examine the 8-point <em class="calibre7">decimation-in-time</em> FFT with bit-reversed inputs. That FFT, the text’s <a href="#calibre_link-494">Figure 4-8</a> repeated here as <a href="#calibre_link-531">Figure P4-13</a>, uses our notation where a number on an arrow is the integer <em class="calibre7">k</em> of a butterfly’s <em class="calibre7">e</em><sup class="calibre10">−<em class="calibre7">j</em>2π<em class="calibre7">k</em>/8</sup> twiddle factor. Compute the values at sample nodes <em class="calibre7">A</em> through <em class="calibre7">F</em>, in terms of the <em class="calibre7">x</em>(<em class="calibre7">n</em>) input samples, and show that the FFT’s <em class="calibre7">X</em>(2) output is equal to a DFT’s output for <em class="calibre7">m</em> = 2 in</p>
<p class="image"><img src="images/000686.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-531"></a><strong class="calibre9">Figure P4-13</strong></p>
<p class="image"><img src="images/001588.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><strong class="calibre9">Hint:</strong> To keep the notation simple, use the term <em class="calibre7">W<sup class="calibre10">q</sup></em> to represent <em class="calibre7">e</em><sup class="calibre10">−<em class="calibre7">j</em>2π<em class="calibre7">q</em>/8</sup>.</p>
<p class="indenthanging"><strong class="calibre9">4.14</strong> Consider the 16-point decimation-in-time FFT in <a href="#calibre_link-532">Figure P4-14</a> that is implemented in a similar manner to that shown in the text’s <a href="#calibre_link-495">Figure 4-9</a>. This FFT has <em class="calibre7">in-order</em> input data indexing. That is, the <em class="calibre7">x</em>(<em class="calibre7">n</em>) input indexing is in normal <a id="calibre_link-2659"></a>numerical order from <em class="calibre7">x</em>(0) to <em class="calibre7">x</em>(15). What will be the order of the frequency-domain indexing of the <em class="calibre7">X</em>(<em class="calibre7">m</em>) output samples for this 16-point radix-2 FFT?</p>
<p class="caption"><a id="calibre_link-532"></a><strong class="calibre9">Figure P4-14</strong></p>
<p class="image"><img src="images/000835.jpg" alt="image" class="calibre2" /></p>
<p class="indenthanging"><strong class="calibre9">4.15</strong> Is it possible to examine the signal-flow diagram of a single standard butterfly, such as that in <a href="#calibre_link-533">Figure P4-15</a>, and determine if it is a decimation-in-time (DIT) butterfly or a decimation-in-frequency (DIF) butterfly? Justify your answer.</p>
<p class="caption"><a id="calibre_link-533"></a><strong class="calibre9">Figure P4-15</strong></p>
<p class="image"><img src="images/001458.jpg" alt="image" class="calibre2" /></p>
<p class="indenthanging"><strong class="calibre9">4.16</strong> Let’s explore the internal structure of a single radix-2 FFT butterfly. <a href="#calibre_link-534">Figure P4-16(a)</a> shows our standard notation for a decimation-in-time butterfly where the input and output samples (<em class="calibre7">A</em>, <em class="calibre7">B</em>, <em class="calibre7">C</em>, and <em class="calibre7">D</em>) are complex-valued. <a href="#calibre_link-534">Figure P4-16(b)</a> shows the same decimation-in-time butterfly where the input and output values are represented by real-valued samples. We use the notation that</p>
<p class="center"><em class="calibre7">A</em> = <em class="calibre7">A</em><sub class="calibre12">R</sub> + <em class="calibre7">jA</em><sub class="calibre12">I</sub></p>
<p class="caption"><a id="calibre_link-534"></a><strong class="calibre9">Figure P4-16</strong></p>
<p class="image"><img src="images/000282.jpg" alt="image" class="calibre2" /></p>
<p class="indentpara">where <em class="calibre7">A</em><sub class="calibre12">R</sub> and <em class="calibre7">A</em><sub class="calibre12">I</sub> are real-valued. Draw the real-valued block diagram of what arithmetic is performed inside the rectangle in <a href="#calibre_link-534">Figure P4-16(b)</a>. Be sure to <a id="calibre_link-2660"></a>include in your diagram the expressions (the equations) for the real-valued <em class="calibre7">C</em><sub class="calibre12">R</sub>, <em class="calibre7">C</em><sub class="calibre12">I</sub>, <em class="calibre7">D</em><sub class="calibre12">R</sub>, and <em class="calibre7">D</em><sub class="calibre12">I</sub> output samples in terms of the real-valued <em class="calibre7">A</em><sub class="calibre12">R</sub>, <em class="calibre7">A</em><sub class="calibre12">I</sub>, <em class="calibre7">B</em><sub class="calibre12">R</sub>, and <em class="calibre7">B</em><sub class="calibre12">I</sub> input samples and the twiddle factor angle θ. The solution to this problem illustrates the computational complexity of performing a single FFT butterfly.</p>
<p class="indenthanging"><strong class="calibre9">4.17</strong> Here’s a problem that has much practical importance. It concerns the data word growth that can occur inside an FFT.</p>
<p class="indentpara">For this problem, our assumptions are:</p>
<p class="indenthangingb1">• We are implementing an FFT using the optimized decimation-in-time FFT butterfly structure, shown in <a href="#calibre_link-535">Figure P4-17</a>, to compute intermediate results.</p>
<p class="caption"><a id="calibre_link-535"></a><strong class="calibre9">Figure P4-17</strong></p>
<p class="image"><img src="images/000906.jpg" alt="image" class="calibre2" /></p>
<p class="indenthangingb1">• The complex data samples <em class="calibre7">A</em> and <em class="calibre7">B</em> are contained in 8-bit storage locations using the <em class="calibre7">sign-magnitude</em> number format system. (In that number format the most positive and most negative decimal numbers we can store, as binary words in an 8-bit-wide memory location, are +127 and −127 respectively.)</p>
<p class="indentpara">It’s difficult at first to imagine that multiplying complex samples <em class="calibre7">A</em> and <em class="calibre7">B</em> by sines and cosines (the real and imaginary parts of <em class="calibre7">e</em><sup class="calibre10">−<em class="calibre7">j</em>2π<em class="calibre7">k</em>/<em class="calibre7">N</em></sup>) can lead to <a id="calibre_link-2661"></a>excessive data word growth&mdash;particularly because sines and cosines are never greater than unity. However, significant data word growth can happen within an FFT butterfly.</p>
<p class="indenthangingn"><strong class="calibre9">(a)</strong> In our 8-bit number format scenario, what is the maximum possible decimal value of the real part of the complex output sample <em class="calibre7">C</em>?</p>
<p class="indenthangingn"><strong class="calibre9">(b)</strong> How many binary bits are needed for a storage register (memory location) to hold that maximum real part of the complex output sample <em class="calibre7">C</em>?</p>
<p class="indenthanging"><strong class="calibre9">4.18</strong> In 2006 the scientists at the Max Planck Institute for Radio Astronomy, in Bonn, Germany, built a hardware spectrum analyzer that performs 16384-point FFTs. This massively parallel analyzer performs 1.744 × 10<sup class="calibre10">5</sup> such FFTs per second. Assuming that the FFTs use the optimized decimation-in-frequency FFT butterfly structure, shown in <a href="#calibre_link-536">Figure P4-18</a>, and that the <em class="calibre7">A</em> and <em class="calibre7">B</em> samples are complex-valued, how many real-valued multiplies per second are being performed by the spectrum analyzer? Show your work.</p>
<p class="caption"><a id="calibre_link-536"></a><strong class="calibre9">Figure P4-18</strong></p>
<p class="image"><img src="images/001741.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2662"></a></p>
<h3 class="calibre6">References</h3>
<p class="indenthanging">[Pruned FFT 1] Nagai, K. “Pruning the Decimation-in-Time FFT Algorithm with Frequency Shift,” <em class="calibre7">IEEE Trans. on ASSP</em>, Vol. ASSP-34, August 1986, pp. 1008&ndash;1010.</p>
<p class="indenthanging">[Pruned FFT 2] Skinner, D. “Pruning the Decimation-in-Time FFT Algorithm,” <em class="calibre7">IEEE Trans. on ASSP</em>, Vol. ASSP-24, April 1976, pp. 193&ndash;194.</p>
<p class="indenthanging">[Pruned FFT 3] Markel, J. D. “FFT Pruning,” <em class="calibre7">IEEE Trans. on Audio Electroacoustics</em>, Vol. AU-19, December 1971, pp. 305&ndash;311.</p>
<p class="indenthanging">[Pruned FFT 4] Sreenivas, T., and Rao, P. “FFT Algorithm for Both Input and Ouput Pruning,” <em class="calibre7">IEEE Trans. on ASSP</em>, Vol. ASSP-27, June 1979, pp. 291&ndash;292.</p>
</div>


</body></html>
