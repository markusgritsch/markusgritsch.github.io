<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="style.css" rel="stylesheet" type="text/css" /><title>Understanding Digital Signal Processing</title>
<style type="text/css">
body {
  -webkit-text-size-adjust: 260%; /* text */
  zoom: 1.8; /* graphics */
  font-family: "BookerlyLCD";
}
a {
  color: #005090;
  text-decoration: none;
}
a {font-variant-numeric: oldstyle-nums proportional-nums;}
p.caption {font-variant-numeric: oldstyle-nums proportional-nums;}
</style>
</head><body>


<div class="calibre" id="calibre_link-572">
<p class="calibre3"><a id="calibre_link-2482"></a></p>
<h2 class="calibre8"><a id="calibre_link-2483" class="calibre5"></a>Contents</h2>
<p class="toc-chapter1"><a id="calibre_link-2487"></a><strong class="calibre9"><a href="#calibre_link-663">11 SIGNAL AVERAGING</a></strong></p>
<p class="toc-section"><a href="#calibre_link-664">11.1 Coherent Averaging</a></p>
<p class="toc-section"><a href="#calibre_link-665">11.2 Incoherent Averaging</a></p>
<p class="toc-section"><a href="#calibre_link-462">11.3 Averaging Multiple Fast Fourier Transforms</a></p>
<p class="toc-section"><a href="#calibre_link-666">11.4 Averaging Phase Angles</a></p>
<p class="toc-section"><a href="#calibre_link-667">11.5 Filtering Aspects of Time-Domain Averaging</a></p>
<p class="toc-section"><a href="#calibre_link-668">11.6 Exponential Averaging</a></p>
<p class="toc-section1"><a href="#calibre_link-669">References</a></p>

</div>


<div class="calibre" id="calibre_link-663">
<p class="calibre3"><a id="calibre_link-225"></a></p>
<h2 class="calibre8"><a id="calibre_link-2388" class="calibre5"></a>11 Signal Averaging</h2>
<p class="image"><img src="images/001349.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">How do we determine the typical amount, a valid estimate, or the true value of some measured parameter? In the physical world, it’s not so easy to do because unwanted random disturbances contaminate our measurements. These disturbances are due to both the nature of the variable being measured and the fallibility of our measuring devices. Each time we try to accurately measure some physical quantity, we’ll get a slightly different value. Those unwanted fluctuations in a measured value are called <em class="calibre7">noise</em>, and digital signal processing practitioners have learned to minimize noise through the process of averaging. In the literature, we can see not only how averaging is used to improve measurement accuracy, but that averaging also shows up in signal detection algorithms as well as in lowpass filter schemes. This chapter introduces the mathematics of averaging and describes how and when this important process is used. Accordingly, as we proceed to quantify the benefits of averaging, we’re compelled to make use of the statistical measures known as the mean, variance, and standard deviation.</p>
<p class="calibre3">In digital signal processing, averaging often takes the form of summing a series of time-domain signal samples and then dividing that sum by the number of individual samples. Mathematically, the average of <em class="calibre7">N</em> samples of sequence <em class="calibre7">x</em>(<em class="calibre7">n</em>), denoted <em class="calibre7">x</em><sub class="calibre12">ave</sub>, is expressed as</p>
<p class="caption"><a id="calibre_link-3103"></a>(11-1)</p>
<p class="image"><img src="images/001319.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">(What we call the average, statisticians call the <em class="calibre7">mean</em>.) In studying averaging, a key definition that we must keep in mind is the variance of the sequence, σ<sup class="calibre10">2</sup>, defined as</p>
<p class="caption"><a id="calibre_link-2425"></a><a id="calibre_link-1776"></a>(11-2)</p>
<p class="image"><img src="images/000358.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-1777"></a>(11-2′)</p>
<p class="image"><img src="images/001205.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">As explained in <a href="#calibre_link-27">Appendix D</a>, the σ<sup class="calibre10">2</sup> variance in <a href="#calibre_link-1776">Eqs. (11-2)</a> and <a href="#calibre_link-1777">(11-2′)</a> gives us a well-defined quantitative measure of how much the values in a sequence fluctuate about the sequence’s average. That’s because the <em class="calibre7">x</em>(1) &ndash; <em class="calibre7">x</em><sub class="calibre12">ave</sub> value in the bracket, for example, is the difference between the <em class="calibre7">x</em>(1) value and the sequence average <em class="calibre7">x</em><sub class="calibre12">ave</sub>. The other important quantity that we’ll use is the standard deviation, defined as the positive square root of the variance, or</p>
<p class="caption"><a id="calibre_link-3104"></a>(11-3)</p>
<p class="image"><img src="images/000243.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">To reiterate our thoughts, the average value <em class="calibre7">x</em><sub class="calibre12">ave</sub> is the constant level about which the individual sequence values may vary. The variance σ<sup class="calibre10">2</sup> indicates the sum of the magnitudes squared of the noise fluctuations of the individual sequence values about the <em class="calibre7">x</em><sub class="calibre12">ave</sub> average value. If the sequence <em class="calibre7">x</em>(<em class="calibre7">n</em>) represents a time series of signal samples, we can say that <em class="calibre7">x</em><sub class="calibre12">ave</sub> specifies the constant, or DC, value of the signal, the standard deviation σ reflects the amount of the fluctuating, or AC, component of the signal, and the variance σ<sup class="calibre10">2</sup> is an indication of the power in the fluctuating component. (<a href="#calibre_link-27">Appendix D</a> explains and demonstrates the nature of these statistical concepts for those readers who don’t use them on a daily basis.)</p>
<p class="calibre3">We’re now ready to investigate two kinds of averaging, <em class="calibre7">coherent</em> and <em class="calibre7">incoherent</em>, to learn how they’re different from each other and to see under what conditions they should be used.</p>
<p class="calibre3"><a id="calibre_link-664"></a></p>
<h3 class="calibre6">11.1 Coherent Averaging</h3>
<p class="calibre3">In the coherent averaging process (also known as <em class="calibre7">time-synchronous averaging</em>), the key feature is the timing used in sampling the original signal; that is, we collect multiple sets of signal-plus-noise samples, and we need the time phase of the signal in each set to be identical. For example, when averaging a sinewave embedded in noise, coherent averaging requires that the phase of the sinewave be the same at the beginning of each measured sample set. When this requirement is met, the sinewave will average to its true sinewave amplitude value. The noise, however, is different in each sample set and will average toward <a id="calibre_link-3105"></a>zero.<sup class="calibre10"><a id="calibre_link-1780"></a><a href="#calibre_link-1778">†</a></sup> The point is that coherent averaging reduces the variance of the noise, while preserving the amplitude of signals that are synchronous, or coherent, with the beginning of the sampling interval. With coherent averaging, we can actually improve the signal-to-noise ratio of a noisy signal. By way of example, consider the sequence of 128 data points plotted in <a href="#calibre_link-1779">Figure 11-1(a)</a>. Those data points represent the time-domain sampling of a single pulse contaminated with random noise. (For illustrative purposes the pulse, whose peak amplitude is 2.5, is shown in the background of <a href="#calibre_link-1779">Figure 11-1</a>.) It’s very difficult to see a pulse in the bold pulse-plus-noise waveform in the foreground of <a href="#calibre_link-1779">Figure 11-1(a)</a>. Let’s say we collect 32 sets of 128 pulse-plus-noise samples of the form</p>
<p class="footnotes"><a id="calibre_link-1778"></a><sup class="calibre11"><a href="#calibre_link-1780">†</a></sup> Noise samples are assumed to be uncorrelated with each other and uncorrelated with the sample rate. If some component of the noise is correlated with the sample rate, that noise component <em class="calibre7">will</em> be preserved after averaging.</p>
<p class="caption"><a id="calibre_link-1781"></a>(11-4)</p>
<p class="image"><img src="images/001085.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-1779"></a><strong class="calibre9">Figure 11-1</strong> Signal pulse plus noise: (a) one sample set; (b) average of 32 sample sets; (c) average of 256 sample sets.</p>
<p class="image"><img src="images/000956.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Here’s where the coherent part comes in: the signal measurement times must be synchronized, in some manner, with the beginning of the pulse, so that the pulse is in a constant time relationship with the first sample of each sample set. Coherent averaging of the 32 sets of samples, adding up the columns of <a href="#calibre_link-1781">Eq. (11-4)</a>, takes the form of</p>
<p class="image"><img src="images/001305.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">or</p>
<p class="caption"><a id="calibre_link-1782"></a>(11-5)</p>
<p class="image"><img src="images/001178.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">If we perform 32 averages indicated by <a href="#calibre_link-1782">Eq. (11-5)</a> on a noisy pulse like that in <a href="#calibre_link-1779">Figure 11-1(a)</a>, we’d get the 128-point <em class="calibre7">x</em><sub class="calibre12">ave</sub>(<em class="calibre7">k</em>) sequence plotted in <a href="#calibre_link-1779">Figure 11-1(b)</a>. Here, we’ve reduced the noise fluctuations riding on the pulse, and the pulse shape is beginning to become apparent. The coherent average of 256 sets of <a id="calibre_link-2422"></a>pulse measurement sequences results in the plot shown in <a href="#calibre_link-1779">Figure 11-1(c)</a>, where the pulse shape is clearly visible now. We’ve reduced the noise fluctuations while preserving the pulse amplitude. (An important concept to keep in mind is that summation and averaging both reduce noise variance. Summation is merely implementing <a href="#calibre_link-1782">Eq. (11-5)</a> without dividing the sum by <em class="calibre7">N</em> = 32. If we perform summations and don’t divide by <em class="calibre7">N</em>, we merely change the vertical scales for the graphs in <a href="#calibre_link-1779">Figures 11-1(b)</a> and <a href="#calibre_link-1779">11-1(c)</a>. However, the noise fluctuations will remain unchanged relative to true pulse amplitude on the new scale.)</p>
<p class="calibre3">The mathematics of this averaging process in <a href="#calibre_link-1782">Eq. (11-5)</a> is both straightforward and important. What we’d like to know is the signal-to-noise improvement gained by coherent averaging as a function of <em class="calibre7">N,</em> the number of sample sets averaged. Let’s say that we want to measure some constant time <a id="calibre_link-2426"></a>signal with amplitude <em class="calibre7">A,</em> and each time we actually make a measurement we get a slightly different value for <em class="calibre7">A</em>. We realize that our measurements are contaminated with noise such that the <em class="calibre7">n</em>th measurement result <em class="calibre7">r</em>(<em class="calibre7">n</em>) is</p>
<p class="caption"><a id="calibre_link-3106"></a>(11-6)</p>
<p class="image"><img src="images/000978.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where noise(<em class="calibre7">n</em>) is the noise contribution. Our goal is to determine <em class="calibre7">A</em> when the <em class="calibre7">r</em>(<em class="calibre7">n</em>) sequence of noisy measurements is all we have to work with. For a more accurate estimate of <em class="calibre7">A</em>, we average <em class="calibre7">N</em> separate <em class="calibre7">r</em>(<em class="calibre7">n</em>) measurement samples and calculate a single average value <em class="calibre7">r</em><sub class="calibre12">ave</sub>. To get a feeling for the accuracy of <em class="calibre7">r</em><sub class="calibre12">ave</sub>, we decide to take a series of averages, <em class="calibre7">r</em><sub class="calibre12">ave</sub>(<em class="calibre7">k</em>), to see how that series fluctuates with each new average; that is,</p>
<p class="caption"><a id="calibre_link-3107"></a>(11-7)</p>
<p class="image"><img src="images/001239.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">or, more concisely,</p>
<p class="caption"><a id="calibre_link-3108"></a>(11-8)</p>
<p class="image"><img src="images/000874.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">To see how averaging reduces our measurement uncertainty, we need to compare the standard deviation of our <em class="calibre7">r</em><sub class="calibre12">ave</sub>(<em class="calibre7">k</em>) sequence of averages with the standard deviation of the original <em class="calibre7">r</em>(<em class="calibre7">n</em>) sequence.</p>
<p class="calibre3">If the standard deviation of our original series of measurements <em class="calibre7">r</em>(<em class="calibre7">n</em>) is σ<sub class="calibre12">in</sub>, it has been shown[<a href="#calibre_link-1783">1</a>&ndash;<a href="#calibre_link-1784">5</a>] that the standard deviation of our <em class="calibre7">r</em><sub class="calibre12">ave</sub>(<em class="calibre7">k</em>) sequence of <em class="calibre7">N</em>-point averages, σ<sub class="calibre12">ave</sub>, is given by</p>
<p class="caption"><a id="calibre_link-1785"></a>(11-9)</p>
<p class="image"><img src="images/001731.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Likewise, we can relate the variance of our <em class="calibre7">r</em><sub class="calibre12">ave</sub>(<em class="calibre7">k</em>) sequence of <em class="calibre7">N</em>-point averages to the variance of the original series of <em class="calibre7">r</em>(<em class="calibre7">n</em>) measurements as</p>
<p class="caption"><a id="calibre_link-3109"></a>(11-9′)</p>
<p class="image"><img src="images/000740.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a href="#calibre_link-1785">Equation (11-9)</a> is significant because it tells us that the <em class="calibre7">r</em><sub class="calibre12">ave</sub>(<em class="calibre7">k</em>) series of averages will not fluctuate as much around <em class="calibre7">A</em> as the original <em class="calibre7">r</em>(<em class="calibre7">n</em>) measurement values did; that is, the <em class="calibre7">r</em><sub class="calibre12">ave</sub>(<em class="calibre7">k</em>) sequence will be less noisy than any <em class="calibre7">r</em>(<em class="calibre7">n</em>) sequence, and the more we average by increasing <em class="calibre7">N</em>, the more closely an individual <em class="calibre7">r</em><sub class="calibre12">ave</sub>(<em class="calibre7">k</em>) estimate will approach the true value of <em class="calibre7">A</em>.<sup class="calibre10"><a id="calibre_link-1787"></a><a href="#calibre_link-1786">†</a></sup></p>
<p class="footnotes"><a id="calibre_link-1786"></a><sup class="calibre11"><a href="#calibre_link-1787">†</a></sup> <a href="#calibre_link-1785">Equation (11-9)</a> is based on the assumptions that the average of the original noise is zero and that neither <em class="calibre7">A</em> nor σ<sub class="calibre14">in</sub> changes during the time we’re performing our averages.</p>
<p class="calibre3"><a id="calibre_link-2424"></a>In a different way, we can quantify the noise reduction afforded by averaging. If the quantity <em class="calibre7">A</em> represents the amplitude of a signal and σ<sub class="calibre12">in</sub> represents the standard deviation of the noise riding on that signal amplitude, we can state that the original signal-amplitude-to-noise ratio is</p>
<p class="caption"><a id="calibre_link-3110"></a>(11-10)</p>
<p class="image"><img src="images/001612.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Likewise, the signal-amplitude-to-noise ratio at the output of an averaging process, <em class="calibre7">SNR</em><sub class="calibre12">ave</sub>, is defined as</p>
<p class="caption"><a id="calibre_link-3111"></a>(11-11)</p>
<p class="image"><img src="images/000635.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Continuing, the signal-to-noise ratio <em class="calibre7">gain</em>, <em class="calibre7">SNR</em><sub class="calibre12">coh</sub> gain, that we’ve realized through coherent averaging is the ratio of <em class="calibre7">SNR</em><sub class="calibre12">ave</sub> over <em class="calibre7">SNR</em><sub class="calibre12">in</sub>, or</p>
<p class="caption"><a id="calibre_link-1788"></a>(11-12)</p>
<p class="image"><img src="images/001491.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Substituting σ<sub class="calibre12">ave</sub> from <a href="#calibre_link-1785">Eq. (11-9)</a> in <a href="#calibre_link-1788">Eq. (11-12)</a>, the SNR gain becomes</p>
<p class="caption"><a id="calibre_link-1789"></a>(11-13)</p>
<p class="image"><img src="images/000529.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Through averaging, we can realize a signal-to-noise ratio improvement proportional to the square root of the number of signal samples averaged. In terms of signal-to-noise ratio measured in dB, we have a coherent averaging, or <em class="calibre7">integration</em>, gain of</p>
<p class="caption"><a id="calibre_link-1790"></a>(11-14)</p>
<p class="image"><img src="images/001593.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Again, <a href="#calibre_link-1789">Eqs. (11-13)</a> and <a href="#calibre_link-1790">(11-14)</a> are valid if <em class="calibre7">A</em> represents the <em class="calibre7">amplitude</em> of a signal and σ<sub class="calibre12">in</sub> represents the original noise standard deviation.</p>
<p class="calibre3">Another way to view the integration gain afforded by coherent averaging is to consider the standard deviation of the input noise, σ<sub class="calibre12">in</sub>, and the probability of measuring a particular value for the <a href="#calibre_link-1779">Figure 11-1</a> pulse amplitude. Assume that we made many individual measurements of the pulse amplitude and created a fine-grained histogram of those measured values to get the dashed curve in <a href="#calibre_link-1791">Figure 11-2</a>. The vertical axis of <a href="#calibre_link-1791">Figure 11-2</a> represents the probability of measuring a pulse-amplitude value corresponding to the values on the horizontal axis. If the noise fluctuations follow the well-known <em class="calibre7">normal</em>, or Gaussian, distribution, that dashed probability distribution curve is described by</p>
<p class="caption"><a id="calibre_link-1794"></a>(11-15)</p>
<p class="image"><img src="images/000428.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-3112"></a><a id="calibre_link-1791"></a><strong class="calibre9">Figure 11-2</strong> Probability density curves of measured pulse amplitudes with no averaging (<em class="calibre7">N</em> = 1) and with <em class="calibre7">N</em> = 32 averaging.</p>
<p class="image"><img src="images/000009.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where σ = σ<sub class="calibre12">in</sub> and the true pulse amplitude is represented by μ = 2.5. We see from that dashed curve that any given measured value will most likely (with highest probability) be near the actual pulse-amplitude value of 2.5. Notice, however, that there’s a nonzero probability that the measured value could be as low as 1.0 or as high as 4.0. Let’s say that the dashed curve represents the probability curve of the pulse-plus-noise signal in <a href="#calibre_link-1779">Figure 11-1(a)</a>. If we averaged a series of 32 pulse-amplitude values and plotted a probability curve of our averaged pulse-amplitude measurements, we’d get the solid curve in <a href="#calibre_link-1791">Figure 11-2</a>. This curve characterizes the pulse-plus-noise values in <a href="#calibre_link-1779">Figure 11-1(b)</a>. From this solid curve, we see that there’s a very low likelihood (probability) that a measured value, after 32-point averaging, will be less than 2.0 or greater than 3.0.</p>
<p class="calibre3">From <a href="#calibre_link-1785">Eq. (11-9)</a>, we know that the standard deviation of the result of averaging 32 signal sample sets is</p>
<p class="caption"><a id="calibre_link-3113"></a>(11-16)</p>
<p class="image"><img src="images/001278.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">In <a href="#calibre_link-1791">Figure 11-2</a>, we can see a statistical view of how an averager’s output standard deviation is reduced from the averager’s input standard deviation. Taking larger averages by increasing <em class="calibre7">N</em> beyond 32 would squeeze the solid curve in <a href="#calibre_link-1791">Figure 11-2</a> even more toward its center value of 2.5, the true pulse amplitude.<sup class="calibre10"><a id="calibre_link-1793"></a><a href="#calibre_link-1792">†</a></sup></p>
<p class="footnotes"><a id="calibre_link-1792"></a><sup class="calibre11"><a href="#calibre_link-1793">†</a></sup> The curves in <a href="#calibre_link-1791">Figure 11-2</a> are normalized for convenient illustration. From <a href="#calibre_link-1794">Eq. (11-15)</a> and assuming that σ = 1 when <em class="calibre7">N</em> = 1, then <em class="calibre7">K</em> = 0.3989. When <em class="calibre7">N</em> = 32, the new standard deviation is <img src="images/000601.jpg" alt="image" class="calibre2" /> and <img src="images/001462.jpg" alt="image" class="calibre2" />.</p>
<p class="calibre3"><a id="calibre_link-3114"></a>Returning to the noisy pulse signal in <a href="#calibre_link-1779">Figure 11-1</a>, and performing coherent averaging for various numbers of sample sets <em class="calibre7">N</em>, we see in <a href="#calibre_link-1795">Figure 11-3(a)</a> that as <em class="calibre7">N</em> increases, the averaged pulse amplitude approaches the true amplitude of 2.5. <a href="#calibre_link-1795">Figure 11-3(b)</a> shows how rapidly the variance of the noise riding on the pulse falls off as <em class="calibre7">N</em> is increased. An alternate way to see how the noise variance decreases with increasing <em class="calibre7">N</em> is the noise power plotted on a <a id="calibre_link-2430"></a>logarithmic scale as in <a href="#calibre_link-1795">Figure 11-3(c)</a>. In this plot, the noise variance is normalized to that noise variance when no averaging is performed, i.e., when <em class="calibre7">N</em> = 1. Notice that the slope of the curve in <a href="#calibre_link-1795">Figure 11-3(c)</a> closely approximates that predicted by <a href="#calibre_link-1789">Eqs. (11-13)</a> and <a href="#calibre_link-1790">(11-14)</a>; that is, as <em class="calibre7">N</em> increases by a factor of ten, we reduce the average noise power by 10 dB. Although the test signal in this discussion was a pulse signal, had the signal been sinusoidal, <a href="#calibre_link-1789">Eqs. (11-13)</a> and <a href="#calibre_link-1790">(11-14)</a> would still apply.</p>
<p class="caption"><a id="calibre_link-1795"></a><strong class="calibre9">Figure 11-3</strong> Results of averaging signal pulses plus noise: (a) measured pulse amplitude versus <em class="calibre7">N</em>; (b) measured variance of pulse amplitude versus <em class="calibre7">N</em>; (c) measured pulse-amplitude noise power versus <em class="calibre7">N</em> on a logarithmic scale.</p>
<p class="image"><img src="images/000847.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-665"></a></p>
<h3 class="calibre6">11.2 Incoherent Averaging</h3>
<p class="calibre3">The process of incoherent averaging (also known as <em class="calibre7">rms, postdetection, scalar,</em> or <em class="calibre7">video averaging</em>) is the averaging of signal samples where no sample timing constraints are used; that is, signal measurement time intervals are not synchronized in any way with the phase of the signal being measured. Think for a moment what the average would be of the noisy pulse signal in <a href="#calibre_link-1779">Figure 11-1(a)</a> if we didn’t in some way synchronize the beginning of the collection of the individual signal sample sets with the beginning of the pulse. The result would be pulses that begin at a different time index in each sample set. The averaging of multiple sample sets would then smear the pulse across the sample set, or just “average the pulse signal away.” (For those readers familiar with using oscilloscopes, incoherent averaging would be like trying to view the pulse when the beginning of the scope sweep was not triggered by the signal.) As such, incoherent averaging is not so useful in the time domain.<sup class="calibre10"><a id="calibre_link-1797"></a><a href="#calibre_link-1796">†</a></sup> In the frequency domain, however, it’s a different story because incoherent averaging can provide increased accuracy in measuring relative signal powers. Indeed, incoherent averaging is used in many test instruments, such as spectrum, network, and signal analyzers.</p>
<p class="footnotes"><a id="calibre_link-1796"></a><sup class="calibre11"><a href="#calibre_link-1797">†</a></sup> The term <em class="calibre7">incoherent averaging</em> is a bit of a misnomer. Averaging a set of data is just that, averaging&mdash;we add up a set of data values and divide by the number of samples in the set. Incoherent averaging should probably be called <em class="calibre7">averaging data that’s obtained incoherently</em>.</p>
<p class="calibre3">In some analog test equipment, time-domain signals are represented in the frequency domain using a narrowband sweeping filter followed by a power detector. These devices measure signal power as a function of frequency. The power detector is necessary because the sweeping measurement is not synchronized, in time, with the signal being measured. Thus the frequency-domain data represents power only and contains no signal phase information. Although it’s too late to improve the input’s signal-amplitude-to-noise ratio, incoherent averaging can improve the accuracy of signal power measurements in the presence of noise; that is, if the signal-power spectrum is very noisy, we can reduce the power estimation fluctuations and improve the accuracy of signal-power and noise-power measurements. <a href="#calibre_link-1798">Figure 11-4(a)</a> <a id="calibre_link-3115"></a>illustrates this idea where we see the power (magnitude squared) output of an FFT of a fundamental tone and several tone harmonics buried in background noise. Notice that the noise-power levels in <a href="#calibre_link-1798">Figure 11-4(a)</a> fluctuate by almost 20 dB about the true average noise power indicated by the dashed line at &ndash;19 dB.</p>
<p class="caption"><a id="calibre_link-1798"></a><strong class="calibre9">Figure 11-4</strong> Results of averaging signal tones plus noise-power spectra: (a) no averaging, <em class="calibre7">N</em> = 1; (b) <em class="calibre7">N</em> = 10; (c) <em class="calibre7">N</em> = 100.</p>
<p class="image"><img src="images/001707.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2423"></a>If we take 10 FFTs, average the square of their output magnitudes, and normalize those squared values, we get the power spectrum shown in <a href="#calibre_link-1798">Figure 11-4(b)</a>. Here, we’ve reduced the variance of the noise in the power spectrum but have not improved the tones’ signal-power-to-noise-power ratios; that is, the average noise-power level remains unchanged. Averaging the output magnitudes squared of 100 FFTs results in the spectrum in <a href="#calibre_link-1798">Figure 11-4(c)</a>, which provides a more accurate measure of the relative power levels of the fundamental tone’s harmonics.</p>
<p class="calibre3">Just as we arrived at a coherent integration SNR gain expression in <a href="#calibre_link-1790">Eq. (11-14)</a>, we can express an incoherent integration gain, <em class="calibre7">SNR</em><sub class="calibre12">incoh</sub> gain, in terms of SNR measured in dB as</p>
<p class="caption"><a id="calibre_link-1799"></a>(11-17)</p>
<p class="image"><img src="images/000315.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a href="#calibre_link-1799">Equation (11-17)</a> applies when the quantity being averaged represents the <em class="calibre7">power</em> of a signal. That’s why we used the factor of 10 in <a href="#calibre_link-1799">Eq. (11-17)</a> as opposed to the factor of 20 used in <a href="#calibre_link-1790">Eq. (11-14)</a>.<sup class="calibre10"><a id="calibre_link-1802"></a><a href="#calibre_link-1800">†</a></sup> We can relate the processing gain effects of <a href="#calibre_link-1790">Eqs. (11-14)</a> and <a href="#calibre_link-1799">(11-17)</a> by plotting those expressions in <a href="#calibre_link-1801">Figure 11-5</a>.</p>
<p class="footnotes"><a id="calibre_link-1800"></a><sup class="calibre11"><a href="#calibre_link-1802">†</a></sup> <a href="#calibre_link-729">Section E.1</a> of <a href="#calibre_link-296">Appendix E</a> explains why the multiplying factor is 10 for signal-power measurements and 20 when dealing with signal-amplitude values.</p>
<p class="caption"><a id="calibre_link-1801"></a><strong class="calibre9">Figure 11-5</strong> Time-domain amplitude SNR processing gain from <a href="#calibre_link-1790">Eq. (11-14)</a>, and the frequency-domain power SNR processing gain from <a href="#calibre_link-1799">Eq. (11-17)</a>, as functions of <em class="calibre7">N</em>.</p>
<p class="image"><img src="images/000727.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-462"></a></p>
<h3 class="calibre6"><a id="calibre_link-2191" class="calibre5"></a>11.3 Averaging Multiple Fast Fourier Transforms</h3>
<p class="calibre3">We discussed the processing gain associated with a single DFT in <a href="#calibre_link-596">Section 3.12</a> and stated that we can realize further processing gain by increasing the point size of any given <em class="calibre7">N</em>-point DFT. Let’s discuss this issue when the DFT is implemented using the FFT algorithm. The problem is that large FFTs require a lot of number crunching. Because addition is easier and faster to perform than multiplication, we can average the outputs of multiple FFTs to obtain further FFT signal detection sensitivity; that is, it’s easier and typically faster to average the outputs of four 128-point FFTs than it is to calculate one 512-point FFT. The increased FFT sensitivity, or noise variance reduction, due to multiple FFT averaging is also called <em class="calibre7">integration gain.</em> So the random noise fluctuations in an FFT’s output bins will decrease, while the magnitude of the FFT’s signal bin output remains constant when multiple FFT outputs are averaged. (Inherent in this argument is the assumption that the signal is present throughout the observation intervals for all of the FFTs that are being averaged and that the noise sample values are independent of the original sample rate.) There are two types of FFT averaging integration gain: incoherent and coherent.</p>
<p class="calibre3">Incoherent integration, relative to FFTs, is averaging the corresponding bin magnitudes of multiple FFTs; that is, to incoherently average <em class="calibre7">k</em> FFTs, the zeroth bin of the incoherent FFT average <em class="calibre7">F</em><sub class="calibre12">incoh</sub>(0) is given by</p>
<p class="caption"><a id="calibre_link-3116"></a>(11-18)</p>
<p class="image"><img src="images/001157.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where |<em class="calibre7">F<sub class="calibre12">n</sub></em>(0)| is the magnitude of the zeroth bin from the <em class="calibre7">n</em>th FFT. Likewise, the first bin of the incoherent FFT average, <em class="calibre7">F</em><sub class="calibre12">incoh</sub>(1), is given by</p>
<p class="caption"><a id="calibre_link-3117"></a>(11-18′)</p>
<p class="image"><img src="images/001608.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">and so on, out to the last bin of the FFT average, <em class="calibre7">F</em><sub class="calibre12">incoh</sub>(<em class="calibre7">N</em>&ndash;1), which is</p>
<p class="caption"><a id="calibre_link-3118"></a>(11-18″)</p>
<p class="image"><img src="images/001045.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Incoherent integration provides additional reduction in background noise variation to augment a single FFT’s inherent processing gain. We can demonstrate this in <a href="#calibre_link-1803">Figure 11-6(a)</a>, where the shaded curve is a single FFT output of random noise added to a tone centered in the 16th bin of a 64-point FFT. The solid curve in <a href="#calibre_link-1803">Figure 11-6(a)</a> is the incoherent integration of ten individual 64-point FFT magnitudes. Both curves are normalized to their peak values, so that the vertical scales are referenced to 0 dB. Notice how the variations <a id="calibre_link-3119"></a>in the noise power in the solid curve have been reduced by the averaging of the ten FFTs. The noise-power values in the solid curve don’t fluctuate as much as the shaded noise-power values. By averaging, we haven’t raised the power of the tone in the 16th bin, but we have reduced the peaks of the noise-power values. The larger the number of FFTs averaged, the closer the individual noise-power bin values will approach the true average noise power indicated by the dashed horizontal line in <a href="#calibre_link-1803">Figure 11-6(a)</a>.</p>
<p class="caption"><a id="calibre_link-1803"></a><strong class="calibre9">Figure 11-6</strong> Single FFT output magnitudes (shaded) and the average of ten FFT output magnitudes (solid): (a) tone at bin center; (b) tone between bin centers.</p>
<p class="image"><img src="images/001583.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">When the signal tone is not at a bin center, incoherent integration still reduces fluctuations in the FFT’s noise-power bins. The shaded curve in <a href="#calibre_link-1803">Figure 11-6(b)</a> is a single FFT output of random noise added to a tone whose frequency is halfway between the 16th and 17th bins of the 64-point FFT. Likewise, the solid curve in <a href="#calibre_link-1803">Figure 11-6(b)</a> is the magnitude average of ten FFTs. The variations in the noise power in the solid curve have again been reduced by the integration of the ten FFTs. So incoherent integration gain reduces <a id="calibre_link-3120"></a>noise-power fluctuations regardless of the frequency location of any signals of interest. As we would expect, the signal peaks are wider, and the true average noise power is larger in <a href="#calibre_link-1803">Figure 11-6(b)</a> relative to <a href="#calibre_link-1803">Figure 11-6(a)</a> because leakage raises the average noise-power level and scalloping loss reduces the FFT bin’s output power level in <a href="#calibre_link-1803">Figure 11-6(b)</a>. The thing to remember is that incoherent averaging of FFT output magnitudes reduces the <em class="calibre7">variations</em> in the background noise power but does not reduce the average background noise power. Equivalent to the incoherent averaging results in <a href="#calibre_link-665">Section 11.2</a>, the reduction in the output noise variance<a href="#calibre_link-1804">[6]</a> of the incoherent average of <em class="calibre7">k</em> FFTs relative to the output noise variance of a single FFT is expressed as</p>
<p class="caption"><a id="calibre_link-1806"></a>(11-19)</p>
<p class="image"><img src="images/000101.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Accordingly, if we average the magnitudes of <em class="calibre7">k</em> separate FFTs, we reduce the noise variance by a factor of <em class="calibre7">k</em>.</p>
<p class="calibre3">In practice, when multiple FFTs are averaged and the FFT inputs are windowed, an overlap in the time-domain sampling process is commonly used. <a href="#calibre_link-1805">Figure 11-7</a> illustrates this concept with 5.5<em class="calibre7">Nt<sub class="calibre12">s</sub></em> seconds, worth of time series data samples, and we wish to average ten separate <em class="calibre7">N</em>-point FFTs where <em class="calibre7">t<sub class="calibre12">s</sub></em> is the sample period (1/<em class="calibre7">f<sub class="calibre12">s</sub></em>). Because the FFTs have a 50 percent overlap in the time domain, some of the input noise in the <em class="calibre7">N</em> time samples for the first FFT will also be contained in the second FFT. The question is “What’s the <a id="calibre_link-2355"></a>noise variance reduction when some of the noise is common to two FFTs in this averaging scheme?” Well, the answer depends on the window function used on the data before the FFTs are performed. It has been shown that for the most common window functions using an overlap of 50 percent or less, <a href="#calibre_link-1806">Eq. (11-19)</a> still applies as the level of noise variance reduction<a href="#calibre_link-1807">[7]</a>.</p>
<p class="caption"><a id="calibre_link-1805"></a><strong class="calibre9">Figure 11-7</strong> Time relationship of multiple FFTs with 50 percent overlap.</p>
<p class="image"><img src="images/000611.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Coherent FFT integration gain is possible when we average the real parts of multiple FFT bin outputs separately from computing the average of the imaginary parts. We can then combine the single real average and the single imaginary average into a single complex bin output average value. While this process may be useful for people who use analog sinewave signals to test the performance of A/D converters using the FFT, it only works for periodic time-domain signal sequences that have been obtained through careful synchronous sampling. Coherent integration of multiple FFT results is of no value in reducing spectral measurement noise for nonperiodic, real-world, information-carrying signals.</p>
<p class="calibre3"><a id="calibre_link-666"></a></p>
<h3 class="calibre6">11.4 Averaging Phase Angles</h3>
<p class="calibre3">So far we’ve discussed averaging time-domain signal amplitude samples and averaging frequency-domain magnitude samples. It’s prudent now to briefly discuss the <em class="calibre7">tricky</em> aspect of averaging phase-angle samples. We say tricky because, as Peter Kootsookos points out, the circular (wraparound) nature of angles can lead us into trouble when computing phase averages<a href="#calibre_link-1808">[8]</a>.</p>
<p class="calibre3">Consider computing the average of two phase angles, α = 7π/8 radians and β = &ndash;7π/8 radians. Due to the directional nature of phase angles, we know the average of α and β is an angle exactly halfway between 7π/8 radians and &ndash;7π/8 radians, or ±π radians (±180 degrees). However, standard numerical averaging of the two scalar radian values 7π/8 and &ndash;7π/8 results in zero radians (0 degrees), which is obviously incorrect.</p>
<p class="calibre3">The solution to this dilemma is to treat the two phase angles as the arguments of two complex numbers, add the two complex numbers, and determine the sum’s argument (angle) to obtain the desired average phase angle. That is,</p>
<p class="caption"><a id="calibre_link-1809"></a>(11-20)</p>
<p class="image"><img src="images/000940.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where the notation “arg[<em class="calibre7">e<sup class="calibre10">jq</sup></em>]” means the phase angle of complex number <em class="calibre7">e<sup class="calibre10">jq</sup></em>. Of course, the complex addition in <a href="#calibre_link-1809">Eq. (11-20)</a> is performed in rectangular form.</p>
<p class="calibre3">As an example, the average of phase angles α = 7π/8 radians and β = &ndash;7π/8 radians is found by first computing the sum:</p>
<p class="caption"><a id="calibre_link-2383"></a><a id="calibre_link-1810"></a>(11-20′)</p>
<p class="image"><img src="images/001804.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">So, from <a href="#calibre_link-1810">Eq. (11-20′)</a>, our average phase angle is ±π radians (±180 degrees).</p>
<p class="calibre3"><a id="calibre_link-667"></a></p>
<h3 class="calibre6">11.5 Filtering Aspects of Time-Domain Averaging</h3>
<p class="calibre3">To reinforce our concept of signal averaging, let’s reiterate that we want to improve the accuracy (the <em class="calibre7">correctness</em>) of our measurement of some physical quantity, but our repeated measurements (signal level samples) are contaminated by random noise as shown in <a href="#calibre_link-1811">Figure 11-8</a>. That random noise can be inherent in the physical quantity that we’re measuring, or it could be caused by an imperfect measurement device (transducer). Sadly, both of these sources of random noise are usually present in our real-world signal measurement activities.</p>
<p class="caption"><a id="calibre_link-1811"></a><strong class="calibre9">Figure 11-8</strong> A constant-level signal contaminated by random noise.</p>
<p class="image"><img src="images/001469.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Of course, we can improve the accuracy of our estimation of the <em class="calibre7">true signal level</em> in <a href="#calibre_link-1811">Figure 11-8</a> by summing a block of 100 measurement values and dividing that sum by 100, which gives us a single 100-point average estimate of the true signal level. However, in a real-time scenario we’d have to wait another 100-sample time interval (100/<em class="calibre7">f<sub class="calibre12">s</sub></em>) before we could compute a new estimated true signal level. To compute real-time signal averages at a sample rate of <em class="calibre7">f<sub class="calibre12">s</sub></em> Hz (computing a new average value upon the arrival of each new measurement value), we use digital filters.</p>
<p class="calibre3"><a id="calibre_link-3121"></a>In <a href="#calibre_link-609">Section 5.2</a> we introduced nonrecursive FIR filters with a moving average example, and there we learned that time-domain averaging performs lowpass filtering. <a href="#calibre_link-1812">Figure 11-9(a)</a> shows an <em class="calibre7">N</em>-point nonrecursive moving averager implemented with an <em class="calibre7">N</em>-tap FIR filter structure. The <em class="calibre7">N</em>-point nonrecursive moving averager’s output in time is expressed as</p>
<p class="caption"><a id="calibre_link-3122"></a>(11-21)</p>
<p class="image"><img src="images/000829.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-1812"></a><strong class="calibre9">Figure 11-9</strong> <em class="calibre7">N</em>-point moving averagers: (a) nonrecursive; (b) recursive; (c) <em class="calibre7">N</em> = 4 impulse response; (d) <em class="calibre7">N</em> = 4 <em class="calibre7">z</em>-plane zeros locations.</p>
<p class="image"><img src="images/000506.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">while its <em class="calibre7">z</em>-domain transfer function is</p>
<p class="caption"><a id="calibre_link-3123"></a>(11-22)</p>
<p class="image"><img src="images/001690.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where the “ma” subscript means moving average.</p>
<p class="calibre3"><a href="#calibre_link-1812">Figure 11-9(b)</a> illustrates an <em class="calibre7">N</em>-point recursive moving averager. The recursive moving averager has the sweet advantage that only two additions are <a id="calibre_link-2382"></a>required per output sample, regardless of the number of delay elements. (So a 100-point moving averager, for example, can be built that requires only two adds per output sample.) (Some people refer to both of our moving averagers as “boxcar averagers.”)</p>
<p class="calibre3">An <em class="calibre7">N</em>-point recursive moving averager’s difference equation is</p>
<p class="caption"><a id="calibre_link-3124"></a>(11-23)</p>
<p class="image"><img src="images/001171.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">while its <em class="calibre7">z</em>-domain transfer function is</p>
<p class="caption"><a id="calibre_link-3125"></a>(11-24)</p>
<p class="image"><img src="images/000003.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where the “rma” subscript means recursive moving average.</p>
<p class="calibre3">The nonrecursive and recursive moving averagers have identical time-domain impulse responses and identical linear-phase frequency responses. As such, <em class="calibre7">H</em><sub class="calibre12">ma</sub>(<em class="calibre7">z</em>) = <em class="calibre7">H</em><sub class="calibre12">rma</sub>(<em class="calibre7">z</em>). The nonrecursive and recursive moving averagers are merely two different implementations of the process known as an “<em class="calibre7">N</em>-point moving average.” The unit impulse response and <em class="calibre7">z</em>-plane pole/zero plot of <em class="calibre7">N</em> = 4 moving averagers are provided in <a href="#calibre_link-1812">Figures 11-9(c)</a> and <a href="#calibre_link-1812">11-9(d)</a>.</p>
<p class="calibre3">Please be aware of two issues regarding the nonrecursive and recursive moving averagers. First, the delay line of the nonrecursive moving averager will have <em class="calibre7">N</em>&ndash;1 delay elements, while the recursive moving averager will have <em class="calibre7">N</em> delay elements. Second, the feedback in the recursive moving averager means that, given certain <em class="calibre7">x</em>(<em class="calibre7">n</em>) signals, the <em class="calibre7">y</em>(<em class="calibre7">n</em>) output sequence can grow large in magnitude. This means that when implementing a recursive moving averager in fixed-point binary hardware we must test the process against our expected input signals to determine if binary overflow errors occur at the output of the second adder.</p>
<p class="calibre3">An agreeable feature of the moving averagers is that when <em class="calibre7">N</em> is an integer power of two, the multiplications by 1/<em class="calibre7">N</em> in <a href="#calibre_link-1812">Figure 11-9</a> can be implemented with binary arithmetic right shifts, thus eliminating the multipliers altogether.</p>
<p class="calibre3">Both moving averagers have identical frequency magnitude responses, given by</p>
<p class="caption"><a id="calibre_link-1813"></a>(11-25)</p>
<p class="image"><img src="images/001233.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where the normalized frequency variable <em class="calibre7">f</em> is in the range of &ndash;0.5 to 0.5 corresponding to a continuous-time frequency range of &ndash;<em class="calibre7">f<sub class="calibre12">s</sub></em>/2 to <em class="calibre7">f<sub class="calibre12">s</sub></em>/2 Hz. (We derived <a href="#calibre_link-1813">Eq. (11-25)</a> in <a href="#calibre_link-1653">Section 7.5.1</a> when <em class="calibre7">k</em> = 0, and in <a href="#calibre_link-1814">Section 10.14.2</a>.) That <a id="calibre_link-3126"></a>response shows us why the averagers’ outputs have reduced noise fluctuations. <a href="#calibre_link-1815">Figure 11-10</a> depicts a moving averaging filter’s frequency magnitude responses for various values of <em class="calibre7">N</em>. Those curves are approximated by the sin(<em class="calibre7">x</em>)/<em class="calibre7">x</em>-like curves we encountered so often in <a href="#calibre_link-134">Chapter 3</a> because they are the discrete Fourier transform (DFT) of an averager’s rectangular time-domain impulse responses.</p>
<p class="caption"><a id="calibre_link-1815"></a><strong class="calibre9">Figure 11-10</strong> <em class="calibre7">N</em>-point moving averager frequency magnitude response as a function of <em class="calibre7">N</em>.</p>
<p class="image"><img src="images/001367.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">In <a href="#calibre_link-1815">Figure 11-10</a> we see the moving average filter has a passband centered at zero Hz, and as <em class="calibre7">N</em> increases, the filter becomes more and more narrowband, attenuating more and more of the noise spectrum of an input signal. The frequencies of the response nulls in <a href="#calibre_link-1815">Figure 11-10</a> for <em class="calibre7">N</em> = 4 (±<em class="calibre7">f<sub class="calibre12">s</sub></em>/4 and <em class="calibre7">f<sub class="calibre12">s</sub></em>/2) correspond to the locations of the <em class="calibre7">z</em>-plane zeros on the unit circle in <a href="#calibre_link-1812">Figure 11-9(d)</a>. In the general case, the <em class="calibre7">z</em>-plane zeros on the unit circle for an <em class="calibre7">N</em>-point moving averager will be located at angles</p>
<p class="caption"><a id="calibre_link-3127"></a>(11-26)</p>
<p class="image"><img src="images/001248.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">corresponding to magnitude response nulls at frequencies</p>
<p class="caption"><a id="calibre_link-3128"></a>(11-26′)</p>
<p class="image"><img src="images/001020.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where <em class="calibre7">k</em> = 1, 2, 3, ..., <em class="calibre7">N</em>&ndash;1.</p>
<p class="calibre3">The output variance (noise power) properties of both moving averagers abide by the important relationship of</p>
<p class="caption"><a id="calibre_link-3129"></a>(11-27)</p>
<p class="image"><img src="images/001046.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2181"></a>While used in many applications seeking noise reduction through real-time averaging, the above moving averagers have two shortcomings. First, the number of points in the average, <em class="calibre7">N</em>, must be an integer, so if we desired a noise-reducing frequency response somewhere between, say, <em class="calibre7">N</em> = 4 and <em class="calibre7">N</em> = 5 in <a href="#calibre_link-1815">Figure 11-10</a>, we’re out of luck. Second, in real-time applications, these averagers are sluggish (slow) in their time response to abrupt amplitude changes in an input signal. One popular solution to these shortcomings is the computationally efficient <em class="calibre7">exponential averager</em>. Please read on.</p>
<p class="calibre3"><a id="calibre_link-668"></a></p>
<h3 class="calibre6">11.6 Exponential Averaging</h3>
<p class="calibre3">There is a kind of time-domain averaging that’s used in many applications&mdash;it’s called <em class="calibre7">exponential averaging</em>[<a href="#calibre_link-1816">9</a>&ndash;<a href="#calibre_link-1817">12</a>]. This noise-reduction process, occasionally called <em class="calibre7">exponential smoothing,</em> uses a simple recursive lowpass filter described by the difference equation</p>
<p class="caption"><a id="calibre_link-1818"></a>(11-28)</p>
<p class="image"><img src="images/001005.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where <em class="calibre7">y</em>(<em class="calibre7">n</em>) is the current averager output sample, <em class="calibre7">y</em>(<em class="calibre7">n</em>&ndash;1) is the previous averager output sample, and α is a constant <em class="calibre7">weighting factor</em> in the range 0 &lt; α &lt; 1. The process described by <a href="#calibre_link-1818">Eq. (11-28)</a> is implemented as shown in <a href="#calibre_link-1819">Figure 11-11</a>.</p>
<p class="caption"><a id="calibre_link-1819"></a><strong class="calibre9">Figure 11-11</strong> Exponential averager.</p>
<p class="image"><img src="images/000405.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">With regard to noise-reduction filtering, the exponential averager has three very appealing properties. First, unlike the nonrecursive and recursive moving averagers described in the last section, the exponential averager permits meaningful control over its frequency response, i.e., its noise-reduction behavior. Second, the exponential averager requires fewer computations per output sample than standard nonrecursive moving averagers; and third, the exponential averager has greatly reduced memory requirements. Only one delay element, i.e., one memory location, is needed by the exponential averager to store the <em class="calibre7">y</em>(<em class="calibre7">n</em>&ndash;1) sample.</p>
<p class="calibre3">The multiply by α operation could be placed after rather than before the feedback network, if we chose to do so.</p>
<p class="calibre3"><a id="calibre_link-3130"></a></p>
<h4 class="calibre13"><a id="calibre_link-2427"></a>11.6.1 Time-Domain Filter Behavior</h4>
<p class="calibre3">The exponential averager’s name stems from its time-domain impulse response. Let’s assume that the input to the averager is a long string of zeros, and we apply a single sample of value 1 at time <em class="calibre7">n</em> = 0. Then the input returns again to a string of zero-valued samples. Now if the weighting factor is α = 0.4, the averager’s output is the impulse response sequence in <a href="#calibre_link-1820">Figure 11-12</a>. When <em class="calibre7">n</em> = 0, the input sample is multiplied by α, so the output is 0.4. On the next clock cycle, the input is zero, and the old value of 0.4 is multiplied by (1 − 0.4), or 0.6 multiplied by (1 − 0.4), or 0.6 to provide an output of 0.24. On the following clock cycle the input is zero and the previous output of 0.24 is multiplied by 0.6 to provide a new output of 0.144. This continues with the averager’s impulse response output falling off exponentially because of the successive multiplications by 0.6.<sup class="calibre10"><a id="calibre_link-1822"></a><a href="#calibre_link-1821">†</a></sup></p>
<p class="footnotes"><a id="calibre_link-1821"></a><sup class="calibre11"><a href="#calibre_link-1822">†</a></sup> We often see exponential decay in nature&mdash;everywhere from a capacitor discharging through a resistor, the flow of heat, to the shrinkage of bubbles in a glass of beer. (See reference <a href="#calibre_link-1823">[13]</a>.)</p>
<p class="caption"><a id="calibre_link-1820"></a><strong class="calibre9">Figure 11-12</strong> Exponential averager impulse response with α = 0.4.</p>
<p class="image"><img src="images/001256.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">A useful feature of the exponential averager is its capability to vary the amount of noise reduction by changing the value of the α weighting factor. If α equals one, input samples are not attenuated, past averager outputs are ignored, and no averaging takes place. In this case the averager output responds immediately to changes at the input. As α is decreased in value, input samples are attenuated and past averager outputs begin to affect the present output. These past values represent an exponentially weighted sum of recent inputs, and that summation tends to smooth out noisy signals. The smaller α gets, the more noise reduction is realized. However, with smaller values for α, the slower the averager is in responding to changes in the input. We can demonstrate this behavior by looking at the exponential averager’s time-domain step response as a function of α as shown in <a href="#calibre_link-1824">Figure 11-13</a>.</p>
<p class="caption"><a id="calibre_link-3131"></a><a id="calibre_link-1824"></a><strong class="calibre9">Figure 11-13</strong> Exponential averager output versus α when a step input is applied at time <em class="calibre7">n</em> = 0.</p>
<p class="image"><img src="images/000293.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">As so often happens in signal processing, we have a trade-off. The more the noise reduction, the more sluggish the averager will be in responding to abrupt changes at the input. We can see in <a href="#calibre_link-1824">Figure 11-13</a> that as α gets smaller, affording better noise reduction, the averager’s output takes longer to respond and stabilize. Some test instrumentation manufacturers use a clever scheme to resolve this noise reduction versus response time trade-off. They use a large value for α at the beginning of a measurement so the averager’s output responds immediately with a nonzero value. Then as the measurement proceeds, the value of α is decreased in order to reduce the noise fluctuations at the input.</p>
<p class="calibre3">The exponential averager’s noise variance reduction as a function of the weighting factor α has been shown to be[<a href="#calibre_link-1825">10</a>,<a href="#calibre_link-1826">11</a>]</p>
<p class="caption"><a id="calibre_link-1827"></a>(11-29)</p>
<p class="image"><img src="images/000137.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a href="#calibre_link-1827">Equation (11-29)</a> is useful because it allows us to determine α given some desired averager noise variance (power) reduction. That is, if our desired noise variance reduction factor is <em class="calibre7">R</em>, where <em class="calibre7">R</em> = (2 − α)/α, we can write</p>
<p class="caption"><a id="calibre_link-3132"></a>(11-30)</p>
<p class="image"><img src="images/001133.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3133"></a>For example, if we want the output noise variance reduced by a factor of <em class="calibre7">R</em> = 10, then α = 2/(10+1) = 0.182. The behavior of exponential averaging is such that to achieve noise reduction roughly equivalent to an <em class="calibre7">N</em>-point moving averager, we define α as</p>
<p class="caption"><a id="calibre_link-3134"></a>(11-31)</p>
<p class="image"><img src="images/001628.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Considering the exponential averager’s noise power reduction in <a href="#calibre_link-1827">Eq. (11-29)</a> as an output signal-to-noise (SNR) increase, we can say the averager’s output SNR increase (in dB) is</p>
<p class="caption"><a id="calibre_link-1828"></a>(11-32)</p>
<p class="image"><img src="images/000202.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a href="#calibre_link-1828">Equation (11-32)</a> is plotted in <a href="#calibre_link-1829">Figure 11-14</a> to illustrate the trade-off between output noise reduction and averager response times.</p>
<p class="caption"><a id="calibre_link-1829"></a><strong class="calibre9">Figure 11-14</strong> Exponential averager output SNR increase as a function of the weighting factor α.</p>
<p class="image"><img src="images/001135.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">To demonstrate the exponential averager’s output noise power reduction capabilities, <a href="#calibre_link-1830">Figure 11-15</a> shows the averager’s output with a low-frequency (relative to the sample rate) cosine wave plus high-level noise as an input. The weighting factor α starts out with a value of 1 and decreases linearly to a final value of 0.1 at the 180th data input sample. Notice that the noise is reduced as α decreases.</p>
<p class="caption"><a id="calibre_link-2254"></a><a id="calibre_link-1830"></a><strong class="calibre9">Figure 11-15</strong> Exponential averager output noise reduction as α decreases.</p>
<p class="image"><img src="images/000183.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3135"></a></p>
<h4 class="calibre13">11.6.2 Frequency-Domain Filter Behavior</h4>
<p class="calibre3">The reader may recognize the exponential averager as a 1st-order infinite impulse response (IIR) digital filter. It has a <em class="calibre7">z</em>-domain transfer function of</p>
<p class="caption"><a id="calibre_link-1832"></a>(11-33)</p>
<p class="image"><img src="images/001643.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Being a 1st-order IIR filter, the exponential averager has a single pole on the <em class="calibre7">z</em>-plane located at <em class="calibre7">z</em> = 1&ndash;α as shown in <a href="#calibre_link-1831">Figure 11-16</a>. When α is reduced in value, the pole resides closer to the <em class="calibre7">z</em>-plane’s unit circle, giving us a narrower lowpass passband width.</p>
<p class="caption"><a id="calibre_link-1831"></a><strong class="calibre9">Figure 11-16</strong> Exponential averager <em class="calibre7">z</em>-plane pole location.</p>
<p class="image"><img src="images/001598.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Setting <em class="calibre7">z</em> in <a href="#calibre_link-1832">Eq. (11-33)</a> equal to <em class="calibre7">e</em><sup class="calibre10"><em class="calibre7">j</em>ω</sup>, we can write the frequency response of the exponential averager as</p>
<p class="caption"><a id="calibre_link-3136"></a>(11-34)</p>
<p class="image"><img src="images/001254.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3137"></a>If we’re interested in the magnitude response of our averager, we can express it as</p>
<p class="caption"><a id="calibre_link-1833"></a>(11-35)</p>
<p class="image"><img src="images/000275.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Evaluating <a href="#calibre_link-1833">Eq. (11-35)</a> over the normalized angular range of 0 ≤ ω ≤ π (corresponding to a continuous-time frequency range of 0 to <em class="calibre7">f<sub class="calibre12">s</sub></em>/2 Hz), the frequency magnitude responses of our exponential averager for various values of α are shown in <a href="#calibre_link-1834">Figure 11-17(a)</a>. There we see that the averager’s DC gain, its gain at zero Hz, is unity, which is just what we want for our noise-reduction applications. It’s worth noting that if we can tolerate a DC gain of 1/α, the multiply by α in <a href="#calibre_link-1819">Figure 11-11</a> can be eliminated to reduce the averager’s computational workload.</p>
<p class="caption"><a id="calibre_link-1834"></a><strong class="calibre9">Figure 11-17</strong> Exponential averager frequency response versus α: (a) normalized magnitude response (linear); (b) normalized magnitude response in dB; (c) phase response in degrees.</p>
<p class="image"><img src="images/001614.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2360"></a>The exponential averager’s magnitude responses plotted on a logarithmic scale (dB) are provided in <a href="#calibre_link-1834">Figure 11-17(b)</a>. Notice as α decreases, the exponential averager behaves more and more like a lowpass filter. Again, it is from this behavior that the exponential averager’s noise-reduction properties stem.</p>
<p class="calibre3">For those readers who prefer to think of a lowpass filter in terms of its 3 dB bandwidth, we can compute the appropriate value of the weighting factor α to achieve a desired exponential averaging filter 3 dB bandwidth. If <em class="calibre7">f</em><sub class="calibre12">c</sub> is the desired positive <em class="calibre7">cutoff</em> frequency in Hz, where the exponential averager’s frequency magnitude response is 3 dB below the averager’s zero-Hz response, the value of α needed to achieve such an <em class="calibre7">f</em><sub class="calibre12">c</sub> cutoff frequency is</p>
<p class="caption"><a id="calibre_link-3138"></a>(11-36)</p>
<p class="image"><img src="images/001312.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where <em class="calibre7">f<sub class="calibre12">s</sub></em> is the averager’s input sample rate in Hz.</p>
<p class="calibre3">To comment on the exponential averager’s nonlinear phase response: We’re primarily concerned with the averager’s frequency response at zero Hz. We want the averager to pass a zero-Hz (constant-amplitude) signal and attenuate noise fluctuations riding on the constant-amplitude signal of interest. As such, the exponential averager’s phase nonlinearity is usually of little consequence.</p>
<p class="calibre3"><a id="calibre_link-3139"></a></p>
<h4 class="calibre13">11.6.3 Exponential Averager Application</h4>
<p class="calibre3">I first encountered the exponential averager as lowpass filter in a specialized real-time hardware spectrum analyzer application. That analyzer, using the fast Fourier transform (FFT) shown in <a href="#calibre_link-1835">Figure 11-18</a>, was similar in operation to a graphics equalizer in home stereo systems. As <em class="calibre7">P</em> spectral power estimates were displayed on a computer monitor in real time, the common weighting factor α (used by each exponential averager) could be increased to speed the display’s response to abrupt changes in the spectral content in <em class="calibre7">x</em>(<em class="calibre7">n</em>). Then again, α could be reduced to minimize abrupt fluctuations (reduced variance) in the <em class="calibre7">P</em> power samples, yielding a slowly changing (sluggish) spectral display. The notation in <a href="#calibre_link-1835">Figure 11-18</a> is such that <em class="calibre7">X<sub class="calibre12">p</sub></em>(<em class="calibre7">n</em>) represents the <em class="calibre7">p</em>th FFT bin’s complex sample value at the <em class="calibre7">n</em>th instant in time.</p>
<p class="caption"><a id="calibre_link-1835"></a><strong class="calibre9">Figure 11-18</strong> An application of exponential averaging.</p>
<p class="image"><img src="images/001480.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">In this application the exponential averagers were referred to as “leaky integrators” and, again, their nonlinear phase was unimportant. Their only purpose in life was to reduce the fluctuations in the real-time |<em class="calibre7">X<sub class="calibre12">p</sub></em>(<em class="calibre7">n</em>)|<sup class="calibre10">2</sup> power samples by means of lowpass filtering.</p>
<p class="calibre3">As an example of their utility, exponential averagers are used when we swipe our charge cards through a magnetic stripe reader (MSR). The analog signal from the magnetic read head is digitized with an A/D converter, and <a id="calibre_link-3140"></a>the discrete samples are exponentially averaged before the binary data (ones and zeros) detection process is performed<a href="#calibre_link-1836">[14]</a>.</p>
<p class="calibre3">To conclude this section, we inform the reader that <a href="#calibre_link-702">Section 13.33</a> presents computationally efficient implementations of exponential averagers.</p>
<p class="calibre3"><a id="calibre_link-669"></a></p>
<h3 class="calibre6">References</h3>
<p class="chapterendnote"><a id="calibre_link-1783"></a>[1] Miller, I., and Freund, J. <em class="calibre7">Probability and Statistics for Engineers</em>, 2nd ed., Prentice Hall, Englewood Cliffs, New Jersey, 1977, p. 118.</p>
<p class="chapterendnote"><a id="calibre_link-3141"></a>[2] Beller, J., and Pless, W. “A Modular All-Haul Optical Time-Domain Reflectometer for Characterizing Fiber Links,” <em class="calibre7">Hewlett</em>-<em class="calibre7">Packard Journal</em>, February 1993.</p>
<p class="chapterendnote"><a id="calibre_link-3142"></a>[3] Spiegel, M. R. <em class="calibre7">Theory and Problems of Statistics</em>, Shaum’s Outline Series, McGraw-Hill, New York, 1961, p. 142.</p>
<p class="chapterendnote"><a id="calibre_link-3143"></a>[4] Papoulis, A. <em class="calibre7">Probability, Random Variables, and Stochastic Processes</em>, McGraw-Hill, New York, 1984, p. 245.</p>
<p class="chapterendnote"><a id="calibre_link-1784"></a>[5] Davenport, W. B., Jr., and Root, W. L. <em class="calibre7">Random Signals and Noise</em>, McGraw-Hill, New York, 1958, pp. 81&ndash;84.</p>
<p class="chapterendnote"><a id="calibre_link-1804"></a>[6] Welch, P. D. “The Use of Fast Fourier Transform for the Estimation of Power Spectra: A Method Based on Time Averaging over Short, Modified Periodograms,” <em class="calibre7">IEEE Transactions on Audio and Electroacoust.,</em> Vol. AU-15, No. 2, June 1967.</p>
<p class="chapterendnote"><a id="calibre_link-1807"></a>[7] Harris, F. J. “On the Use of Windows for Harmonic Analysis with the Discrete Fourier Transform,” <em class="calibre7">Proceedings of the IEEE,</em> Vol. 66, No. 1, January 1978.</p>
<p class="chapterendnote"><a id="calibre_link-1808"></a>[8] Kootsookos, P. “The Nature of Circles,” DSPrelated blog, <a href="http://www.dsprelated.com/showarticle/57.php">http://www.dsprelated.com/showarticle/57.php</a>.</p>
<p class="chapterendnote"><a id="calibre_link-3144"></a><a id="calibre_link-1816"></a>[9] Booster, D. H., et al. “Design of a Precision Optical Low-Coherence Reflectometer,” <em class="calibre7">Hewlett</em>-<em class="calibre7">Packard Journal</em>, February 1993.</p>
<p class="chapterendnote"><a id="calibre_link-1825"></a>[10] Witte, R. A. “Averaging Techniques Reduce Test Noise, Improve Accuracy,” <em class="calibre7">Microwaves &amp; RF</em>, February 1988.</p>
<p class="chapterendnote"><a id="calibre_link-1826"></a>[11] Oxaal, J. “Temporal Averaging Techniques Reduce Image Noise,” <em class="calibre7">EDN</em>, March 17, 1983.</p>
<p class="chapterendnote"><a id="calibre_link-1817"></a>[12] Lymer, A. “Digital-Modulation Scheme Processes RF Broadcast Signals,” <em class="calibre7">Microwaves &amp; RF</em>, April 1994.</p>
<p class="chapterendnote"><a id="calibre_link-1823"></a>[13] Leike, A. “Demonstration of the Exponential Decay Law Using Beer Froth,” <em class="calibre7">European Journal of Physics</em>, Vol. 23, January 2002, pp. 21&ndash;26.</p>
<p class="chapterendnote"><a id="calibre_link-1836"></a>[14] Silicon Laboratories Inc. “Magnetic Stripe Reader,” <em class="calibre7">Application Note: AN148</em>.</p>
<p class="calibre3"><a id="calibre_link-670"></a></p>
<h3 class="calibre6"><a id="calibre_link-3145" class="calibre5"></a>Chapter 11 Problems</h3>
<p class="indenthanging6"><strong class="calibre9">11.1</strong> Assume we have a four-sample <em class="calibre7">x</em>(<em class="calibre7">n</em>) sequence, where index <em class="calibre7">n</em> is 1 ≤ <em class="calibre7">n</em> ≤ 4, whose samples are</p>
<p class="center"><em class="calibre7">x</em>(1) = 1, <em class="calibre7">x</em>(2) = 2, <em class="calibre7">x</em>(3) = 3, <em class="calibre7">x</em>(4) = 4.</p>
<p class="indenthangingn2"><strong class="calibre9">(a)</strong> What is the average of <em class="calibre7">x</em>(<em class="calibre7">n</em>)?</p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> What is the variance of <em class="calibre7">x</em>(<em class="calibre7">n</em>)?</p>
<p class="indenthangingn2"><strong class="calibre9">(c)</strong> What is the standard deviation of <em class="calibre7">x</em>(<em class="calibre7">n</em>)?</p>
<p class="indenthanging6"><strong class="calibre9">11.2</strong> This problem illustrates an important characteristic of the quantity known as the <em class="calibre7">average</em> (mean value) of a sequence of numbers. Suppose we have a six-sample <em class="calibre7">x</em>(<em class="calibre7">n</em>) sequence, where index <em class="calibre7">n</em> is 1 ≤ <em class="calibre7">n</em> ≤ 6, defined by</p>
<p class="center"><em class="calibre7">x</em>(1) = 1, <em class="calibre7">x</em>(2) = &ndash;2, <em class="calibre7">x</em>(3) = 3, <em class="calibre7">x</em>(4) = &ndash;4, <em class="calibre7">x</em>(5) = 6, <em class="calibre7">x</em>(6) = unspecified,</p>
<p class="indentpara5">and the average of <em class="calibre7">x</em>(<em class="calibre7">n</em>) is <em class="calibre7">x</em><sub class="calibre12">ave</sub> = 4. (Note that the sixth sample in <em class="calibre7">x</em>(<em class="calibre7">n</em>) is not explicitly defined.) The difference between <em class="calibre7">x</em>(<em class="calibre7">n</em>) and <em class="calibre7">x</em><sub class="calibre12">ave</sub> is the sequence <em class="calibre7">d</em><sub class="calibre12">iff</sub>(<em class="calibre7">n</em>) = <em class="calibre7">x</em>(<em class="calibre7">n</em>) &ndash; <em class="calibre7">x</em><sub class="calibre12">ave</sub>, given as</p>
<p class="center"><em class="calibre7">d</em><sub class="calibre12">iff</sub>(1) = &ndash;3, <em class="calibre7">d</em><sub class="calibre12">iff</sub>(2) = &ndash;6, <em class="calibre7">d</em><sub class="calibre12">iff</sub>(3) = &ndash;1, <em class="calibre7">d</em><sub class="calibre12">iff</sub>(4) = &ndash;8, <em class="calibre7">d</em><sub class="calibre12">iff</sub>(5) = 2, <em class="calibre7">d</em><sub class="calibre12">iff</sub>(6) = unspecified.</p>
<p class="indenthangingn2"><strong class="calibre9">(a)</strong> What is the value of <em class="calibre7">d</em><sub class="calibre12">iff</sub>(6)? Justify your answer.</p>
<p class="indentpara5"><strong class="calibre9">Hint:</strong> The discussion of sequence averages in <a href="#calibre_link-27">Appendix D</a>’s <a href="#calibre_link-565">Section D.1</a> will be helpful here.</p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> What is the value of <em class="calibre7">x</em>(6)?</p>
<p class="indenthanging6"><strong class="calibre9">11.3</strong> Let’s look at an important topic regarding averaging. Assume we have two <em class="calibre7">N</em>-point discrete sequences, <em class="calibre7">x</em>(<em class="calibre7">n</em>) and <em class="calibre7">y</em>(<em class="calibre7">n</em>), where index <em class="calibre7">n</em> is 1 ≤ <em class="calibre7">n</em> ≤ <em class="calibre7">N</em>, and the <em class="calibre7">N</em>-point averages of the two sequences are</p>
<p class="image"><img src="images/000501.jpg" alt="image" class="calibre2" /></p>
<p class="indentpara5">Next, let’s add the two sequences, element for element, to obtain a new <em class="calibre7">N</em>-point sequence <em class="calibre7">z</em>(<em class="calibre7">n</em>) = <em class="calibre7">x</em>(<em class="calibre7">n</em>) + <em class="calibre7">y</em>(<em class="calibre7">n</em>). Is it correct to say that the average of <em class="calibre7">z</em>(<em class="calibre7">n</em>), defined as</p>
<p class="image"><img src="images/001363.jpg" alt="image" class="calibre2" /></p>
<p class="indentpara5"><a id="calibre_link-3146"></a>is equal to the sum of <em class="calibre7">x</em><sub class="calibre12">ave</sub> and <em class="calibre7">y</em><sub class="calibre12">ave</sub>? (In different words, we’re asking, “Is the average of sums equal to the sum of averages?”) Explain how you arrived at your answer.</p>
<p class="indentpara5"><strong class="calibre9">Note:</strong> This problem is <em class="calibre7">not</em> “busy work.” If the above statement <em class="calibre7">z</em><sub class="calibre12">ave</sub> = <em class="calibre7">x</em><sub class="calibre12">ave</sub> + <em class="calibre7">y</em><sub class="calibre12">ave</sub> is true, it tells us that the average of a noisy signal is equal to the average of the noise-free signal plus the average of the noise.</p>
<p class="indenthanging6"><strong class="calibre9">11.4</strong> Suppose we had three unity-magnitude complex numbers whose phase angles are π/4 radians, &ndash;3π/4 radians, and &ndash;π/4 radians. What is the average phase angle, measured in degrees, of the three phase angles? Show your work.</p>
<p class="indenthanging6"><strong class="calibre9">11.5</strong> Assume we’re averaging magnitude samples from multiple FFTs (fast Fourier transforms) and we want the variance of the <em class="calibre7">averaged FFT magnitudes</em> to be reduced below the variance of single-FFT magnitudes by a factor of 20. That is, we want</p>
<p class="image"><img src="images/000396.jpg" alt="image" class="calibre2" /></p>
<p class="indentpara5">How many FFTs, <em class="calibre7">k</em>, must we compute and then average their magnitude samples?</p>
<p class="indenthanging6"><strong class="calibre9">11.6</strong> Concerning the moving averager filters in the text’s <a href="#calibre_link-1812">Figure 11-9</a>, we stated that their transfer functions are equal. Prove that <em class="calibre7">H</em><sub class="calibre12">ma</sub>(<em class="calibre7">z</em>) = <em class="calibre7">H</em><sub class="calibre12">rma</sub>(<em class="calibre7">z</em>).</p>
<p class="indentpara5"><strong class="calibre9">Hint:</strong> <em class="calibre7">H</em><sub class="calibre12">ma</sub>(<em class="calibre7">z</em>) is a geometric series that we’d like to represent as a closed-form equation. To obtain a closed-form equation for a geometric series, start by looking up <em class="calibre7">geometric series</em> in the Index.</p>
<p class="indenthanging6"><strong class="calibre9">11.7</strong> If we remove the 1/<em class="calibre7">N</em> multiplier from the recursive moving averager in the text’s <a href="#calibre_link-1812">Figure 11-9(b)</a>, the remaining structure is called a <em class="calibre7">recursive running sum.</em> To exercise your digital network analysis skills, plot the frequency magnitude responses of a recursive running sum system for <em class="calibre7">N</em> = 4, 8, and 16 as we did in <a href="#calibre_link-1815">Figure 11-10</a>.</p>
<p class="indentpara5"><strong class="calibre9">Hint:</strong> The frequency response of a recursive running sum network is, of course, the discrete Fourier transform (DFT) of the network’s rectangular impulse response. Note that the recursive running sum network’s magnitude response curves will be similar, but not equal, to the curves in <a href="#calibre_link-1815">Figure 11-10</a>.</p>
<p class="indenthanging6"><strong class="calibre9">11.8</strong> In the text we said that the phase responses of both nonrecursive and recursive <em class="calibre7">N</em>-point moving averagers are linear. Why is it valid to make that statement?</p>
<p class="indenthanging6"><a id="calibre_link-3147"></a><strong class="calibre9">11.9</strong> Draw a rough sketch of the frequency magnitude response, over the positive-frequency range, of a three-point moving averager. Clearly show the frequency magnitude response at <em class="calibre7">f<sub class="calibre12">s</sub></em>/2 Hz.</p>
<p class="indentpara5"><strong class="calibre9">Note:</strong> The locations of the frequency response nulls are defined by the locations of the averager’s transfer function zeros on its <em class="calibre7">z</em>-plane unit circle.</p>
<p class="indenthanging6"><strong class="calibre9">11.10</strong> Think about building a two-stage filter comprising a four-point moving averager in cascade (series) with a two-point moving averager.</p>
<p class="indenthangingn2"><strong class="calibre9">(a)</strong> Draw a rough sketch of the frequency magnitude response of the two-stage filter.</p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> Does the cascaded filter have a linear phase response? Justify your answer.</p>
<p class="indenthanging6"><strong class="calibre9">11.11</strong> Let’s assume we’re measuring a constant-level, but very noisy, temperature signal from a thermocouple and we wish to reduce the noise variance (power) of our measurements by 13 dB.</p>
<p class="indenthangingn2"><strong class="calibre9">(a)</strong> What is the number of delay elements needed in a nonrecursive moving average filter to achieve the desired measurement-noise reduction?</p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> What is the number of delay elements needed in a recursive moving average filter to achieve the desired measurement-noise reduction?</p>
<p class="indenthangingn2"><strong class="calibre9">(c)</strong> What is the value of the α weighting factor in a standard exponential averager to achieve the desired measurement-noise reduction?</p>
<p class="indenthangingn2"><strong class="calibre9">(d)</strong> Fill in the following table describing the implementation requirements to achieve measurement-noise variance reduction of 13 dB.</p>
<p class="indentpara5">Implementation Requirements for 13 dB Noise Reduction</p>
<p class="image"><img src="images/000701.jpg" alt="image" class="calibre2" /></p>
<p class="indenthanging6"><strong class="calibre9">11.12</strong> Regarding the exponential averaging filter, when α = 0, the filter’s single pole lies right on the <em class="calibre7">z</em>-plane unit circle. In <a href="#calibre_link-289">Chapter 6</a> and <a href="#calibre_link-187">Chapter 7</a> we discussed that having digital filter poles on the unit circle can lead to filter stability problems because quantizing a filter’s coefficients to a fixed-width binary <a id="calibre_link-3148"></a>word representation can sometimes cause the poles to reside just outside the unit circle. Why does using α = 0 cause no stability problems for us when we use exponential averagers?</p>
<p class="indenthanging6"><strong class="calibre9">11.13</strong> In the text we stated that an alternate version of an exponential averager, shown in <a href="#calibre_link-1837">Figure P11-13</a>, has a DC (zero Hz) gain of 1/α. Prove that this DC gain factor of 1/α is correct.</p>
<p class="caption"><a id="calibre_link-1837"></a><strong class="calibre9">Figure P11-13</strong></p>
<p class="image"><img src="images/000872.jpg" alt="image" class="calibre2" /></p>
<p class="indenthanging6"><strong class="calibre9">11.14</strong> Show how to derive the equation for the frequency magnitude response of an exponential averager whose weighting factor is α.</p>
<p class="indenthanging6"><strong class="calibre9">11.15</strong> Explain why it’s valid to call the exponential averager in <a href="#calibre_link-1838">Figure P11-15(a)</a>, where for example α = 0.4, by the name <em class="calibre7">leaky integrator</em> compared to a standard (rectangular rule) integrator shown in <a href="#calibre_link-1838">Figure P11-15(b)</a>?</p>
<p class="caption"><a id="calibre_link-1838"></a><strong class="calibre9">Figure P11-15</strong></p>
<p class="image"><img src="images/001729.jpg" alt="image" class="calibre2" /></p>
<p class="indentpara5"><strong class="calibre9">Hint:</strong> Compare the impulse responses of the two networks.</p>
<p class="indenthanging6"><a id="calibre_link-3149"></a><strong class="calibre9">11.16</strong> Here are (somewhat) challenging problems regarding the exponential averager in <a href="#calibre_link-1839">Figure P11-16</a>:</p>
<p class="caption"><a id="calibre_link-1839"></a><strong class="calibre9">Figure P11-16</strong></p>
<p class="image"><img src="images/000752.jpg" alt="image" class="calibre2" /></p>
<p class="indenthangingn2"><strong class="calibre9">(a)</strong> Derive an algebraic expression for the exponential averager’s time-domain response to a unity-valued input sample applied at time <em class="calibre7">n</em> = 0 followed by all zero-valued input samples. Use the term <em class="calibre7">h</em>(<em class="calibre7">n</em>) to represent this <em class="calibre7"><a href="#calibre_link-1064">impulse response</a></em>, where <em class="calibre7">n</em> is the time-domain index. (Assume the output of the <em class="calibre7">z</em><sup class="calibre10">&ndash;1</sup> delay element is zero at time <em class="calibre7">n</em> = 0.)</p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> Use your <em class="calibre7">h</em>(<em class="calibre7">n</em>) expression from Part (a) to determine the exponential averager’s gain at zero Hz (DC gain).</p>
<p class="indentpara5"><strong class="calibre9">Hint:</strong> Recall the relationship between a filter’s impulse response and its gain at zero Hz.</p>
<p class="indenthangingn2"><strong class="calibre9">(c)</strong> Comment on how the value of the α weighting factor affects the averager’s gain at zero Hz (DC gain).</p>
</div>


</body></html>
