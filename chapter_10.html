<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="style.css" rel="stylesheet" type="text/css" /><title>Understanding Digital Signal Processing</title>
<style type="text/css">
body {
  font-family: "BookerlyLCD";
}
a {
  color: #005090;
  text-decoration: none;
}
a {font-variant-numeric: oldstyle-nums proportional-nums;}
p.caption {font-variant-numeric: oldstyle-nums proportional-nums;}
</style>
</head><body>


<div class="calibre" id="calibre_link-572">
<p class="calibre3"><a id="calibre_link-2482"></a></p>
<h2 class="calibre8"><a id="calibre_link-2483" class="calibre5"></a>Contents</h2>
<p class="toc-chapter1"><strong class="calibre9"><a href="#calibre_link-114">10 SAMPLE RATE CONVERSION</a></strong></p>
<p class="toc-section"><a href="#calibre_link-362">10.1 Decimation</a></p>
<p class="toc-section"><a href="#calibre_link-150">10.2 Two-Stage Decimation</a></p>
<p class="toc-section"><a href="#calibre_link-654">10.3 Properties of Downsampling</a></p>
<p class="toc-section"><a href="#calibre_link-655">10.4 Interpolation</a></p>
<p class="toc-section"><a href="#calibre_link-656">10.5 Properties of Interpolation</a></p>
<p class="toc-section"><a href="#calibre_link-657">10.6 Combining Decimation and Interpolation</a></p>
<p class="toc-section"><a href="#calibre_link-121">10.7 Polyphase Filters</a></p>
<p class="toc-section"><a href="#calibre_link-151">10.8 Two-Stage Interpolation</a></p>
<p class="toc-section"><a href="#calibre_link-658">10.9 <em class="calibre7">z</em>-Transform Analysis of Multirate Systems</a></p>
<p class="toc-section"><a href="#calibre_link-248">10.10 Polyphase Filter Implementations</a></p>
<p class="toc-section"><a href="#calibre_link-129">10.11 Sample Rate Conversion by Rational Factors</a></p>
<p class="toc-section"><a href="#calibre_link-659">10.12 Sample Rate Conversion with Half-band Filters</a></p>
<p class="toc-section"><a href="#calibre_link-133">10.13 Sample Rate Conversion with IFIR Filters</a></p>
<p class="toc-section"><a href="#calibre_link-660">10.14 Cascaded Integrator-Comb Filters</a></p>
<p class="toc-section1"><a href="#calibre_link-661">References</a></p>

</div>


<div class="calibre" id="calibre_link-114">
<p class="calibre3"><a id="calibre_link-291"></a></p>
<h2 class="calibre8"><a id="calibre_link-2415" class="calibre5"></a>10 Sample Rate Conversion</h2>
<p class="image"><img src="images/001521.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The useful, and fascinating, process of sample rate conversion is a scheme for changing the effective sampling rate of a discrete time-domain signal sequence. We’ll fully explain that puzzling notion in a moment. But first, know that sample rate conversion has many applications; it’s primarily used to minimize computations by reducing signal data rates when a signal of interest’s bandwidth has been narrowed by lowpass filtering. Sample rate conversion is mandatory in real-time processing when two separate hardware processors operating at two different sample rates must exchange digital signal data. In satellite and medical image processing, sample rate conversion is necessary for image enhancement, scale change, and image rotation. Sample rate conversion is also used to reduce the computational complexity of certain narrowband digital filters.</p>
<p class="calibre3">In this chapter we’ll explore sample rate conversion by first looking at the process by way of a few examples. Then we introduce what are known as polyphase filters. With some knowledge under our belts, next we’ll review the standard mathematical notation used to describe sample rate conversion. Finally, we’ll examine the behavior of specialized digital filters that have found wide use in sample rate conversion applications.</p>
<p class="calibre3">We can define sample rate conversion as follows: Consider the process where a continuous signal <em class="calibre7">x</em>(<em class="calibre7">t</em>) has been sampled at a rate of <em class="calibre7">f</em><sub class="calibre12">s,old</sub> = 1/<em class="calibre7">T</em><sub class="calibre12">old</sub>, and the discrete samples are <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) = <em class="calibre7">x</em>(<em class="calibre7">nT</em><sub class="calibre12">old</sub>). Sample rate conversion is necessary when we need <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">n</em>) = <em class="calibre7">x</em>(<em class="calibre7">nT</em><sub class="calibre12">new</sub>), and direct sampling of the continuous <em class="calibre7">x</em>(<em class="calibre7">t</em>) at the rate of <em class="calibre7">f</em><sub class="calibre12">s,new</sub> = 1/<em class="calibre7">T</em><sub class="calibre12">new</sub> is not possible. For example, imagine we have an analog-to-digital (A/D) conversion system supplying a sample value every <em class="calibre7">T</em><sub class="calibre12">old</sub> seconds. But our processor can only accept data at a rate of one sample every <em class="calibre7">T</em><sub class="calibre12">new</sub> seconds. How do we obtain <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">n</em>) directly from <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>)? One <a id="calibre_link-2109"></a>possibility is to digital-to-analog (D/A) convert the <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) sequence to regenerate the continuous <em class="calibre7">x</em>(<em class="calibre7">t</em>) and then A/D convert <em class="calibre7">x</em>(<em class="calibre7">t</em>) at a sampling rate of <em class="calibre7">f</em><sub class="calibre12">s,new</sub> to obtain <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">n</em>). Due to the spectral distortions induced by D/A followed by A/D conversion, this technique limits our effective dynamic range and is typically avoided in practice. Fortunately, accurate all-digital sample rate conversion schemes have been developed, as we shall see.</p>
<p class="calibre3">Sampling rate changes come in two flavors: rate decreases and rate increases. Decreasing the sampling rate is typically called <em class="calibre7">decimation</em>. When the sampling rate is being increased, the process is known as <em class="calibre7">interpolation</em>, i.e., computing intermediate sample values. Because decimation is the simpler of the two sample rate change operations, let’s examine it first.</p>
<p class="calibre3"><a id="calibre_link-362"></a></p>
<h3 class="calibre6">10.1 Decimation</h3>
<p class="calibre3">Decimation is the two-step process of lowpass filtering followed by an operation known as <em class="calibre7">downsampling</em>. Let’s first consider the notion of downsampling. We can downsample a sequence of sampled signal values by a factor of <em class="calibre7">M</em> by retaining every <em class="calibre7">M</em>th sample and discarding all the remaining samples. Relative to the original sample rate, <em class="calibre7">f</em><sub class="calibre12">s,old</sub>, the sample rate of the downsampled sequence is</p>
<p class="caption"><a id="calibre_link-3013"></a>(10-1)</p>
<p class="image"><img src="images/001578.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">For example, assume that an analog sinewave <em class="calibre7">x</em>(<em class="calibre7">t</em>) has been sampled to produce the <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) sequence shown in <a href="#calibre_link-115">Figure 10-1(a)</a>. To downsample <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) by a factor of <em class="calibre7">M</em> = 3, we retain <em class="calibre7">x</em><sub class="calibre12">old</sub>(0) and discard <em class="calibre7">x</em><sub class="calibre12">old</sub>(1) and <em class="calibre7">x</em><sub class="calibre12">old</sub>(2), retain <a id="calibre_link-3014"></a><em class="calibre7">x</em><sub class="calibre12">old</sub>(3) and discard <em class="calibre7">x</em><sub class="calibre12">old</sub>(4) and <em class="calibre7">x</em><sub class="calibre12">old</sub>(5), retain <em class="calibre7">x</em><sub class="calibre12">old</sub>(6), and so on as shown in <a href="#calibre_link-115">Figure 10-1(b)</a>. Mathematically, we describe the downsampled sequence as</p>
<p class="caption"><a id="calibre_link-116"></a>(10-1′)</p>
<p class="image"><img src="images/001685.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-115"></a><strong class="calibre9">Figure 10-1</strong> Sample rate conversion: (a) original sequence; (b) downsampled by <em class="calibre7">M</em> = 3 sequence.</p>
<p class="image"><img src="images/000556.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where <em class="calibre7">M</em> = 3, and <em class="calibre7">m</em> = 0, 1, 2, 3, etc.</p>
<p class="calibre3">Notice in <a href="#calibre_link-116">Eq. (10-1′)</a> that we’re using an alternate time index variable <em class="calibre7">m</em>, rather than <em class="calibre7">n</em>, in <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">m</em>) to remind us that the time period between the <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">m</em>) samples is different from the time period between the <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) samples. That is, the absolute time instant corresponding to <em class="calibre7">m</em> = 3 is not equal to the absolute time instant corresponding to <em class="calibre7">n</em> = 3.</p>
<p class="calibre3">The spectral implications of downsampling are what we should expect as shown in <a href="#calibre_link-117">Figure 10-2</a>, where the spectrum of an original band-limited sampled <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) signal is indicated by the solid lines, and the spectral replications are indicated by the dashed lines. With <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">m</em>) = <em class="calibre7">x</em><sub class="calibre12">old</sub>(3<em class="calibre7">n</em>), <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">m</em>)’s spectrum, <em class="calibre7">X</em><sub class="calibre12">new</sub>(<em class="calibre7">f</em>), is shown in <a href="#calibre_link-117">Figure 10-2(b)</a>. Two important features are <a id="calibre_link-2114"></a>illustrated in <a href="#calibre_link-117">Figure 10-2</a>. First, <em class="calibre7">X</em><sub class="calibre12">new</sub>(<em class="calibre7">f</em>) could have been obtained directly by sampling the original continuous <em class="calibre7">x</em>(<em class="calibre7">t</em>) signal at a rate of <em class="calibre7">f</em><sub class="calibre12">s,new</sub>, as opposed to downsampling <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) by a factor of three. Second, there is a limit to the amount of downsampling that can be performed relative to the bandwidth <em class="calibre7">B</em> of the original signal. We must ensure that <em class="calibre7">f</em><sub class="calibre12">s,new</sub> &gt; 2<em class="calibre7">B</em> to prevent overlapped spectral replications (aliasing errors) after downsampling.</p>
<p class="caption"><a id="calibre_link-117"></a><strong class="calibre9">Figure 10-2</strong> Decimation by a factor of three: (a) spectrum of original <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) signal; (b) spectrum after downsampling by three; (c) bandwidth <em class="calibre7">B</em>′ is to be retained; (d) lowpass filter’s frequency response relative to bandwidth <em class="calibre7">B</em>′.</p>
<p class="image"><img src="images/001259.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">If a decimation application requires <em class="calibre7">f</em><sub class="calibre12">s,new</sub> to be less than 2<em class="calibre7">B</em>, then <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) must be lowpass filtered before the downsampling process is performed, as shown in <a href="#calibre_link-117">Figure 10-2(c)</a>. (To clarify our terminology, we refer to decimation as the two-step process of lowpass filtering followed by downsampling.) If the original signal has a bandwidth <em class="calibre7">B</em>, and we’re interested in retaining only the band <em class="calibre7">B</em>v, the signal spectrum above <em class="calibre7">B</em>′ must be lowpass filtered, with full attenuation in the stopband beginning at <em class="calibre7">f</em><sub class="calibre12">stop</sub>, before the downsample-by-<em class="calibre7">M</em> process is performed. <a href="#calibre_link-117">Figure 10-2(d)</a> shows this in more detail where the frequency response of the lowpass filter, the bold lines, must attenuate the signal spectral components whose frequencies are greater than <em class="calibre7">B</em>′. Review the busy <a href="#calibre_link-117">Figure 10-2(d)</a> carefully and notice how the lowpass filter’s <em class="calibre7">f</em><sub class="calibre12">stop</sub> frequency can be as high as <em class="calibre7">f</em><sub class="calibre12">stop</sub> = <em class="calibre7">f</em><sub class="calibre12">s,new</sub>&ndash;<em class="calibre7">B</em>′ and no spectral aliasing will occur in the <em class="calibre7">B</em>′ band of interest.</p>
<p class="calibre3">In practice, the nonrecursive tapped-delay line FIR filter structure in <a href="#calibre_link-118">Figure 5-13</a> is the prevailing choice for <em class="calibre7"><a href="#calibre_link-119">decimation filters</a></em> due to its linear phase response<a href="#calibre_link-120">[1]</a>. However, we need not apply <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) samples, one at a time, to an FIR lowpass filter and discard <em class="calibre7">M</em>&ndash;1 out of every <em class="calibre7">M</em> filter output samples. Instead, we could apply one <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) sample to the filter and compute an output sample, apply the next <em class="calibre7">M</em> consecutive <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) samples to the filter’s delay line and compute the next output, and continue applying <em class="calibre7">M</em> consecutive <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) samples for each new filter output sample. That way we do not compute filter output samples that are discarded. In <a href="#calibre_link-121">Section 10.7</a> we’ll learn how to minimize the number of filter multiplications needed.</p>
<p class="calibre3"><a id="calibre_link-150"></a></p>
<h3 class="calibre6">10.2 Two-Stage Decimation</h3>
<p class="calibre3">When the desired decimation factor <em class="calibre7">M</em> is large, say <em class="calibre7">M</em> &gt; 20, there is an important feature of the filter/decimation process to keep in mind. Significant lowpass filter (LPF) computational savings may be had by implementing the single-stage decimation, shown in <a href="#calibre_link-122">Figure 10-3(a)</a>, in two stages as shown in <a href="#calibre_link-122">Figure 10-3(b)</a>. There we decimate sequence <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) by integer factor <em class="calibre7">M</em><sub class="calibre12">1</sub> to produce the intermediate <em class="calibre7">x</em><sub class="calibre12">int</sub>(<em class="calibre7">n</em>‘) sequence, which is then decimated by integer factor <em class="calibre7">M</em><sub class="calibre12">2</sub>. The downsampling, sample rate decrease operation “↓<em class="calibre7">M</em><sub class="calibre12">1</sub>” in <a href="#calibre_link-122">Figure 10-3(b)</a> means discard all but every <em class="calibre7">M</em><sub class="calibre12">1</sub>th sample. The product of <em class="calibre7">M</em><sub class="calibre12">1</sub> and <em class="calibre7">M</em><sub class="calibre12">2</sub> is our desired decimation factor; that is, <em class="calibre7">M</em> = <em class="calibre7">M</em><sub class="calibre12">1</sub><em class="calibre7">M</em><sub class="calibre12">2</sub>.</p>
<p class="caption"><a id="calibre_link-2386"></a><a id="calibre_link-122"></a><strong class="calibre9">Figure 10-3</strong> Decimation: (a) single-stage; (b) two-stage.</p>
<p class="image"><img src="images/000452.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">As a brief aside, the systems in <a href="#calibre_link-122">Figure 10-3</a> are called <em class="calibre7">multirate systems</em> because there are two or more different data sample rates within a single system.</p>
<p class="calibre3"><a id="calibre_link-3015"></a></p>
<h4 class="calibre13">10.2.1 Two-Stage Decimation Concepts</h4>
<p class="calibre3">Considering <a href="#calibre_link-122">Figure 10-3(b)</a>, an important question is “Given a desired total downsampling factor <em class="calibre7">M</em>, what should be the values of <em class="calibre7">M</em><sub class="calibre12">1</sub> and <em class="calibre7">M</em><sub class="calibre12">2</sub> to minimize the number of taps in lowpass filters LPF<sub class="calibre12">1</sub> and LPF<sub class="calibre12">2</sub>?” If, for example, <em class="calibre7">M</em> = 100, should <em class="calibre7">M</em><sub class="calibre12">1</sub><em class="calibre7">M</em><sub class="calibre12">2</sub> be 5 · 20, 20 · 5, 25 · 4, or maybe 10 · 10? Thankfully, thoughtful DSP pioneers answered this question for us<a href="#calibre_link-120">[1]</a>. For two-stage decimation, the optimum value for <em class="calibre7">M</em><sub class="calibre12">1</sub> is</p>
<p class="caption"><a id="calibre_link-123"></a>(10-2)</p>
<p class="image"><img src="images/001712.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where <em class="calibre7">F</em> is the ratio of <a href="#calibre_link-122">Figure 10-3(a)</a>’s single-stage lowpass filter’s transition region width to that filter’s stopband frequency. That is,</p>
<p class="caption"><a id="calibre_link-3016"></a>(10-2′)</p>
<p class="image"><img src="images/001806.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">After using <a href="#calibre_link-123">Eq. (10-2)</a> to determine the optimum <em class="calibre7">M</em><sub class="calibre12">1,opt</sub> factor, and setting <em class="calibre7">M</em><sub class="calibre12">1</sub> equal to the integer submultiple of <em class="calibre7">M</em> that is closest to <em class="calibre7">M</em><sub class="calibre12">1,opt</sub>, the second downsampling factor is</p>
<p class="caption"><a id="calibre_link-126"></a>(10-2″)</p>
<p class="image"><img src="images/000143.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3017"></a></p>
<h4 class="calibre13"><a id="calibre_link-2113"></a>10.2.2 Two-Stage Decimation Example</h4>
<p class="calibre3">By way of example, let’s assume we have an <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) input signal arriving at a sample rate of 400 kHz, and we must decimate that signal by a factor of <em class="calibre7">M</em> = 100 to obtain a final sample rate of 4 kHz. Also, let’s assume the baseband frequency range of interest is from 0 to <em class="calibre7">B</em>′ = 1.8 kHz, and we want 60 dB of filter stopband attenuation. As such, a single-stage-decimation lowpass filter’s frequency magnitude response is shown in <a href="#calibre_link-124">Figure 10-4(a)</a>.</p>
<p class="caption"><a id="calibre_link-124"></a><strong class="calibre9">Figure 10-4</strong> Two-stage decimation: (a) single-stage filter response; (b) decimation by 100; (c) spectrum of original signal; (d) output spectrum of the <em class="calibre7">M</em> = 25 downsampler; (e) output spectrum of the <em class="calibre7">M</em> = 4 downsampler.</p>
<p class="image"><img src="images/001309.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">So, with <em class="calibre7">f</em><sub class="calibre12">s,new</sub> = 4 kHz, we must filter out all <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>)’s signal energy above <em class="calibre7">f</em><sub class="calibre12">stop</sub> by having our filter transition region extend from 1.8 kHz to <em class="calibre7">f</em><sub class="calibre12">stop</sub> = 4&ndash;1.8 = 2.2 kHz. Now let’s estimate the number of taps, <em class="calibre7">N</em>, required of a single-stage decimation-by-100 process. Using <a href="#calibre_link-79">Chapter 5</a>’s <a href="#calibre_link-125">Eq. (5-49)</a>, and the notation <em class="calibre7">f</em><sub class="calibre12">pass</sub> = <em class="calibre7">B</em>′ = 1.8 kHz, we estimate the filter tap length to be</p>
<p class="caption"><a id="calibre_link-127"></a>(10-3)</p>
<p class="image"><img src="images/000979.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3018"></a>taps. That’s a painfully large number! (Resist all temptation to propose using a 2727-tap FIR filter in any system design review meeting at your company, or else you may be forced to update your résumé.)</p>
<p class="calibre3">Happily, to reduce the number of necessary filter taps we can partition our decimation problem into two stages. With <em class="calibre7">M</em> = 100 and <em class="calibre7">F</em> = (2200&ndash;1800)/2200 = 4/22, <a href="#calibre_link-123">Eq. (10-2)</a> yields an optimum <em class="calibre7">M</em><sub class="calibre12">1,opt</sub> downsample factor of 26.4. The integer submultiple of 100 closest to 26.4 is 25, so we set <em class="calibre7">M</em><sub class="calibre12">1</sub> = 25. Next, from <a href="#calibre_link-126">Eq. (10-2″)</a>, <em class="calibre7">M</em><sub class="calibre12">2</sub> = 4 as shown in <a href="#calibre_link-124">Figure 10-4(b)</a>.</p>
<p class="calibre3">In this two-stage decimation example we’ll assume the original <em class="calibre7">X</em><sub class="calibre12">old</sub>(<em class="calibre7">f</em>) input signal spectrum extends from zero Hz to something greater than 100 kHz as shown in <a href="#calibre_link-124">Figure 10-4(c)</a>. If the first lowpass filter LPF<sub class="calibre12">1</sub> has a passband cutoff frequency of 1.8 kHz and its <em class="calibre7">f</em><sub class="calibre12">stop</sub> is defined as <em class="calibre7">f</em><sub class="calibre12">s,int</sub>&ndash;<em class="calibre7">B</em>′ = 16&ndash;1.8 = 14.2 kHz, the output of the <em class="calibre7">M</em><sub class="calibre12">1</sub> = 25 decimator will have the spectrum shown in <a href="#calibre_link-124">Figure 10-4(d)</a>. When filter LPF<sub class="calibre12">2</sub> has a passband cutoff frequency of 1.8 kHz and its <em class="calibre7">f</em><sub class="calibre12">stop</sub> is set equal to 4&ndash;1.8 = 2.2 kHz, the output of the <em class="calibre7">M</em><sub class="calibre12">2</sub> = 4 decimator will have our desired spectrum shown in <a href="#calibre_link-124">Figure 10-4(e)</a>. The point is, the total number of taps in the two lowpass filters, <em class="calibre7">N</em><sub class="calibre12">total</sub>, is greatly reduced from the 2727 taps needed by a single filter stage. From the expression in <a href="#calibre_link-127">Eq. (10-3)</a> for the combined LPF<sub class="calibre12">1</sub> and LPF<sub class="calibre12">2</sub> filters, the total number of two-stage filter taps is roughly</p>
<p class="caption"><a id="calibre_link-3019"></a>(10-3‘)</p>
<p class="image"><img src="images/000530.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">This is an impressive computational savings, and it shows the kind of processing efficiency afforded by two-stage decimation[<a href="#calibre_link-120">1</a>,<a href="#calibre_link-128">2</a>]. Had we used <em class="calibre7">M</em><sub class="calibre12">1</sub> = 50 and <em class="calibre7">M</em><sub class="calibre12">2</sub> = 2 (or <em class="calibre7">M</em><sub class="calibre12">1</sub> = 10 and <em class="calibre7">M</em><sub class="calibre12">2</sub> = 10) in our decimation-by-100 example, the total number of two-stage filter taps would have been greater than 250. Thus <em class="calibre7">M</em><sub class="calibre12">1</sub> = 25 and <em class="calibre7">M</em><sub class="calibre12">2</sub> = 4 is the better choice.</p>
<p class="calibre3"><a id="calibre_link-3020"></a></p>
<h4 class="calibre13">10.2.3 Two-Stage Decimation Considerations</h4>
<p class="calibre3">The multistage decimation design curves in reference <a href="#calibre_link-120">[1]</a> tell us that, for computational efficiency reasons, it’s always to our benefit to decimate in order from the largest to the smallest factor. That is, we make sure that <em class="calibre7">M</em><sub class="calibre12">1</sub> is greater than <em class="calibre7">M</em><sub class="calibre12">2</sub>.</p>
<p class="calibre3">In two-stage decimation applications it is advantageous to consider setting the <em class="calibre7">M</em><sub class="calibre12">1</sub> and <em class="calibre7">M</em><sub class="calibre12">2</sub> decimation factors equal to integer powers of two because we can use computationally efficient half-band filters for the lowpass filters in <a href="#calibre_link-124">Figure 10-4(b)</a>. We discuss the use of multirate half-band filtering later in <a href="#calibre_link-129">Section 10.11</a>.</p>
<p class="calibre3"><a id="calibre_link-2112"></a>There are two practical issues to consider for two-stage decimation. First, as we discussed regarding cascaded filters in <a href="#calibre_link-130">Section 6.8.1</a>, if the dual-filter system in <a href="#calibre_link-124">Figure 10-4(b)</a> is required to have a passband peak-peak ripple of <em class="calibre7">R</em> dB (<em class="calibre7">R</em> decibels), then both filters must be designed to have a passband peak-peak ripple of no greater than <em class="calibre7">R</em>/2 dB. Second, the number of multiplications needed to compute each <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">m</em>) output sample in <a href="#calibre_link-124">Figure 10-4(b)</a> is much larger than <em class="calibre7">N</em><sub class="calibre12">total</sub> because we must compute so many LPF<sub class="calibre12">1</sub> and LPF<sub class="calibre12">2</sub> output samples destined to be discarded. Later we’ll introduce an efficient decimation filter implementation scheme called <em class="calibre7">polyphase decomposition</em> that only requires <em class="calibre7">N</em><sub class="calibre12">total</sub> multiplications per <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">m</em>) output sample.</p>
<p class="calibre3">The advantages of two-stage decimation, over single-stage decimation, are</p>
<p class="indenthangingb">• an overall reduction in computational workload,</p>
<p class="indenthangingb">• reduced signal and filter coefficient data storage,</p>
<p class="indenthangingb">• simpler filter designs, and</p>
<p class="indenthangingb">• a decrease in the ill effects of finite binary-word-length filter coefficients.</p>
<p class="calibre3">These advantages become more pronounced as the overall desired decimation factor <em class="calibre7">M</em> becomes larger. To conclude our two-stage decimation discussion, be aware that reference <a href="#calibre_link-131">[3]</a> discusses aspects of multistage decimation where the number of stages is greater than two.</p>
<p class="calibre3"><a id="calibre_link-654"></a></p>
<h3 class="calibre6">10.3 Properties of Downsampling</h3>
<p class="calibre3">Let us now quickly review several interesting aspects of downsampling a discrete sequence (retaining every <em class="calibre7">M</em>th sample and discarding all the remaining samples).</p>
<p class="calibre3"><a id="calibre_link-3021"></a></p>
<h4 class="calibre13">10.3.1 Time and Frequency Properties of Downsampling</h4>
<p class="calibre3">First, we realize that downsampling is one of those rare processes that is not time invariant. From the very nature of its operation, we know if we delay the input sequence by one sample, a downsampler will generate an entirely different output sequence. For example, if we apply an input sequence <em class="calibre7">x</em>(<em class="calibre7">n</em>) = <em class="calibre7">x</em>(0), <em class="calibre7">x</em>(1), <em class="calibre7">x</em>(2), <em class="calibre7">x</em>(3), <em class="calibre7">x</em>(4), etc., to a downsampler and <em class="calibre7">M</em> = 3, the output <em class="calibre7">y</em>(<em class="calibre7">m</em>) will be the sequence <em class="calibre7">x</em>(0), <em class="calibre7">x</em>(3), <em class="calibre7">x</em>(6), etc. Should we delay the input sequence by one sample, our delayed <em class="calibre7">x</em><sub class="calibre12">d</sub>(<em class="calibre7">n</em>) input would be <em class="calibre7">x</em>(1), <em class="calibre7">x</em>(2), <em class="calibre7">x</em>(3), <em class="calibre7">x</em>(4), <em class="calibre7">x</em>(5), etc. In this case the downsampled output sequence <em class="calibre7">y</em><sub class="calibre12">d</sub>(<em class="calibre7">m</em>) would be <em class="calibre7">x</em>(1), <em class="calibre7">x</em>(4), <em class="calibre7">x</em>(7), etc., which is <em class="calibre7">not</em> a delayed version of <em class="calibre7">y</em>(<em class="calibre7">m</em>). Thus a downsampler is not time invariant. What this means is that if a downsampling operation is in cascade with other operations, we are not permitted to swap the order of any of those <a id="calibre_link-2111"></a>operations and the downsampling process without modifying those operations in some way. We first discussed this notion of time invariance in <a href="#calibre_link-132">Section 1.7</a>, and we’ll see an example of it in <a href="#calibre_link-133">Section 10.13</a>.</p>
<p class="calibre3">Second, downsampling does not cause time-domain signal amplitude loss. A sinusoid with a peak-peak amplitude of 10 retains this peak-peak amplitude after downsampling. However, downsampling by <em class="calibre7">M</em> does induce a magnitude loss by a factor of <em class="calibre7">M</em> in the frequency domain. That’s because, as we learned in <a href="#calibre_link-134">Chapter 3</a>, DFT magnitudes are proportional to the number of time-domain samples used in the transformation.</p>
<p class="calibre3"><a id="calibre_link-3022"></a></p>
<h4 class="calibre13">10.3.2 Drawing Downsampled Spectra</h4>
<p class="calibre3">To illustrate the frequency properties of downsampling, let’s review an algorithm (a recipe) that tells us how to draw the spectrum of a downsampled signal. Drawing the spectrum of a downsampled lowpass signal is easy; we saw that in <a href="#calibre_link-117">Figures 10-2(a)</a> and <a href="#calibre_link-117">10-2(b)</a>. However, drawing the spectra of bandpass and highpass signals that have been downsampled can be a bit tricky. Here’s the process I use to draw the spectra of any type of downsampled signal.</p>
<p class="calibre3">We begin by looking at the spectral magnitude, |<em class="calibre7">X</em>(ω)| in <a href="#calibre_link-135">Figure 10-5(a)</a>, of an <em class="calibre7">x</em>(<em class="calibre7">n</em>) time signal containing spectral energy at both low and high <a id="calibre_link-2352"></a>frequencies. To help clarify our discussion by making the associated spectra (we hope) easier to interpret, we use a complex-valued lowpass <em class="calibre7">x</em>(<em class="calibre7">n</em>) for this example. Regarding <a href="#calibre_link-135">Figure 10-5(a)</a>, notice the following:</p>
<p class="indenthangingb">• The baseband spectral envelope of |<em class="calibre7">X</em>(ω)| is centered at zero Hz covering the frequency range of &ndash;π ≤ ω<sub class="calibre12">old</sub> ≤ π radians/sample (−<em class="calibre7">f</em><sub class="calibre12"><em class="calibre7">s</em>,old</sub>/2 to <em class="calibre7">f</em><sub class="calibre12"><em class="calibre7">s</em>,old</sub>/2 Hz), shown by the bold solid curve. Frequency <em class="calibre7">f</em><sub class="calibre12"><em class="calibre7">s</em>,old</sub> is the original sample rate of <em class="calibre7">x</em>(<em class="calibre7">n</em>), measured in Hz.</p>
<p class="indenthangingb">• For clarity, and reference, we label the frequency axis in both radians/sample and Hz.</p>
<p class="indenthangingb">• The spectral replications in |<em class="calibre7">X</em>(ω)| are shown by the short-dashed curves, spaced at integer multiples of 2π radians/sample (<em class="calibre7">f</em><sub class="calibre12"><em class="calibre7">s</em>,old</sub> Hz).</p>
<p class="indenthangingb">• |<em class="calibre7">X</em>(ω)| has a peak magnitude of <em class="calibre7">P</em>.</p>
<p class="caption"><a id="calibre_link-135"></a><strong class="calibre9">Figure 10-5</strong> Spectra associated with downsampling by <em class="calibre7">M</em> = 3.</p>
<p class="image"><img src="images/000342.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Assuming we want to downsample <em class="calibre7">x</em>(<em class="calibre7">n</em>) by a factor of <em class="calibre7">M</em> = 3 to create a <em class="calibre7">y</em>(<em class="calibre7">m</em>) sequence, the following steps show how to determine the |<em class="calibre7">Y</em>(ω)| spectrum based on the known |<em class="calibre7">X</em>(ω)|:</p>
<p class="indenthangingn1"><strong class="calibre9">1.</strong> Draw the |<em class="calibre7">X</em>(ω)| spectrum of sequence <em class="calibre7">x</em>(<em class="calibre7">n</em>) showing at least one spectral replication in both the positive- and negative-frequency directions. We did that in <a href="#calibre_link-135">Figure 10-5(a)</a>.</p>
<p class="indenthangingn1"><strong class="calibre9">2.</strong> Insert <em class="calibre7">M</em>&ndash;1 equally spaced copies of the primary spectral envelope between the primary spectral envelope and the spectral replications centered at ω<sub class="calibre12">old</sub> = ±2π. The spectral spacing of the <em class="calibre7">M</em>&ndash;1 inserted copies should be multiples of 2π/<em class="calibre7">M</em> radians/sample as shown by the long-dashed curves in <a href="#calibre_link-135">Figure 10-5(b)</a>.</p>
<p class="indenthangingn1"><strong class="calibre9">3.</strong> Scale upward the frequency axis values of |<em class="calibre7">Y</em>(ω)| by a factor of <em class="calibre7">M</em>, yielding the new ω<sub class="calibre12">new</sub> frequency axis variable as shown in <a href="#calibre_link-135">Figure 10-5(c)</a>.</p>
<p class="indenthangingn1"><strong class="calibre9">4.</strong> Finally, scale downward the vertical axis of |<em class="calibre7">Y</em>(ω)| by a factor of 1/<em class="calibre7">M</em>. This produces a peak magnitude for |<em class="calibre7">Y</em>(ω)| of <em class="calibre7">P</em>/<em class="calibre7">M</em> as shown in <a href="#calibre_link-135">Figure 10-5(c)</a>.</p>
<p class="calibre3">We zoom in on the |<em class="calibre7">Y</em>(ω)| spectrum in <a href="#calibre_link-135">Figure 10-5(d)</a> to show enhanced detail.</p>
<p class="calibre3"><a id="calibre_link-655"></a></p>
<h3 class="calibre6">10.4 Interpolation</h3>
<p class="calibre3">As we said before, downsampling is only part of the sample rate conversion story&mdash;let’s now consider interpolation. Sample rate increase by interpolation is a bit more involved than decimation because with interpolation new sample values need to be calculated. Conceptually, interpolation comprises the <a id="calibre_link-2353"></a>generation of a continuous <em class="calibre7">x</em>(<em class="calibre7">t</em>) curve passing through our <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) sampled values, as shown in <a href="#calibre_link-136">Figure 10-6(a)</a>, followed by sampling that curve at the new sample rate <em class="calibre7">f</em><sub class="calibre12">s,new</sub> to obtain the interpolated sequence <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">m</em>) in <a href="#calibre_link-136">Figure 10-6(b)</a>. Of course, continuous curves cannot exist inside a digital machine, so we’re forced to obtain <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">m</em>) directly from <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>). To increase a given <em class="calibre7">f</em><sub class="calibre12">s,old</sub> sample rate by an integer factor of <em class="calibre7">L</em> we must insert <em class="calibre7">L</em>&ndash;1 zero-valued samples between each sample in <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>), creating a longer-length sequence. To the end of that longer sequence we append <em class="calibre7">L</em>&ndash;1 zero-valued samples. Those two steps are what we call <em class="calibre7">upsampling</em>, indicated by the “↑<em class="calibre7">L</em>” operation in <a href="#calibre_link-136">Figure 10-6(c)</a>. Next, we apply the upsampled sequence to a lowpass filter whose output is the interpolated sequence in <a href="#calibre_link-136">Figure 10-6(b)</a>.</p>
<p class="caption"><a id="calibre_link-136"></a><strong class="calibre9">Figure 10-6</strong> Interpolation: (a) original time sequence; (b) interpolated by <em class="calibre7">L</em> = 3 sequence; (c) interpolation functional notation.</p>
<p class="image"><img src="images/001187.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">We formally refer to interpolation as the two-step process of upsampling followed by lowpass filtering. The process of interpolation is beautifully straightforward and best understood by way of an example.</p>
<p class="calibre3">Let’s assume we have the sequence <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>), part of which is shown in <a href="#calibre_link-137">Figure 10-7(a)</a>, and we want to increase its sample rate by a factor of <em class="calibre7">L</em> = 4. The <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) sequence’s spectrum is provided in <a href="#calibre_link-137">Figure 10-7(a)</a> where the signal spectrum between zero Hz and 4<em class="calibre7">f</em><sub class="calibre12">s,old</sub> is shown. Please notice that the dashed curves in <em class="calibre7">X</em><sub class="calibre12">old</sub>(<em class="calibre7">f</em>) are spectral replications. To upsample <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) by a factor of four, we insert three zeros between each sample of <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) and append the last three zeros, as shown in <a href="#calibre_link-137">Figure 10-7(b)</a>, to create the new intermediate sequence <em class="calibre7">x</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>). Notice that the old sequence is embedded in the new <a id="calibre_link-2354"></a>sequence. The insertion of the zeros (a process often called <em class="calibre7">zero stuffing</em>) establishes the sample index for the intermediate sequence <em class="calibre7">x</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>) where the interpolated values will be assigned.</p>
<p class="caption"><a id="calibre_link-137"></a><strong class="calibre9">Figure 10-7</strong> Interpolation by four: (a) original sampled sequence and its spectrum; (b) zeros inserted in original sequence and resulting spectrum; (c) output sequence of interpolation filter and final spectrum.</p>
<p class="image"><img src="images/000229.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The spectrum of <em class="calibre7">x</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>), <em class="calibre7">X</em><sub class="calibre12">int</sub>(<em class="calibre7">f</em>), is shown in <a href="#calibre_link-137">Figure 10-7(b)</a> where <em class="calibre7">f</em><sub class="calibre12">s,new</sub> = 4<em class="calibre7">f</em><sub class="calibre12">s,old</sub>. The solid curves in <em class="calibre7">X</em><sub class="calibre12">int</sub>(<em class="calibre7">f</em>), centered at multiples of <em class="calibre7">f</em><sub class="calibre12">s,old</sub>, are called <em class="calibre7">images</em>. What we’ve done by adding the zeros is merely increase the effective sample frequency to <em class="calibre7">f<sub class="calibre12">s</sub></em> = <em class="calibre7">f</em><sub class="calibre12">s,new</sub> in <a href="#calibre_link-137">Figure 10-7(b)</a>. The final step in interpolation is to filter the <em class="calibre7">x</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>) sequence with the lowpass filter shown in <a href="#calibre_link-136">Figure 10-6(c)</a>. That filter’s frequency magnitude response is crudely shown as the dashed lines centered at zero Hz, and <em class="calibre7">f</em><sub class="calibre12">s,new</sub> Hz, in <a href="#calibre_link-137">Figure 10-7(b)</a>. The lowpass filter’s job is to attenuate the spectral images shown in <a href="#calibre_link-137">Figure 10-7(b)</a>. This lowpass filter is called an <em class="calibre7">interpolation filter</em>, and its output sequence is the desired <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">m</em>) sequence in <a href="#calibre_link-137">Figure 10-7(c)</a> having the spectrum <em class="calibre7">X</em><sub class="calibre12">new</sub>(<em class="calibre7">f</em>) containing residual spectral images. We’ll discuss those residual images in a moment.</p>
<p class="calibre3"><a id="calibre_link-656"></a></p>
<h3 class="calibre6">10.5 Properties of Interpolation</h3>
<p class="calibre3">Here we discuss several important aspects of the interpolation (upsampling followed by lowpass filtering) process depicted in <a href="#calibre_link-137">Figure 10-7</a>.</p>
<p class="calibre3"><a id="calibre_link-3023"></a></p>
<h4 class="calibre13"><a id="calibre_link-2272"></a>10.5.1 Time and Frequency Properties of Interpolation</h4>
<p class="calibre3">Because we cannot implement an ideal lowpass interpolation filter, <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">m</em>) will not be an exact interpolation of <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>). The error manifests itself as the residual spectral images in <em class="calibre7">X</em><sub class="calibre12">new</sub>(<em class="calibre7">f</em>) as indicated in <a href="#calibre_link-137">Figure 10-7(c)</a>. With an ideal filter, these images would not exist, but we can only approximate an ideal lowpass interpolation filter. The issue to remember is that the accuracy of our entire interpolation process depends on the stopband attenuation of our lowpass filter. The greater the stopband attenuation, the more accurate the interpolation. As with decimation, interpolation can be thought of as an exercise in lowpass filter design.</p>
<p class="calibre3">Note that our interpolation process, because of the zero-valued samples, has an inherent amplitude loss factor of <em class="calibre7">L</em> when a unity-gain lowpass filter is used. That is, the peak sample value of <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">m</em>) is equal to the peak sample value of <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) divided by <em class="calibre7">L</em>. Thus, to achieve unity gain between sequences <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) and <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">m</em>), the lowpass interpolation filter must have a gain of <em class="calibre7">L</em> at zero Hz.</p>
<p class="calibre3">Although there is a time-domain gain (amplitude) loss of <em class="calibre7">L</em> by upsampling and filtering, that loss is canceled in the discrete frequency domain by the <em class="calibre7">L</em>-fold gain in the magnitudes of the discrete Fourier transform (DFT) of an <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">m</em>) sequence that is <em class="calibre7">L</em> times longer in duration than the original <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) time sequence. (We’re repeating a fact we learned in <a href="#calibre_link-134">Chapter 3</a>&mdash;DFT magnitudes are proportional to the length of the time sequence being transformed.)</p>
<p class="calibre3">Rather than perform the upsampling in <a href="#calibre_link-137">Figure 10-7(b)</a>, we might be inclined to merely repeat each <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) sample three times to generate the new upsampled <em class="calibre7">x</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>) sequence. Such a maneuver would indeed help attenuate the unwanted spectral images, but sadly the resulting low-frequency <em class="calibre7">X</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>) spectral magnitude shape will be the original desired <em class="calibre7">X</em><sub class="calibre12">old</sub>(<em class="calibre7">m</em>) spectrum multiplied by a sin(<em class="calibre7">x</em>)/<em class="calibre7">x</em> function. If this happens, then the follow-on lowpass filter must compensate for that spectral magnitude roll-off distortion. Such non-flat passband sin(<em class="calibre7">x</em>)/<em class="calibre7">x</em>-compensation filters require so many additional taps that the “repeat each <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) sample” scheme is unwise. In fact, later we’ll discuss an efficient interpolation filtering scheme called <em class="calibre7">polyphase filtering</em> wherein we don’t bother to create the upsampled <em class="calibre7">x</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>) sequence at all.</p>
<p class="calibre3">There’s one further issue regarding interpolation. You might tend to think that interpolation was born of our modern-day signal processing applications such as cell phones and compact disc players. Please don’t. Ancient astronomical cuneiform tablets, originating from Uruk and Babylon (200 years before the birth of Jesus), indicate that linear interpolation was used to fill in the missing tabulated positions of celestial bodies for those times when atmospheric conditions prevented direct observation<a href="#calibre_link-138">[4]</a>. Interpolation has been used ever since, for <em class="calibre7">filling in</em> missing data.</p>
<p class="calibre3"><a id="calibre_link-3024"></a></p>
<h4 class="calibre13"><a id="calibre_link-2350"></a>10.5.2 Drawing Upsampled Spectra</h4>
<p class="calibre3">To illustrate the frequency properties of upsampling (insertion of zero-valued samples), and to demonstrate the method for drawing the spectra of upsampled signals, consider the spectral magnitude, |<em class="calibre7">X</em>(ω)| in <a href="#calibre_link-139">Figure 10-8(a)</a>, of a lowpass <em class="calibre7">x</em>(<em class="calibre7">n</em>) time signal. Regarding <a href="#calibre_link-139">Figure 10-8(a)</a>, notice the following:</p>
<p class="indenthangingb">• The baseband spectral envelope of |<em class="calibre7">X</em>(ω)| is centered at zero Hz covering the frequency range of roughly &ndash;π ≤ ω<sub class="calibre12">old</sub> ≤ π radians/sample (−<em class="calibre7">f</em><sub class="calibre12"><em class="calibre7">s</em>,old</sub>/2 to <em class="calibre7">f</em><sub class="calibre12"><em class="calibre7">s</em>,old</sub>/2 Hz), shown by the solid lines. Frequency <em class="calibre7">f</em><sub class="calibre12"><em class="calibre7">s</em>,old</sub> is the original sample rate of <em class="calibre7">x</em>(<em class="calibre7">n</em>), measured in Hz.</p>
<p class="indenthangingb">• For clarity, and reference, we label the frequency axis in both radians/sample and Hz.</p>
<p class="indenthangingb">• The spectral replications in |<em class="calibre7">X</em>(ω)| are shown by the dashed-line spectral envelopes spaced at integer multiples of 2π radians/sample (<em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,old</sub> Hz).</p>
<p class="indenthangingb">• |<em class="calibre7">X</em>(ω)| has a peak magnitude of <em class="calibre7">P</em>.</p>
<p class="caption"><a id="calibre_link-139"></a><strong class="calibre9">Figure 10-8</strong> Spectra associated with upsampling by <em class="calibre7">L</em> = 3.</p>
<p class="image"><img src="images/001072.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Assuming we want to upsample <em class="calibre7">x</em>(<em class="calibre7">n</em>) by a factor of <em class="calibre7">L</em> = 3, for example, to create a <em class="calibre7">y</em>(<em class="calibre7">m</em>) sequence, the following steps show how to determine the |<em class="calibre7">Y</em>(ω)| spectrum of <em class="calibre7">y</em>(<em class="calibre7">m</em>):</p>
<p class="indenthangingn1"><strong class="calibre9">1.</strong> Draw the |<em class="calibre7">X</em>(ω)| spectrum of sequence <em class="calibre7">x</em>(<em class="calibre7">n</em>) showing at least <em class="calibre7">L</em> = 3 spectral replications in both the positive- and negative-frequency directions. We did that in <a href="#calibre_link-139">Figure 10-8(a)</a>.</p>
<p class="indenthangingn1"><strong class="calibre9">2.</strong> Scale downward the frequency axis values of <em class="calibre7">X</em>(ω) by a factor of <em class="calibre7">L</em>, yielding the new ω<sub class="calibre12">new</sub> frequency variable as shown in <a href="#calibre_link-139">Figure 10-8(b)</a>.</p>
<p class="indenthangingn1"><a id="calibre_link-2108"></a><strong class="calibre9">3.</strong> Finally, indicate the spectral images (destined to be attenuated by subsequent lowpass filtering) by using solid lines to represent their spectral envelopes, as we did in <a href="#calibre_link-139">Figure 10-8(b)</a>.</p>
<p class="calibre3"><a id="calibre_link-657"></a></p>
<h3 class="calibre6">10.6 Combining Decimation and Interpolation</h3>
<p class="calibre3">Although changing sampling rates, through decimation or interpolation, by integer factors is quite common in practice, what can we do if we need a sample rate change that is not an integer? The good news is that we can implement sample rate conversion by any rational fraction <em class="calibre7">L</em>/<em class="calibre7">M</em> with interpolation by an integer factor <em class="calibre7">L</em> followed by decimation by an integer factor <em class="calibre7">M</em>. Because the ratio <em class="calibre7">L</em>/<em class="calibre7">M</em> can be obtained as accurately as we want, with the correct choice of integers <em class="calibre7">L</em> and <em class="calibre7">M</em>, we can change sample rates by almost any factor in practice. For example, a sample rate increase by a factor of 7.125 can be performed by an interpolation by <em class="calibre7">L</em> = 57 followed by a decimation by <em class="calibre7">M</em> = 8, because 7.125 = 57/8.</p>
<p class="calibre3">This <em class="calibre7">L</em>/<em class="calibre7">M</em> sample rate change is illustrated as the processes shown in <a href="#calibre_link-140">Figure 10-9(a)</a>. The neat part here is that the computational burden of changing the sample rate by the ratio of <em class="calibre7">L</em>/<em class="calibre7">M</em> is less than the sum of an individual interpolation followed by an individual decimation. That’s because we can combine the interpolation filter LPF<em class="calibre7"><sub class="calibre12">L</sub></em> and the decimation filter LPF<em class="calibre7"><sub class="calibre12">M</sub></em> into a single filter shown as LPF<sub class="calibre12"><em class="calibre7">L</em>/<em class="calibre7">M</em></sub> in <a href="#calibre_link-140">Figure 10-9(b)</a>. The process in <a href="#calibre_link-140">Figure 10-9(b)</a> is normally called a <em class="calibre7">sample rate converter</em> because if <em class="calibre7">L</em> &gt; <em class="calibre7">M</em> we have interpolation, and when <em class="calibre7">M</em> &gt; <em class="calibre7">L</em> we have decimation. (The filter LPF<sub class="calibre12"><em class="calibre7">L</em>/<em class="calibre7">M</em></sub> is often called a <em class="calibre7">multirate</em> filter.)</p>
<p class="caption"><a id="calibre_link-140"></a><strong class="calibre9">Figure 10-9</strong> Sample rate conversion by a rational factor: (a) combination interpolation/decimation; (b) single lowpass filter method.</p>
<p class="image"><img src="images/000128.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Filter LPF<sub class="calibre12"><em class="calibre7">L</em>/<em class="calibre7">M</em></sub> must sufficiently attenuate the interpolation spectral images so they don’t contaminate our desired signal beyond acceptable limits after decimation. To accomplish this task, lowpass filter LPF<sub class="calibre12"><em class="calibre7">L</em>/<em class="calibre7">M</em></sub> must attenuate all spectral components whose frequencies are above <em class="calibre7">f</em><sub class="calibre12"><em class="calibre7">s</em>,old</sub>/2 or (<em class="calibre7">f</em><sub class="calibre12"><em class="calibre7">s</em>,old</sub>/2) · (<em class="calibre7">L</em>/<em class="calibre7">M</em>), whichever is smaller, where <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,old</sub> is <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>)’s sample rate in Hz. The <a id="calibre_link-2231"></a>stopband attenuation of LPF<sub class="calibre12"><em class="calibre7">L</em>/<em class="calibre7">M</em></sub> must be great enough that the attenuated upsampled images do not induce intolerable levels of noise when they’re aliased by downsampling by <em class="calibre7">M</em> into the final band of 0 to <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,new</sub>/2 Hz, where <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,new</sub> is the filter’s data rate, in Hz.</p>
<p class="calibre3">Again, our interpolator/decimator designs are exercises in lowpass filter design, and all the knowledge and tools we have to design lowpass filters can be applied to this task. In software interpolator/decimator design, we want our lowpass filter algorithm to prevent aliasing images and be fast in execution time. For hardware interpolator/decimators, we strive to implement designs optimizing the conflicting goals of high performance (minimum spectral aliasing), simple architecture, high data throughput speed, and low power consumption.</p>
<p class="calibre3">The filtering computational workload in rational-factor sample rate conversion, as we’ve presented it here, is sadly inefficient. Think about interpolating a signal sequence by a factor of 4/3; we’d insert the zero-valued samples into the original time sequence and apply it to a lowpass filter. Three-fourths of the filter multiplication products would necessarily be zero. Next, we’d discard two-thirds of our computed filter output values. Very inefficient! Fortunately, we are now prepared to introduce special sample rate conversion filters, called <em class="calibre7">digital polyphase</em> filters, that avoid these computational inefficiencies.</p>
<p class="calibre3"><a id="calibre_link-121"></a></p>
<h3 class="calibre6">10.7 Polyphase Filters</h3>
<p class="calibre3">In this section we introduce the fascinating, and exceedingly useful, subject of digital polyphase FIR filters. These filters have the ability to eliminate all multiply by zero operations in interpolation, as well as avoid the wasteful computation of filter output samples that are subsequently discarded in decimation applications.</p>
<p class="calibre3">Let’s assume that a linear-phase FIR interpolation filter design requires an <em class="calibre7">N</em> = 12-tap filter; our initial plan is to pass the upsampled by <em class="calibre7">L</em> = 4 <em class="calibre7">x</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>) sequence in <a href="#calibre_link-141">Figure 10-10(a)</a> through the 12-tap FIR filter coefficients shown in <a href="#calibre_link-141">Figure 10-10(b)</a> to obtain the desired <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">m</em>) sequence. (This filter, whose coefficients are the <em class="calibre7">h</em>(<em class="calibre7">k</em>) sequence, is often called the <em class="calibre7">prototype</em> FIR filter. That’s because later we’re going to modify it.) Notice that with time advancing to the right in <a href="#calibre_link-141">Figure 10-10(a)</a>, the filter coefficients are in reversed order as shown in <a href="#calibre_link-141">Figure 10-10(b)</a>. This filtering requires 12 multiplications for each <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">m</em>) output sample, with 9 of the products always being zero. As it turns out, we need not perform all 12 multiplications.</p>
<p class="caption"><a id="calibre_link-141"></a><strong class="calibre9">Figure 10-10</strong> Interpolation by four with a 12-tap lowpass FIR filter: (a) filter input samples; (b) filter coefficients, <img src="images/000370.jpg" alt="image" class="calibre2" />s, used to compute <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">m</em>).</p>
<p class="image"><img src="images/000965.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">To show this by way of an example, <a href="#calibre_link-142">Figure 10-11(a)</a> shows the <em class="calibre7">x</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>) samples just filling the filter’s delay line so that we can compute the <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">m</em>=11) output sample. The 12 filter coefficients are indicated by the <img src="images/000370.jpg" alt="image" class="calibre2" /> symbols.</p>
<p class="caption"><a id="calibre_link-142"></a><strong class="calibre9">Figure 10-11</strong> Filter coefficients used to calculate various <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">m</em>) samples.</p>
<p class="image"><img src="images/000015.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3025"></a>With the dots in <a href="#calibre_link-142">Figure 10-11(a)</a> representing the <em class="calibre7">x</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>) sequence, we see that although there are nine <img src="images/000370.jpg" alt="image" class="calibre2" />s and three <img src="images/001740.jpg" alt="image" class="calibre2" />, only the three <img src="images/001740.jpg" alt="image" class="calibre2" /> generate nonzero products contributing to the convolution sum <em class="calibre7">x</em><sub class="calibre12">new</sub>(11). Those three <img src="images/001740.jpg" alt="image" class="calibre2" /> represent FIR filter coefficients <em class="calibre7">h</em>(3), <em class="calibre7">h</em>(7), and <em class="calibre7">h</em>(11). The issue here is that we need not perform the multiplications associated with the zero-valued samples in <em class="calibre7">x</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>). We only need to perform three multiplications to obtain <em class="calibre7">x</em><sub class="calibre12">new</sub>(11). To see the polyphase concept, remember that we use the prototype filter coefficients indicated by the <img src="images/001740.jpg" alt="image" class="calibre2" /> to compute <em class="calibre7">x</em><sub class="calibre12">new</sub>(12). When we slide the filter’s impulse response to the right one sample, we use the coefficients indicated by the circles, in <a href="#calibre_link-142">Figure 10-11(b)</a>, to calculate <em class="calibre7">x</em><sub class="calibre12">new</sub>(12) because the nonzero values of <em class="calibre7">x</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>) will line up under the circled coefficients. Those circles represent filter coefficients <em class="calibre7">h</em>(0), <em class="calibre7">h</em>(4), and <em class="calibre7">h</em>(8).</p>
<p class="calibre3"><a id="calibre_link-2067"></a>Likewise, when we slide the impulse response to the right one more sample to compute <em class="calibre7">x</em><sub class="calibre12">new</sub>(13), we use the coefficients indicated by the diamonds in <a href="#calibre_link-142">Figure 10-11(c)</a>. Finally, we slide the impulse response to the right once more and use the coefficients indicated by the triangles in <a href="#calibre_link-142">Figure 10-11(d)</a> to compute <em class="calibre7">x</em><sub class="calibre12">new</sub>(14). Sliding the filter’s impulse response once more to the right, we would return to using the coefficients indicated by the <img src="images/001740.jpg" alt="image" class="calibre2" /> to calculate <em class="calibre7">x</em><sub class="calibre12">new</sub>(15). You can see the pattern here&mdash;there are <em class="calibre7">L</em> = 4 different sets of coefficients used to compute <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">m</em>) from the <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) samples. Each time a new <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">m</em>) sample value is to be computed, we rotate one step through the four sets of coefficients and calculate as</p>
<p class="image"><img src="images/001709.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">and so on. The beautiful parts here are that we don’t actually have to create the <em class="calibre7">x</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>) sequence at all, and we perform no multiply by zero computations. <em class="calibre7">That</em> is polyphase filtering.</p>
<p class="calibre3">The above list of calculations not only shows us what filtering to do, it shows us how to do it. We can implement our polyphase interpolation filtering technique with a bank of four subfilters as shown in <a href="#calibre_link-143">Figure 10-12</a>. This depiction is called the <em class="calibre7">commutator model</em> for polyphase interpolation filters. We have a commutator switch rotating one complete cycle after the arrival of each new <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) sample. This way, four <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">m</em>) samples are computed for each <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) input sample.</p>
<p class="caption"><a id="calibre_link-143"></a><strong class="calibre9">Figure 10-12</strong> Polyphase interpolation by <em class="calibre7">L</em> = 4 filter structure as a bank of FIR subfilters.</p>
<p class="image"><img src="images/001137.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">In the typical case, if our polyphase filter is interpolating by a factor of <em class="calibre7">L</em>, then we’ll have <em class="calibre7">L</em> subfilters. As such, for convenience the number of taps in (the impulse response length of) the original prototype lowpass FIR filter, <em class="calibre7">N</em>, is chosen to be an integer multiple of <em class="calibre7">L</em>. Again, the passband width of the prototype lowpass FIR filter must not be greater than <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,old</sub>/2 where <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,old</sub> is <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>)’s sample rate in Hz.</p>
<p class="calibre3">A minimum data storage structure for the polyphase interpolation filter is shown in <a href="#calibre_link-144">Figure 10-13</a>, where three commutators rotate (in unison) counterclockwise through four sets of filter coefficients upon the arrival of each new <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) sample. Again, four <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">m</em>) samples are computed for each <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) sample.</p>
<p class="caption"><a id="calibre_link-144"></a><strong class="calibre9">Figure 10-13</strong> Minimum-storage polyphase interpolation filter structure using commutated coefficients.</p>
<p class="image"><img src="images/001715.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">This commutated-coefficients scheme has the advantage of reducing the number of storage registers for the <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) input samples. If our polyphase filter is interpolating by a factor of <em class="calibre7">L</em>, then we have <em class="calibre7">L</em> sets of coefficients.</p>
<p class="calibre3"><a id="calibre_link-3026"></a>We can validate our polyphase FIR filter block diagrams with <em class="calibre7">z</em>-transform equations. We start by describing our <a href="#calibre_link-143">Figure 10-12</a> polyphase FIR filter with</p>
<p class="caption"><a id="calibre_link-145"></a>(10-4)</p>
<p class="image"><img src="images/000585.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2400"></a>where <em class="calibre7">z</em><sub class="calibre12">in</sub><sup class="calibre10">&ndash;1</sup> is a unit delay at the input sample rate, and <em class="calibre7">z</em><sub class="calibre12">out</sub><sup class="calibre10">&ndash;1</sup> is a unit delay at the output sample rate implemented with the commutator. Because <em class="calibre7">z</em><sub class="calibre12">in</sub><sup class="calibre10">&ndash;1</sup> = <em class="calibre7">z</em><sub class="calibre12">out</sub><sup class="calibre10">&ndash;4</sup>, and <em class="calibre7">z</em><sub class="calibre12">in</sub><sup class="calibre10">&ndash;2</sup> = <em class="calibre7">z</em><sub class="calibre12">out</sub><sup class="calibre10">&ndash;8</sup>, we can write</p>
<p class="caption"><a id="calibre_link-146"></a>(10-4′)</p>
<p class="image"><img src="images/000429.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">which is the classic <em class="calibre7">z</em>-domain transfer function for a 12-tap FIR filter. <a href="#calibre_link-145">Equation (10-4)</a> is called a <em class="calibre7">polyphase decomposition</em> of <a href="#calibre_link-146">Eq. (10-4′)</a>.</p>
<p class="calibre3">Concerning our <a href="#calibre_link-142">Figure 10-11</a> example, there are several issues to keep in mind:</p>
<p class="indenthangingb">• For an interpolation factor of <em class="calibre7">L</em>, most people make sure the prototype FIR has an integer multiple of <em class="calibre7">L</em> number of stages for ease of implementation.</p>
<p class="indenthangingb">• As with the zeros-insertion and filtering method of interpolation, the polyphase method has a gain loss equal to the interpolation factor <em class="calibre7">L</em>. To compensate for this amplitude loss we can increase the filter’s coefficients by a factor of <em class="calibre7">L</em>, or perhaps multiply the <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">m</em>) output sequence by <em class="calibre7">L</em>.</p>
<p class="indenthangingb">• Our <a href="#calibre_link-142">Figure 10-11</a> example used a prototype filter with an even number of taps, but an odd-tap prototype FIR interpolation filter can also be used<a href="#calibre_link-147">[5]</a>. For example, you could have a 15-tap prototype FIR and interpolate by 5.</p>
<p class="indenthangingb">• Because the subfilter coefficient sets in <a href="#calibre_link-144">Figure 10-13</a> are not necessarily symmetrical, we can’t reduce the number of multiplications by means of the <em class="calibre7">folded FIR</em> structure discussed in <a href="#calibre_link-148">Section 13.7</a>.</p>
<p class="calibre3">With the commutating switch structure of <a href="#calibre_link-143">Figure 10-12</a> in mind, we can build a decimation-by-four polyphase filter using a commutating switch as shown in <a href="#calibre_link-149">Figure 10-14</a>. The switch rotates through its four positions (<em class="calibre7">M</em> = 4), applying four <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) input samples to the subfilters, then the four subfilters’ outputs are accumulated to provide a single <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">m</em>) output sample. In this filter the commutating switch rotates in the counterclockwise direction.</p>
<p class="caption"><a id="calibre_link-3027"></a><a id="calibre_link-149"></a><strong class="calibre9">Figure 10-14</strong> Polyphase decimation by <em class="calibre7">M</em> = 4 filter structure as a bank of FIR subfilters.</p>
<p class="image"><img src="images/000739.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Notice that the subfilters in <a href="#calibre_link-149">Figure 10-14</a> are unchanged from the interpolation filter in <a href="#calibre_link-143">Figure 10-12</a>. Again, the benefit of polyphase decimation filtering means no unnecessary computations are performed. We’re decimating before filtering, so no filter computational results are discarded.</p>
<p class="calibre3">In the typical case, if our polyphase filter is decimating by a factor of <em class="calibre7">M</em>, then we’ll have <em class="calibre7">M</em> subfilters. As such, for convenience the number of taps in (the impulse response length of) the original prototype lowpass FIR filter, <em class="calibre7">N</em>, is chosen to be an integer multiple of <em class="calibre7">M</em>. The passband width of the prototype lowpass filter must not be greater than (<em class="calibre7">f</em><sub class="calibre12"><em class="calibre7">s</em>,old</sub>/2) · (<em class="calibre7">L</em>/<em class="calibre7">M</em>) where <em class="calibre7">f</em><sub class="calibre12"><em class="calibre7">s</em>,old</sub> is <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>)’s sample rate in Hz.</p>
<p class="calibre3">Again, in practice, large changes in sampling rate are accomplished with multiple stages (where <a href="#calibre_link-149">Figure 10-14</a>, for example, is a single decimation stage) of cascaded smaller rate change operations of decimation and interpolation as discussed in <a href="#calibre_link-150">Sections 10.2</a> and <a href="#calibre_link-151">10.8</a>. With that thought in mind, now is the appropriate time to discuss two-stage interpolation.</p>
<p class="calibre3">This concludes our brief introduction to the important topic of discrete polyphase filters. (For my money, the development of polyphase filters arguably resides in the stratosphere of brilliant DSP innovations, along with the <a id="calibre_link-3028"></a>radix-2 FFT algorithm and the Parks-McClellan FIR filter design algorithm.) More detailed information on polyphase filters can be found in references [<a href="#calibre_link-152">6</a>&ndash;<a href="#calibre_link-153">8</a>] and my favorite, reference <a href="#calibre_link-154">[9]</a>.</p>
<p class="calibre3"><a id="calibre_link-151"></a></p>
<h3 class="calibre6">10.8 Two-Stage Interpolation</h3>
<p class="calibre3">Because we’re now familiar with the notion of polyphase filtering, we’re ready to consider the process of two-stage interpolation. When a desired interpolation factor <em class="calibre7">L</em> is large, say <em class="calibre7">L</em> &gt; 20, significant interpolation filter computational savings may be had by implementing the interpolation in <a href="#calibre_link-155">Figure 10-15(a)</a> in two stages as shown in <a href="#calibre_link-155">Figure 10-15(c)</a>. In the later figure we interpolate input sequence <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) by integer factor <em class="calibre7">L</em><sub class="calibre12">1</sub> followed by interpolation by integer factor <em class="calibre7">L</em><sub class="calibre12">2</sub>, where <em class="calibre7">L</em> = <em class="calibre7">L</em><sub class="calibre12">1</sub><em class="calibre7">L</em><sub class="calibre12">2</sub>.</p>
<p class="caption"><a id="calibre_link-155"></a><strong class="calibre9">Figure 10-15</strong> Interpolation: (a) single-stage; (b) lowpass filter (LPF) magnitude response and upsampled <em class="calibre7">x</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>) spectrum; (c) two-stage interpolation; (d) two-stage polyphase interpolation.</p>
<p class="image"><img src="images/001594.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3029"></a></p>
<h4 class="calibre13">10.8.1 Two-Stage Interpolation Concepts</h4>
<p class="calibre3">Let’s assume we want to interpolate <a href="#calibre_link-155">Figure 10-15(a)</a>’s input <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) sequence by <em class="calibre7">L</em>, so we insert the <em class="calibre7">L</em>&ndash;1 zero-valued samples appropriately in <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) to create the <em class="calibre7">x</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>) sequence whose spectral magnitude is shown as the dashed lines in <a href="#calibre_link-155">Figure 10-15(b)</a>. The lowpass filter (LPF) in <a href="#calibre_link-155">Figure 10-15(a)</a> must <a id="calibre_link-3030"></a>have a frequency magnitude response, shown as the solid lines in <a href="#calibre_link-155">Figure 10-15(b)</a>, that eliminates the spectral images in the <em class="calibre7">x</em><sub class="calibre12">int</sub>(<em class="calibre7">m</em>) sequence’s <em class="calibre7">X</em><sub class="calibre12">int</sub>(<em class="calibre7">f</em>) spectrum. As such, the filter LPF’s transition region extends from <em class="calibre7">B</em> Hz to <em class="calibre7">f</em><sub class="calibre12">stop</sub> = <em class="calibre7">f</em><sub class="calibre12">s,old</sub>&ndash;<em class="calibre7">B</em> = <em class="calibre7">f</em><sub class="calibre12">s,new</sub>/<em class="calibre7">L</em>&ndash;<em class="calibre7">B</em> Hz. (Frequency <em class="calibre7">f</em><sub class="calibre12">stop</sub> is the beginning of the lowpass filter’s stopband.) Given that frequency response requirement, we could now begin to design the lowpass filter LPF.</p>
<p class="calibre3">However, using <a href="#calibre_link-155">Figure 10-15(c)</a>’s two-stage interpolation, we can accomplish our overall interpolation by <em class="calibre7">L</em> where the combined number of computations in filters LPF<sub class="calibre12">1</sub> and LPF<sub class="calibre12">2</sub> is much smaller than the computations needed in the single <a href="#calibre_link-155">Figure 10-15(a)</a> LPF filter. This computational workload reduction can be achieved by determining the optimum <em class="calibre7">L</em><sub class="calibre12">1</sub> and <em class="calibre7">L</em><sub class="calibre12">2</sub> factors for our two-stage interpolation in <a href="#calibre_link-155">Figure 10-15(c)</a>, just as we did in finding the optimum downsampling factors in two-stage decimation.</p>
<p class="calibre3">Given the desired upsampling factor <em class="calibre7">L</em> in <a href="#calibre_link-155">Figure 10-15(a)</a>, we can determine the <em class="calibre7">L</em><sub class="calibre12">1</sub> and <em class="calibre7">L</em><sub class="calibre12">2</sub> upsampling factors that minimize the number of overall two-stage filtering multiplications per input sample using</p>
<p class="caption"><a id="calibre_link-156"></a>(10-5)</p>
<p class="image"><img src="images/001279.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where <em class="calibre7">F</em> is the ratio of the LPF filter’s transition region width over the filter’s stopband frequency, as shown in <a href="#calibre_link-155">Figure 10-15(b)</a>. That is,</p>
<p class="caption"><a id="calibre_link-158"></a>(10-5′)</p>
<p class="image"><img src="images/000316.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Upon using <a href="#calibre_link-156">Eq. (10-5)</a> to compute <em class="calibre7">L</em><sub class="calibre12">2,opt</sub>, and setting <em class="calibre7">L</em><sub class="calibre12">2</sub> equal to the integer submultiple of <em class="calibre7">L</em> that is closest to <em class="calibre7">L</em><sub class="calibre12">2,opt</sub>, the first interpolation factor <em class="calibre7">L</em><sub class="calibre12">1</sub> is found using</p>
<p class="caption"><a id="calibre_link-159"></a>(10-5″)</p>
<p class="image"><img src="images/001159.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">So, once we know the optimum values for <em class="calibre7">L</em><sub class="calibre12">1</sub> and <em class="calibre7">L</em><sub class="calibre12">2</sub>, we proceed by designing the LPF<sub class="calibre12">1</sub> and LPF<sub class="calibre12">2</sub> lowpass filters in <a href="#calibre_link-155">Figure 10-15(c)</a>. Finally, we implement the two-stage interpolation using two polyphase interpolation filters, PLPF<sub class="calibre12">1</sub> and PLPF<sub class="calibre12">2</sub>, as shown in <a href="#calibre_link-155">Figure 10-15(d)</a>. Let’s illustrate this two-stage interpolation concept with an example.</p>
<p class="calibre3"><a id="calibre_link-3031"></a></p>
<h4 class="calibre13">10.8.2 Two-Stage Interpolation Example</h4>
<p class="calibre3">Assume we must convert a compact disc (CD) audio signal, having a signal bandwidth of 15 kHz and a sample rate of 44.1 kHz, to the sample rate of 96 <a id="calibre_link-3032"></a>kHz used by a high-performance audio system. In addition, let’s assume that our interpolation filtering requires a stopband attenuation of 60 dB. We can accomplish this sample rate conversion by interpolating the CD signal by a factor of <em class="calibre7">L</em> = 320, and then decimate the interpolated signal by <em class="calibre7">M</em> = 147. So this two-stage interpolation example will show how to efficiently interpolate an input signal sequence by <em class="calibre7">L</em> = 320, yielding an interpolated sequence having a sample rate of <em class="calibre7">f</em><sub class="calibre12">s,new</sub> = <em class="calibre7">L</em> · <em class="calibre7">f</em><sub class="calibre12">s,old</sub> = 320 · 44.1 = 14112 kHz.</p>
<p class="calibre3">The bold lines in <a href="#calibre_link-157">Figure 10-16(a)</a> show the frequency requirements of the lowpass filter that we need for a single-stage <em class="calibre7">L</em> = 320 interpolation process. It is that magnitude response that we will implement using two cascaded polyphase interpolation filter stages. The sample rate in <a href="#calibre_link-157">Figure 10-16(a)</a> is <em class="calibre7">f</em><sub class="calibre12">s,new</sub> = 14112 kHz.</p>
<p class="caption"><a id="calibre_link-157"></a><strong class="calibre9">Figure 10-16</strong> Two-stage interpolation: (a) single-stage filter frequency parameters; (b) LPF<sub class="calibre12">1</sub> filter parameters; (c) LPF<sub class="calibre12">2</sub> filter parameters; (d) polyphase implementation.</p>
<p class="image"><img src="images/001198.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3033"></a>First we determine the optimum <em class="calibre7">L</em><sub class="calibre12">1</sub> and <em class="calibre7">L</em><sub class="calibre12">2</sub> interpolation factors. With <em class="calibre7">f</em><sub class="calibre12">stop</sub> = 29.1 kHz and <em class="calibre7">B</em> = 15 kHz, we use <a href="#calibre_link-158">Eq. (10-5′)</a> to compute ratio <em class="calibre7">F</em> as</p>
<p class="caption"><a id="calibre_link-3034"></a>(10-6)</p>
<p class="image"><img src="images/000526.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Next, we compute <em class="calibre7">L</em><sub class="calibre12">2,opt</sub> using <a href="#calibre_link-156">Eq. (10-5)</a> as</p>
<p class="caption"><a id="calibre_link-3035"></a>(10-6′)</p>
<p class="image"><img src="images/001047.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The integer submultiple of <em class="calibre7">L</em> = 320 that’s closest to <em class="calibre7">L</em><sub class="calibre12">2,opt</sub> = 37.98 is 40. So we set <em class="calibre7">L</em><sub class="calibre12">2</sub> = 40, and using <a href="#calibre_link-159">Eq. (10-5″)</a>, we compute <em class="calibre7">L</em><sub class="calibre12">1</sub> = 320/40 = 8.</p>
<p class="calibre3">So the first polyphase lowpass filter, LPF<sub class="calibre12">1</sub>, must have the frequency magnitude response shown in <a href="#calibre_link-157">Figure 10-16(b)</a> when its operating sample rate is <em class="calibre7">L</em><sub class="calibre12">1</sub> · <em class="calibre7">f</em><sub class="calibre12">s,old</sub> = 8 · 44.1 = 352.8 kHz. (That 352.8 kHz sample rate would have been the LPF<sub class="calibre12">1</sub> filter’s input rate had we inserted the <em class="calibre7">L</em><sub class="calibre12">1</sub>&ndash;1 zero-valued samples between each of the original CD samples. Recall that with polyphase filtering we don’t actually insert any zero-valued samples, but we must design a polyphase filter assuming the upsampled 352.8 kHz sample rate.)</p>
<p class="calibre3">Using <a href="#calibre_link-127">Eq. (10-3)</a> to estimate the number of taps in LPF<sub class="calibre12">1</sub>, <em class="calibre7">N</em><sub class="calibre12">LPF1</sub>, with <em class="calibre7">Atten</em> = 60, we compute</p>
<p class="caption"><a id="calibre_link-3036"></a>(10-7)</p>
<p class="image"><img src="images/000103.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Because we must partition the LPF<sub class="calibre12">1</sub> coefficients into a polyphase bank of <em class="calibre7">L</em><sub class="calibre12">1</sub> = 8 subfilters, <em class="calibre7">N</em><sub class="calibre12">LPF1</sub> must be an integer multiple of 8. So we’ll set <em class="calibre7">N</em><sub class="calibre12">LPF1</sub> = 72 taps, and the polyphase LPF<sub class="calibre12">1</sub> filter will have 8 subfilters.</p>
<p class="calibre3">The second polyphase lowpass filter, LPF<sub class="calibre12">2</sub>, must have the frequency magnitude response shown in <a href="#calibre_link-157">Figure 10-16(c)</a> when its operating sample rate is <em class="calibre7">L</em><sub class="calibre12">1</sub> · <em class="calibre7">L</em><sub class="calibre12">2</sub> · <em class="calibre7">f</em><sub class="calibre12">s,old</sub> = 14112 kHz. Using <a href="#calibre_link-127">Eq. (10-3)</a> to estimate the number of taps in LPF<sub class="calibre12">2</sub>, <em class="calibre7">N</em><sub class="calibre12">LPF2</sub>, with <em class="calibre7">Atten</em> = 60, we compute</p>
<p class="caption"><a id="calibre_link-3037"></a>(10-8)</p>
<p class="image"><img src="images/000826.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2436"></a>Because we must partition the LPF<sub class="calibre12">2</sub> coefficients into a polyphase bank of <em class="calibre7">L</em><sub class="calibre12">2</sub> = 40 subfilters, <em class="calibre7">N</em><sub class="calibre12">LPF2</sub> must be an integer multiple of 40. So we’ll set <em class="calibre7">N</em><sub class="calibre12">LPF2</sub> = 120 taps, and the polyphase LPF<sub class="calibre12">2</sub> filter will have 40 subfilters. We implement our two-stage interpolation as shown in <a href="#calibre_link-157">Figure 10-16(d)</a>, and that completes our two-stage interpolation example.</p>
<p class="calibre3">The number of multiplies in our two-stage polyphase interpolation process is <em class="calibre7">N</em><sub class="calibre12">LPF1</sub> + <em class="calibre7">L</em><sub class="calibre12">1</sub> · <em class="calibre7">N</em><sub class="calibre12">LPF2</sub> = 1032 multiplies per <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) input sample. If we had implemented our interpolation by <em class="calibre7">L</em> = 320 using a single polyphase filter having 320 subfilters, we would have had to perform 2880 multiplies per <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) input sample. So, happily, our two-stage interpolation process reduced the number of necessary filter multiplies by almost a factor of three relative to a single-stage interpolation.</p>
<p class="calibre3"><a id="calibre_link-3038"></a></p>
<h4 class="calibre13">10.8.3 Two-Stage Interpolation Considerations</h4>
<p class="calibre3">Due to the duality between decimation and interpolation, for computational efficiency reasons as presented in reference <a href="#calibre_link-131">[3]</a>, it’s beneficial to interpolate in order from the smallest to the largest factor. That is, we make sure that <em class="calibre7">L</em><sub class="calibre12">1</sub> is smaller than <em class="calibre7">L</em><sub class="calibre12">2</sub>.</p>
<p class="calibre3">Also, it is advantageous to consider setting the <em class="calibre7">L</em><sub class="calibre12">1</sub> and <em class="calibre7">L</em><sub class="calibre12">2</sub> interpolation factors equal to integer powers of two because we can use computationally efficient half-band filters for the lowpass filters in <a href="#calibre_link-155">Figure 10-15(c)</a>. We discuss the use of multirate half-band filtering later in <a href="#calibre_link-129">Section 10.11</a>.</p>
<p class="calibre3">As with dual-stage decimation, if the single-filter system in <a href="#calibre_link-155">Figure 10-15(a)</a> is required to have a passband peak-peak ripple of <em class="calibre7">R</em> dB (<em class="calibre7">R</em> decibels), then each filter in <a href="#calibre_link-155">Figure 10-15(c)</a> must be designed to have passband peak-peak ripple of no greater than <em class="calibre7">R</em>/2 dB. We have previously mentioned that interpolation has an inherent amplitude loss. Thus, to achieve unity gain between sequences <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) and <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">m</em>) in <a href="#calibre_link-155">Figure 10-15(c)</a>, the product of the DC (zero Hz) gains of the LPF<sub class="calibre12">1</sub> and LPF<sub class="calibre12">2</sub> filters must be equal to <em class="calibre7">L</em>.</p>
<p class="calibre3">The advantages of two-stage interpolation, over single-stage interpolation, are identical to the advantages of two-stage decimation listed at the end of <a href="#calibre_link-150">Section 10.2</a>. Be aware that references <a href="#calibre_link-120">[1]</a> and <a href="#calibre_link-131">[3]</a> discuss aspects of multistage interpolation where the number of stages is greater than two.</p>
<p class="calibre3">In concluding this section, we mention that <a href="#calibre_link-160">Chapter 13</a> contains three DSP tricks regarding interpolation of time-domain signals. Now that we have some familiarity with sample rate conversion, for completeness let’s review the standard mathematical notation used to describe these operations using polyphase filters. Learning that notation will aid readers as they encounter other descriptions of sample rate conversion in the literature of DSP.</p>
<p class="calibre3"><a id="calibre_link-658"></a></p>
<h3 class="calibre6"><a id="calibre_link-2385" class="calibre5"></a>10.9 <em class="calibre17">z</em>-Transform Analysis of Multirate Systems</h3>
<p class="calibre3">In preparation for the multirate filter material in the following sections, here we formalize both our terminology and notation of sample rate conversion operations.</p>
<p class="calibre3">First, there is a fair amount of variety (some would call it “ambiguity”) in the literature of DSP regarding the language of sample rate conversion. If you’ve been reading the literature, you may have noticed that the terminology used has been, unfortunately, very inconsistent&mdash;sometimes downright confusing. A wide variety of terms are used in the literature as shown in <a href="#calibre_link-161">Figure 10-17</a> where “LPF” means lowpass filter. In the spirit of consistency, from here on we’ll use the terminology indicated by the bold underlined font in <a href="#calibre_link-161">Figure 10-17</a>.</p>
<p class="caption"><a id="calibre_link-161"></a><strong class="calibre9">Figure 10-17</strong> Sample rate conversion terminology: (a) sample rate increase; (b) sample rate reduction.</p>
<p class="image"><img src="images/000237.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3039"></a></p>
<h4 class="calibre13">10.9.1 Signal Mathematical Notation</h4>
<p class="calibre3">Compared to the written language of sample rate conversion, the mathematical notation of sample rate conversion is quite consistent if we use <em class="calibre7">z</em>-transform representations. For example, if a time-domain sequence <em class="calibre7">x</em>(<em class="calibre7">n</em>), having a <em class="calibre7">z</em>-transform of</p>
<p class="caption"><a id="calibre_link-3040"></a>(10-9)</p>
<p class="image"><img src="images/001805.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">is upsampled by two (<em class="calibre7">L</em> = 2, a single zero-valued sample is inserted between each <em class="calibre7">x</em>(<em class="calibre7">n</em>) sample), producing a <em class="calibre7">w</em>(<em class="calibre7">m</em>) sequence as shown in <a href="#calibre_link-161">Figure 10-17(a)</a>, then we can describe <em class="calibre7">w</em>(<em class="calibre7">m</em>) as</p>
<p class="caption"><a id="calibre_link-162"></a>(10-10)</p>
<p class="image"><img src="images/000605.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2384"></a><a href="#calibre_link-162">Equation (10-10)</a> indicates that every other <em class="calibre7">w</em>(<em class="calibre7">m</em>) sample is zero. Considering only the nonzero values of <em class="calibre7">w</em>(<em class="calibre7">m</em>), the <em class="calibre7">z</em>-transform of <em class="calibre7">w</em>(<em class="calibre7">m</em>) is expressed as</p>
<p class="caption"><a id="calibre_link-163"></a>(10-11)</p>
<p class="image"><img src="images/001464.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where <em class="calibre7">m</em> represents even-valued integers and <em class="calibre7">k</em> represents all integers. If the <em class="calibre7">w</em>(<em class="calibre7">m</em>) sequence is an upsampled-by-integer-<em class="calibre7">L</em> version of <em class="calibre7">x</em>(<em class="calibre7">n</em>) (inserting <em class="calibre7">L</em>&ndash;1 zero-valued samples between each <em class="calibre7">x</em>(<em class="calibre7">n</em>) sample), then <em class="calibre7">w</em>(<em class="calibre7">m</em>)’s <em class="calibre7">z</em>-transform is expressed as</p>
<p class="caption"><a id="calibre_link-164"></a>(10-12)</p>
<p class="image"><img src="images/000503.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">In a similar manner, some authors express the <em class="calibre7">z</em>-transform of sequence <em class="calibre7">x</em>(<em class="calibre7">n</em>) as</p>
<p class="caption"><a id="calibre_link-165"></a>(10-13)</p>
<p class="image"><img src="images/001447.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">So here is the point: When we see expressions like <a href="#calibre_link-163">Eqs. (10-11)</a>, <a href="#calibre_link-164">(10-12)</a>, or <a href="#calibre_link-165">(10-13)</a>, they merely mean that sequence <em class="calibre7">w</em>(<em class="calibre7">m</em>) is an upsampled-by-<em class="calibre7">L</em> version of sequence <em class="calibre7">x</em>(<em class="calibre7">n</em>), and sequence <em class="calibre7">x</em>(<em class="calibre7">n</em>) is a decimated-by-<em class="calibre7">L</em> version of sequence <em class="calibre7">w</em>(<em class="calibre7">m</em>).</p>
<p class="calibre3"><a id="calibre_link-3041"></a></p>
<h4 class="calibre13">10.9.2 Filter Mathematical Notation</h4>
<p class="calibre3">With the above multirate notation fresh in our minds, let’s consider how we can use that notation to describe digital polyphase filters. If we have a tapped-delay line FIR filter, having <em class="calibre7">N</em> taps, whose impulse response is <em class="calibre7">h</em>(<em class="calibre7">k</em>), then we can represent the filter’s <em class="calibre7">z</em>-domain transfer function as</p>
<p class="caption"><a id="calibre_link-166"></a>(10-14)</p>
<p class="image"><img src="images/000399.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">For an <em class="calibre7">N</em> = 9-tap FIR filter, for example, from <a href="#calibre_link-166">Eq. (10-14)</a> its <em class="calibre7">z</em>-domain transfer function is</p>
<p class="caption"><a id="calibre_link-167"></a>(10-15)</p>
<p class="image"><img src="images/001250.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">In both up- and downsample-by-integer-factor-<em class="calibre7">Q</em> filtering applications, for computational efficiency reasons, we partition <em class="calibre7">H</em>(<em class="calibre7">z</em>) into <em class="calibre7">Q</em> separate subfilters <a id="calibre_link-2403"></a>using the polyphase decomposition process. For example, if <em class="calibre7">Q</em> = 3, we can write <em class="calibre7">H</em>(<em class="calibre7">z</em>) as</p>
<p class="caption"><a id="calibre_link-168"></a>(10-16)</p>
<p class="image"><img src="images/000288.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">(Read no further until you convince yourself that <a href="#calibre_link-167">Eqs. (10-15)</a> and <a href="#calibre_link-168">(10-16)</a> are equivalent.) Due to the exponents of <em class="calibre7">z</em> in <a href="#calibre_link-168">Eq. (10-16)</a> we can write</p>
<p class="caption"><a id="calibre_link-169"></a>(10-17)</p>
<p class="image"><img src="images/001130.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where</p>
<p class="caption"><a id="calibre_link-173"></a>(10-17′)</p>
<p class="image"><img src="images/000177.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The notation in the last line of <a href="#calibre_link-169">Eq. (10-17)</a> seems, at first, like a needless complication in describing the 9-tap <em class="calibre7">h</em>(<em class="calibre7">k</em>) filter, but shortly we will see why such notation is <em class="calibre7">very</em> useful.</p>
<p class="calibre3"><a id="calibre_link-248"></a></p>
<h3 class="calibre6">10.10 Polyphase Filter Implementations</h3>
<p class="calibre3">Let’s now use the above <em class="calibre7">z</em>-domain transfer functions to help us understand the most popular forms of polyphase filtering in multirate systems. <a href="#calibre_link-169">Equation (10-17)</a>, when followed by downsampling by <em class="calibre7">M</em> = 3, is depicted graphically in <a href="#calibre_link-170">Figure 10-18</a>, showing the three subfilters. We interpret the notation of the top subfilter, <em class="calibre7">H</em><sub class="calibre12">0</sub>(<em class="calibre7">z</em><sup class="calibre10">3</sup>) in <a href="#calibre_link-170">Figure 10-18</a>, as a tapped-delay line wherein there are <a id="calibre_link-2387"></a><em class="calibre7">M</em> = 3 delay elements between each tap. To pause for a moment, what we’re doing here is showing the algebraic and graphical notation used to describe the polyphase decomposition of a 9-tap prototype FIR filter used in a decimation-by-three application.</p>
<p class="caption"><a id="calibre_link-170"></a><strong class="calibre9">Figure 10-18</strong> Polyphase decomposition of <em class="calibre7">H</em>(<em class="calibre7">z</em>) prior to downsampling by <em class="calibre7">M</em> = 3.</p>
<p class="image"><img src="images/001078.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The detailed structure of the FIR filter in <a href="#calibre_link-170">Figure 10-18</a> is shown in <a href="#calibre_link-171">Figure 10-19</a>, where we see the polyphase decomposition of <em class="calibre7">h</em>(<em class="calibre7">k</em>) into three subfilters, creating a polyphase filter.</p>
<p class="caption"><a id="calibre_link-171"></a><strong class="calibre9">Figure 10-19</strong> Details of the polyphase decomposition of <em class="calibre7">H</em>(<em class="calibre7">z</em>) for decimation <em class="calibre7">M</em> = 3.</p>
<p class="image"><img src="images/000134.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">When the multirate concepts described above were first applied to the impulse responses of digital filters, DSP pioneers quickly arrived at the impressive-sounding “noble identities” graphically depicted in <a href="#calibre_link-172">Figure 10-20</a>. Those complementary identities, showing the equivalency of swapping the order of filters and up/downsamplers, are exceedingly useful in the analysis and implementation of multirate systems as we shall see in the next section. In <a href="#calibre_link-172">Figure 10-20</a> the <em class="calibre7">H</em>(<em class="calibre7">z</em>) term is the <em class="calibre7">z</em>-transform of a filter’s <em class="calibre7">h</em>(<em class="calibre7">n</em>) impulse response, and the <em class="calibre7">H</em>(<em class="calibre7">z<sup class="calibre10">Q</sup></em>) term is the <em class="calibre7">z</em>-transform of <em class="calibre7">h</em>(<em class="calibre7">n</em>) upsampled by integer <em class="calibre7">Q</em>, similar in form to <a href="#calibre_link-169">Eqs. (10-17)</a> and <a href="#calibre_link-173">(10-17′)</a>.</p>
<p class="caption"><a id="calibre_link-172"></a><strong class="calibre9">Figure 10-20</strong> Noble identities of multirate systems: (a) sample rate increase; (b) sample rate reduction.</p>
<p class="image"><img src="images/000972.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Using the noble identities, we can move the downsampling by <em class="calibre7">M</em> = 3 operation in front of the subfilters in <a href="#calibre_link-170">Figure 10-18</a> as shown in <a href="#calibre_link-174">Figure 10-21(a)</a>. A detailed depiction of the polyphase filter is provided in <a href="#calibre_link-174">Figure 10-21(b)</a>, where we also rearranged the initial delay elements at the input of the filter.</p>
<p class="caption"><a id="calibre_link-174"></a><strong class="calibre9">Figure 10-21</strong> Polyphase decomposition of <em class="calibre7">h</em>(<em class="calibre7">k</em>), for decimation by <em class="calibre7">M</em> = 3: (a) simplified depiction; (b) detailed depiction.</p>
<p class="image"><img src="images/000026.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3042"></a>In that figure we see that the delay lines between the filter coefficients now contain only a single delay element and the subfilters can be described by</p>
<p class="caption"><a id="calibre_link-3043"></a>(10-18)</p>
<p class="image"><img src="images/001019.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The upper subfilters in <a href="#calibre_link-171">Figures 10-19</a> and <a href="#calibre_link-174">10-21(b)</a> make obvious the meaning of our notation regarding <em class="calibre7">H</em><sub class="calibre12">0</sub>(<em class="calibre7">z</em><sup class="calibre10">3</sup>) and <em class="calibre7">H</em><sub class="calibre12">0</sub>(<em class="calibre7">z</em>), for example. That is, <em class="calibre7">H</em><sub class="calibre12">0</sub>(<em class="calibre7">z</em><sup class="calibre10">3</sup>) is merely an upsampled-by-three version of <em class="calibre7">H</em><sub class="calibre12">0</sub>(<em class="calibre7">z</em>).</p>
<p class="calibre3">One final simplification available for polyphase decimation filters is shown in <a href="#calibre_link-175">Figure 10-22</a>, where the two initial delay elements and the downsampling by <em class="calibre7">M</em> = 3 operations in <a href="#calibre_link-174">Figure 10-21(b)</a> are replaced by a three-position commutating (multiplexing) switch. One <em class="calibre7">y</em>(<em class="calibre7">m</em>) output sample is produced each time the switch completes a single full (three-step) rotation.</p>
<p class="caption"><a id="calibre_link-2401"></a><a id="calibre_link-175"></a><strong class="calibre9">Figure 10-22</strong> Simplified polyphase decomposition of <em class="calibre7">h</em>(<em class="calibre7">k</em>), for decimation by <em class="calibre7">M</em> = 3.</p>
<p class="image"><img src="images/000867.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">In an identical manner, interpolation by <em class="calibre7">L</em> = 3 (upsampling by three followed by lowpass filtering) by way of polyphase decomposition is depicted in <a href="#calibre_link-176">Figure 10-23(a)</a>. The subfilters in that figure are identical to the subfilters from <a href="#calibre_link-169">Eq. (10-17)</a> and <a href="#calibre_link-171">Figure 10-19</a>. Looking at <a href="#calibre_link-176">Figure 10-23(b)</a>, we see that the upsamplers insert two zero-valued samples between each output sample of the three subfilters. The delay elements delay those upsampled sequences by various delay times such that at each output time instant only one of the inputs to the final summation is nonzero. So instead of performing a summation of mostly zero-valued samples, we can select only the path to the summer that contains a nonzero sample.</p>
<p class="caption"><a id="calibre_link-176"></a><strong class="calibre9">Figure 10-23</strong> Polyphase decomposition of <em class="calibre7">h</em>(<em class="calibre7">k</em>), for interpolation by <em class="calibre7">L</em> = 3: (a) simple depiction; (b) reduced-length subfilters; (c) final structure.</p>
<p class="image"><img src="images/001723.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Thinking about this path selection process (multiplexing), happily we can use the three-path commutating switch in <a href="#calibre_link-176">Figure 10-23(c)</a> for multipath selection and eliminate the delay elements, the upsamplers, and the final summation. As each new <em class="calibre7">x</em>(<em class="calibre7">n</em>) input sample is available, the switch completes a single full (three-step) rotation, producing three <em class="calibre7">y</em>(<em class="calibre7">m</em>) output samples.</p>
<p class="calibre3">Again, the purpose of the material in this section is to show the algebraic and graphical notation typically used to describe FIR polyphase filters used in sample rate conversion applications.</p>
<p class="calibre3"><a id="calibre_link-2402"></a>The major benefits of using polyphase filters for sample rate conversion are:</p>
<p class="indenthangingb">• Signal data storage requirements are minimized.</p>
<p class="indenthangingb">• No multiply by zero computations are performed (for interpolation).</p>
<p class="indenthangingb">• No computational results are discarded (for decimation).</p>
<p class="indenthangingb">• A key benefit is that the computations are performed at the lower sample rate. For an <em class="calibre7">N</em>-tap FIR filter, polyphase decimation implementations <a id="calibre_link-2416"></a>reduce the number of multiplications per unit time to 1/<em class="calibre7">M</em> times the number of multiplications per unit time with no polyphase decomposition. This advantage may be critical in high-data-rate applications and leads to lower power consumption in battery-powered devices.</p>
<p class="calibre3">In the following sections we introduce several specialized digital filters developed specifically to minimize the computational workload encountered in sample rate conversion applications. As such, let’s have a look at rational-factor sample rate change filters first.</p>
<p class="calibre3"><a id="calibre_link-129"></a></p>
<h3 class="calibre6">10.11 Sample Rate Conversion by Rational Factors</h3>
<p class="calibre3">In the event that we wish to resample a signal by a rational factor <em class="calibre7">L</em>/<em class="calibre7">M</em> (as in <a href="#calibre_link-140">Figure 10-9(b)</a>), we can interpolate by integer factor <em class="calibre7">L</em> followed by downsampling by integer factor <em class="calibre7">M</em>. Our single lowpass filter comprises the <em class="calibre7">L</em> polyphase subfilters shown in <a href="#calibre_link-177">Figure 10-24(a)</a>, where the input and output sample rates are related by</p>
<p class="caption"><a id="calibre_link-3044"></a>(10-19)</p>
<p class="image"><img src="images/000603.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-177"></a><strong class="calibre9">Figure 10-24</strong> Resampling by rational-factor <em class="calibre7">L/M</em>: (a) fundamental process; (b) no downsampling; (c) addressed-ROM scheme.</p>
<p class="image"><img src="images/000747.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">However, this naive approach would not be sensible because we’d be computing some <em class="calibre7">w</em>(<em class="calibre7">p</em>) samples that are destined to be discarded by the downsample-by-<em class="calibre7">M</em> process.</p>
<p class="calibre3">Attempting to avoid that computational inefficiency, we can omit the downsampling process altogether and merely control the position of the interpolator’s output commutating switch position as depicted in <a href="#calibre_link-177">Figure 10-24(b)</a>. For example, if we rotate the switch but skip alternate switch output ports, we achieve resampling by a factor of <em class="calibre7">L</em>/2. If we advance the switch to every third output position, for each <em class="calibre7">y</em>(<em class="calibre7">m</em>) output sample, we’ll have resampling by a factor of <em class="calibre7">L</em>/3, and so on. This commutating switch control mechanism idea means that we need only compute the output of a single subfilter for each <em class="calibre7">y</em>(<em class="calibre7">m</em>) output sample. In resampling by a rational factor <em class="calibre7">L</em>/<em class="calibre7">M</em>, the switch output port (index of a single subfilter) used to compute a <em class="calibre7">y</em>(<em class="calibre7">m</em>) output sample is found using</p>
<p class="caption"><a id="calibre_link-179"></a>(10-20)</p>
<p class="image"><img src="images/000798.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where &lt;<em class="calibre7">mM</em>&gt;<em class="calibre7"><sub class="calibre12">L</sub></em> means compute the product <em class="calibre7">mM</em> modulo-<em class="calibre7">L</em>. So the switch output port counter in <a href="#calibre_link-177">Figure 10-24(b)</a> is a binary modulo-<em class="calibre7">L</em> counter. As the resampler operates, the index <em class="calibre7">n</em>, of the most recent input <em class="calibre7">x</em>(<em class="calibre7">n</em>) applied to the subfilters, is given by</p>
<p class="caption"><a id="calibre_link-180"></a>(10-20′)</p>
<p class="image"><img src="images/001656.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3045"></a>where <img src="images/000729.jpg" alt="image" class="calibre2" /> means the integer part of <em class="calibre7">mM</em>/<em class="calibre7">L</em>. The actual resampler difference equation is</p>
<p class="caption"><a id="calibre_link-181"></a>(10-20″)</p>
<p class="image"><img src="images/001660.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where <em class="calibre7">N</em> is the number of taps in the prototype FIR filter from which the polyphase <em class="calibre7">H<sub class="calibre12">k</sub></em>(<em class="calibre7">z</em>) subfilters in <a href="#calibre_link-177">Figure 10-24(b)</a> were obtained.</p>
<p class="calibre3">For a numerical example, the left side of <a href="#calibre_link-178">Table 10-1</a> shows the commutating switch output port index <em class="calibre7">k</em> (index of a single subfilter), and the input <em class="calibre7">x</em>(<em class="calibre7">n</em>) index <em class="calibre7">n</em>, as a function of a resampler’s <em class="calibre7">m</em>th <em class="calibre7">y</em>(<em class="calibre7">m</em>) output sample index for resampling by a factor of <em class="calibre7">L</em>/<em class="calibre7">M</em> = 4/3. In this case, the switch counter counts <a id="calibre_link-3046"></a>as <em class="calibre7">k</em> = 0,3,2,1,0,3,2,1, and so on. The right side of <a href="#calibre_link-178">Table 10-1</a> shows the switch indexing for resampling by 3/4. In that scenario, the switch counter counts as <em class="calibre7">k</em> = 0,1,2,0,1,2, and so on.</p>
<p class="caption"><a id="calibre_link-178"></a><strong class="calibre9">Table 10-1</strong> Indexing for Resampling by 4/3 and 3/4</p>
<p class="image"><img src="images/001586.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">In our daily lives we hear the phrase “Timing is everything.” Well, that’s certainly true in our resampling schemes. In <a href="#calibre_link-177">Figure 10-24(b)</a> we must remember that when the commutating switch resides at position <em class="calibre7">k</em> = 0, and when during its cycling it crosses the <em class="calibre7">k</em> = 0 position, we must input a new <em class="calibre7">x</em>(<em class="calibre7">n</em>) sample <em class="calibre7">before</em> we compute a <em class="calibre7">y</em>(<em class="calibre7">m</em>) output sample. The times when a new <em class="calibre7">x</em>(<em class="calibre7">n</em>) input sample is applied to the subfilters, before a <em class="calibre7">y</em>(<em class="calibre7">m</em>) sample is computed, are indicated by the left-pointing arrows in <a href="#calibre_link-178">Table 10-1</a>.</p>
<p class="calibre3">Be aware that it’s possible that more than one <em class="calibre7">x</em>(<em class="calibre7">n</em>) input sample must be applied to the resampler prior to an output <em class="calibre7">y</em>(<em class="calibre7">m</em>) computation for decimation applications. For example, on the right side of <a href="#calibre_link-178">Table 10-1</a>, when <em class="calibre7">m</em> = 3, we are forced to apply both the <em class="calibre7">x</em>(3) <em class="calibre7">and x</em>(4) input samples to the resampler before computing <em class="calibre7">y</em>(3).</p>
<p class="calibre3">OK, let’s stop and catch our breath here. If we were to substitute the expressions for <em class="calibre7">k</em> and <em class="calibre7">n</em>, from <a href="#calibre_link-179">Eqs. (10-20)</a> and <a href="#calibre_link-180">(10-20′)</a>, into <a href="#calibre_link-181">Eq. (10-20″)</a>, we would produce a rather complicated algebraic expression for <em class="calibre7">y</em>(<em class="calibre7">m</em>). However, we will not let such an equation for <em class="calibre7">y</em>(<em class="calibre7">m</em>) intimidate us because the <em class="calibre7">h</em>(<em class="calibre7">pL</em> + <em class="calibre7">k</em>) term in <a href="#calibre_link-181">Eq. (10-20″)</a> merely specifies the coefficients of the <em class="calibre7">k</em>th subfilter, and the <a id="calibre_link-2310"></a><em class="calibre7">x</em>(<em class="calibre7">n</em> &ndash; <em class="calibre7">p</em>) term simply defines the <em class="calibre7">x</em>(<em class="calibre7">n</em>) input samples residing in that <em class="calibre7">k</em>th subfilter. As such, we see that <a href="#calibre_link-181">Eq. (10-20″)</a> is no more than a convolution equation where the summation index <em class="calibre7">p</em> accounts for each of the <em class="calibre7">N</em>/<em class="calibre7">L</em> coefficients in a subfilter. (<em class="calibre7">N</em>/<em class="calibre7">L</em> is an integer.)</p>
<p class="calibre3">Notice that the tapped-delay lines of each subfilter in <a href="#calibre_link-177">Figure 10-24(b)</a> contain the same <em class="calibre7">x</em>(<em class="calibre7">n</em>) time samples. To reduce input signal data storage requirements, we can use a single tapped-delay line as we described for <a href="#calibre_link-144">Figure 10-13</a>. So in our rational-factor resampling implementation, shown in <a href="#calibre_link-177">Figure 10-24(c)</a>, the modulo-<em class="calibre7">L</em> counter output index <em class="calibre7">k</em> now becomes a pointer pointing to a bank of read-only memory (ROM) locations that contain the <em class="calibre7">N</em>/<em class="calibre7">L</em> coefficients of the <em class="calibre7">k</em>th subfilter. For each updated value of <em class="calibre7">k</em> in <a href="#calibre_link-178">Table 10-1</a> we use the <em class="calibre7">k</em>th set of subfilter coefficients to compute <em class="calibre7">y</em>(<em class="calibre7">m</em>). The control of applying a new <em class="calibre7">x</em>(<em class="calibre7">n</em>) input sample, or samples, to the resampler before computing a <em class="calibre7">y</em>(<em class="calibre7">m</em>) output sample is indicated by the dashed line to the Input Switch in <a href="#calibre_link-177">Figure 10-24(c)</a>. As such, each time the modulo-<em class="calibre7">L</em> ROM address counter overflows, we apply new <em class="calibre7">x</em>(<em class="calibre7">n</em>) input samples to the resampler.</p>
<p class="calibre3">To conclude this rational-factor resampling discussion, there are three practical issues we must keep in mind. First, if we want the DC (zero Hz) gain of our resampling process to be unity, then the original prototype lowpass FIR filter must have a DC gain of <em class="calibre7">L</em> to compensate for the amplitude loss by a factor of <em class="calibre7">L</em> caused by interpolation. (The downsampling by <em class="calibre7">M</em> causes no amplitude change.) To achieve a DC gain of <em class="calibre7">L</em>, the sum of the prototype filter’s <em class="calibre7">h</em>(<em class="calibre7">k</em>) coefficients must equal <em class="calibre7">L</em>.</p>
<p class="calibre3">Second, to avoid aliasing errors after downsampling, in designing the original prototype lowpass FIR filter, the filter’s passband width must not be greater than <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,in</sub>/2 or (<em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,in</sub>/2) · (<em class="calibre7">L</em>/<em class="calibre7">M</em>), whichever is smaller, where <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,in</sub> is <em class="calibre7">x</em>(<em class="calibre7">n</em>)’s sample rate, and <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,out</sub> is the filter’s data rate, in Hz. The stopband attenuation of the prototype filter must be such that the attenuated upsampled images do not induce intolerable levels of noise when they’re aliased by downsampling by <em class="calibre7">M</em> into the final band of 0 to <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,out</sub>/2 Hz.</p>
<p class="calibre3">Third, from a computational efficiency standpoint, the rational-factor resampling scheme described in this section has the power of George Foreman’s right hand.</p>
<p class="calibre3"><a id="calibre_link-659"></a></p>
<h3 class="calibre6">10.12 Sample Rate Conversion with Half-band Filters</h3>
<p class="calibre3">Recall that the half-band filters we introduced in <a href="#calibre_link-182">Section 5.7</a> have a frequency magnitude response with transition regions centered at ±<em class="calibre7">f<sub class="calibre12">s</sub></em>/4 as shown in <a href="#calibre_link-183">Figure 10-25(a)</a>. Those filters are linear-phase lowpass tapped-delay line FIR filters in which every other filter coefficient is zero, except the center coefficient. We discuss half-band filters here because their sparse nonzero coefficient sets make them ideal for use in sample rate conversion applications where the resampling factor is an integer power of two (2, 4, 8, etc.).</p>
<p class="caption"><a id="calibre_link-183"></a><strong class="calibre9">Figure 10-25</strong> Half-band filters: (a) filter frequency magnitude response; (b) decimation by eight; (c) spectral overlap after decimation by two.</p>
<p class="image"><img src="images/001606.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3047"></a></p>
<h4 class="calibre13"><a id="calibre_link-2308"></a>10.12.1 Half-band Filtering Fundamentals</h4>
<p class="calibre3">An example of sample rate change by an integer power of two is shown in <a href="#calibre_link-183">Figure 10-25(b)</a> where the same <em class="calibre7">h</em>(<em class="calibre7">k</em>) half-band filter is used three times to achieve decimation by eight. If the sample rate at the input of the three-stage decimation is <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,in</sub>, the sample rate at the output is <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,in</sub>/8.</p>
<p class="calibre3">We remind the reader that due to the nature of half-band filters there will be some amount of spectral overlap, and thus some aliasing, after each downsample-by-two operation. This is shown in <a href="#calibre_link-183">Figure 10-25(c)</a> for the first decimation-by-two stage, where the spectral replications are shown as dotted lines centered at integer multiples of the sample rate <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,in</sub>/2. The amount of spectral overlap is proportional to the transition region width of the filters (inversely proportional to the number of <em class="calibre7">h</em>(<em class="calibre7">k</em>) half-band filter taps).</p>
<p class="calibre3">It’s normal to use the same half-band filter in multistage decimation by two as was done in <a href="#calibre_link-183">Figure 10-25(b)</a>. However, in multistage interpolation by factors of two it would be computationally inefficient to use the same half-band filter in each stage. <a href="#calibre_link-184">Figure 10-26</a> helps explain why this is true. Consider the <em class="calibre7">x</em>(<em class="calibre7">n</em>) signal in <a href="#calibre_link-184">Figure 10-26(a)</a> that we wish to interpolate by a factor of eight. The <em class="calibre7">x</em>(<em class="calibre7">n</em>) signal’s spectrum is that shown in <a href="#calibre_link-184">Figure 10-26(b)</a> where the spectral replications are shown as dotted lines centered at integer multiples of the input sample rate <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,in</sub>. The signal at node A, after <em class="calibre7">x</em>(<em class="calibre7">n</em>) has been upsampled by two via zeros insertion, has the |<em class="calibre7">A</em>(<em class="calibre7">f</em>)| spectrum shown in <a href="#calibre_link-184">Figure 10-26(c)</a> where the new sample rate is 2<em class="calibre7">f</em><sub class="calibre12"><em class="calibre7">s</em>,in</sub>.</p>
<p class="caption"><a id="calibre_link-3048"></a><a id="calibre_link-184"></a><strong class="calibre9">Figure 10-26</strong> Multistage interpolation using half-band filters.</p>
<p class="image"><img src="images/001581.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The job of the <em class="calibre7">h</em><sub class="calibre12">1</sub>(<em class="calibre7">k</em>) filter in <a href="#calibre_link-184">Figure 10-26(a)</a> is to eliminate the spectral images in |<em class="calibre7">A</em>(<em class="calibre7">f</em>)| centered at ±<em class="calibre7">f</em><sub class="calibre12"><em class="calibre7">s</em>,in</sub> (half the sample rate at node A). We show <em class="calibre7">h</em><sub class="calibre12">1</sub>(<em class="calibre7">k</em>)’s magnitude response as the dashed |<em class="calibre7">H</em><sub class="calibre12">1</sub>(<em class="calibre7">f</em>)| lines in <a href="#calibre_link-184">Figure 10-26(c)</a>. The output of the <em class="calibre7">h</em><sub class="calibre12">1</sub>(<em class="calibre7">k</em>) half-band filter, node B, has the |<em class="calibre7">B</em>(<em class="calibre7">f</em>)| spectrum shown in <a href="#calibre_link-184">Figure 10-26(d)</a>. After the signal at node B is upsampled by two, the <em class="calibre7">h</em><sub class="calibre12">2</sub>(<em class="calibre7">k</em>) half-band filter must have the frequency magnitude response shown as |<em class="calibre7">H</em><sub class="calibre12">2</sub>(<em class="calibre7">f</em>)| in <a href="#calibre_link-184">Figure 10-26(d)</a>. Because the transition region width of |<em class="calibre7">H</em><sub class="calibre12">2</sub>(<em class="calibre7">f</em>)| is so much wider than the transition region width of |<em class="calibre7">H</em><sub class="calibre12">1</sub>(<em class="calibre7">f</em>)|, the <em class="calibre7">h</em><sub class="calibre12">2</sub>(<em class="calibre7">k</em>) filter will require fewer coefficients than did the <em class="calibre7">h</em><sub class="calibre12">1</sub>(<em class="calibre7">k</em>) filter. For similar reasons the <em class="calibre7">h</em><sub class="calibre12">3</sub>(<em class="calibre7">k</em>) filter will require fewer coefficients than the <em class="calibre7">h</em><sub class="calibre12">2</sub>(<em class="calibre7">k</em>) filter.</p>
<p class="calibre3">What we’re saying is this: Unlike multistage decimation by powers of two, in our relentless pursuit of computational efficiency, multistage interpolation by powers of two should not use the same half-band filter in each stage. In multistage interpolation each follow-on half-band filter requires fewer taps than the preceding filter. Because we like to minimize the number of necessary multiplications per second in real-time applications, we take comfort in the fact that the half-band interpolation filter requiring the most computations per output sample, <em class="calibre7">h</em><sub class="calibre12">1</sub>(<em class="calibre7">k</em>), operates at the lowest sample rate.</p>
<p class="calibre3"><a id="calibre_link-2309"></a>From a practical standpoint, we remind the reader that if we use an FIR filter design software package to design half-band filters, unavoidable numerical computation errors will yield alternating filter coefficients that are indeed very small but not exactly zero-valued. So in our filter modeling efforts, we must force those very small coefficient values to zero before we proceed to analyze half-band filter frequency responses.</p>
<p class="calibre3"><a id="calibre_link-3049"></a></p>
<h4 class="calibre13">10.12.2 Half-band Filter Implementations</h4>
<p class="calibre3">Here we discuss several important aspects of implementing half-band FIR filters for sample rate conversion and show why these filters are computationally efficient. We illustrate half-band filter implementations in sample rate <a id="calibre_link-3050"></a>conversion applications with a decimation-by-two example showing the details of a polyphase decomposition process.</p>
<p class="calibre3">Suppose we need an <em class="calibre7">N</em> = 11-tap half-band FIR filter in a decimation-by-two application. We could use a standard 11-tap tapped-delay line half-band filter, as discussed in <a href="#calibre_link-79">Chapter 5</a>, followed by a downsample-by-two operation. Instead we choose to use polyphase decomposition as shown in <a href="#calibre_link-185">Figure 10-27(a)</a>.</p>
<p class="caption"><a id="calibre_link-185"></a><strong class="calibre9">Figure 10-27</strong> An 11-tap polyphase half-band decimation filter: (a) polyphase form; (b) polyphase with downsampling prior to filtering.</p>
<p class="image"><img src="images/001487.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Recall that a prototype FIR filter, which we want to decompose into <em class="calibre7">Q</em> polyphase subfilters for a resample by <em class="calibre7">Q</em> application, must have an integer multiple of <em class="calibre7">Q</em> taps. So we can think of our 11-tap FIR filter as being a 12-tap filter with the <em class="calibre7">h</em>(11) twelfth coefficient being zero-valued.</p>
<p class="calibre3">Read no further until you convince yourself that the two subfilters in <a href="#calibre_link-185">Figure 10-27(a)</a>, whose outputs are summed, is equivalent to a standard 11-tap tapped-delay line half-band filter, where both implementations have a <em class="calibre7">z</em>-domain transfer function of</p>
<p class="caption"><a id="calibre_link-3051"></a>(10-21)</p>
<p class="image"><img src="images/000683.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Next, we place the downsample-by-two operation in <a href="#calibre_link-185">Figure 10-27(a)</a> ahead of the tapped-delay lines as shown in <a href="#calibre_link-185">Figure 10-27(b)</a>. That modification, because of our noble identities, reduces each dual delay element in <a href="#calibre_link-185">Figure 10-27(a)</a> to a single delay element as shown in <a href="#calibre_link-185">Figure 10-27(b)</a>.</p>
<p class="caption"><a id="calibre_link-186"></a><strong class="calibre9">Figure 10-27</strong> Half-band filter implementations: (c) decimation by two; (d) interpolation by two.</p>
<p class="image"><img src="images/000521.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-2267"></a>Applying the input commutating switch implementation introduced in <a href="#calibre_link-177">Figure 10-24</a>, our <a href="#calibre_link-185">Figure 10-27(b)</a> decimation-by-two polyphase half-band filter becomes what is shown in <a href="#calibre_link-186">Figure 10-27(c)</a>. Because only one of the odd-indexed filter coefficients is nonzero, namely <em class="calibre7">h</em>(5) ≠ 0, we have only one multiply operation in the bottom path of our final polyphase half-band filter. Again, by using this polyphase implementation, we compute no filter output samples destined to be discarded by the downsample-by-two operation, and happily all filter computations take place at the decimated (lower) sample rate.</p>
<p class="calibre3"><a href="#calibre_link-186">Figure 10-27(d)</a> presents the structure of a polyphase version of a half-band filter that eliminates any multiply by zero computations in an interpolation-by-two application.</p>
<p class="calibre3">If the number of taps in a half-band filter is <em class="calibre7">N</em>, where <em class="calibre7">N</em>+1 is an integer multiple of four, then the number of unit-delay elements in the filters’ bottom paths in <a href="#calibre_link-185">Figures 10-27(c)</a> and <a href="#calibre_link-185">10-27(d)</a> is (<em class="calibre7">N</em>&ndash;3)/4.</p>
<p class="calibre3">Because the half-band filter coefficients in the top path are symmetrical, thankfully, we can use the <em class="calibre7">folded</em> FIR filter scheme described in <a href="#calibre_link-148">Section 13.7</a> to reduce the number of multipliers in the top path by a factor of two. This means we can achieve the filtering performance of an <em class="calibre7">N</em>-tap half-band FIR filter while performing only, roughly, <em class="calibre7">N</em>/4 multiplies per filter output sample. Neat!</p>
<p class="calibre3">If <a href="#calibre_link-185">Figures 10-27(c)</a> and <a href="#calibre_link-185">10-27(d)</a>’s half-band filters’ coefficients are designed such that <em class="calibre7">h</em>(5) = 0.5, which is often the case with commercial filter design software, the bottom path’s multiplication by <em class="calibre7">h</em>(5) can be replaced with a binary right-shift-by-one-bit operation. On the other hand, to compensate for the amplitude loss by a factor of two inherent in interpolation by two, the coefficients in <a href="#calibre_link-186">Figure 10-27(d)</a> are multiplied by two to make the filter’s gain equal to two. In that case coefficient <em class="calibre7">h</em>(5) becomes one, eliminating the bottom path multiplication altogether.</p>
<p class="calibre3"><a id="calibre_link-133"></a></p>
<h3 class="calibre6">10.13 Sample Rate Conversion with IFIR Filters</h3>
<p class="calibre3">The interpolated FIR (IFIR) filters that we introduced in <a href="#calibre_link-187">Chapter 7</a> are particularly useful in sample rate conversion applications because they’re computationally efficient, and their signal data storage requirements can be reduced in such applications.</p>
<p class="calibre3">To see why this is so, we refer to <a href="#calibre_link-188">Figure 10-28(a)</a> showing a standard IFIR filter with its cascaded shaping and image-reject subfilters followed by downsampling by integer <em class="calibre7">M</em> (discard all but every <em class="calibre7">M</em>th sample). The high-order <em class="calibre7">H</em><sub class="calibre12">sh</sub>(<em class="calibre7">z</em>) shaping filter is an upsampled (zero-stuffed) by <em class="calibre7">M</em> version of an <em class="calibre7">H</em><sub class="calibre12">p</sub>(<em class="calibre7">z</em>) prototype lowpass filter as discussed in <a href="#calibre_link-187">Chapter 7</a>. Because the <em class="calibre7">H</em><sub class="calibre12">sh</sub>(<em class="calibre7">z</em>) shaping subfilter and the <em class="calibre7">H</em><sub class="calibre12">ir</sub>(<em class="calibre7">z</em>) image-reject subfilter are linear and time invariant, we can swap their order as depicted in <a href="#calibre_link-188">Figure 10-28(b)</a>. Now comes the good part.</p>
<p class="caption"><a id="calibre_link-3052"></a><a id="calibre_link-188"></a><strong class="calibre9">Figure 10-28</strong> IFIR filter structures used for decimation.</p>
<p class="image"><img src="images/001381.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Due to the noble identities we can swap the order of the <em class="calibre7">H</em><sub class="calibre12">sh</sub>(<em class="calibre7">z</em>) subfilter with the downsampler and arrive at the structure shown in <a href="#calibre_link-188">Figure 10-28(c)</a>. Every <em class="calibre7">M</em>-unit delay in the <em class="calibre7">H</em><sub class="calibre12">sh</sub>(<em class="calibre7">z</em>) filter’s tapped-delay line is now replaced by a single unit delay, which takes us back to using our original low-order <em class="calibre7">H</em><sub class="calibre12">p</sub>(<em class="calibre7">z</em>) prototype filter. This fortunate scenario reduces the signal data storage requirements of our traditional IFIR filter. In addition, the <em class="calibre7">H</em><sub class="calibre12">ir</sub>(<em class="calibre7">z</em>) and <em class="calibre7">M</em> downsampler combination can be implemented using polyphase filtering to further reduce their computational complexity.</p>
<p class="calibre3">In a similar manner, IFIR filters can be used for interpolation as shown in <a href="#calibre_link-189">Figure 10-29(a)</a>. There we show an upsampling process followed by a standard IFIR filter structure. Again, we can swap the order of subfilter <em class="calibre7">H</em><sub class="calibre12">sh</sub>(<em class="calibre7">z</em>) with the upsampler and arrive at the structure shown in <a href="#calibre_link-189">Figure 10-29(b)</a>. Every <em class="calibre7">L</em>-unit delay in <em class="calibre7">H</em><sub class="calibre12">sh</sub>(<em class="calibre7">z</em>) is now replaced by a single unit delay, which, again, takes us back to using our original low-order prototype filter <em class="calibre7">H</em><sub class="calibre12">p</sub>(<em class="calibre7">z</em>) with its reduced data storage requirements. The <em class="calibre7">L</em> upsampler and <em class="calibre7">H</em><sub class="calibre12">ir</sub>(<em class="calibre7">z</em>) combination can be implemented using polyphase filtering to reduce their computational workload.</p>
<p class="caption"><a id="calibre_link-189"></a><strong class="calibre9">Figure 10-29</strong> IFIR filter structures used for interpolation.</p>
<p class="image"><img src="images/000404.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3053"></a>Before concluding this chapter on sample rate conversion, we introduce one final topic, cascaded integrator-comb filters. These important filters have become popular for sample rate conversion in the hardware design of modern digital communications systems.</p>
<p class="calibre3"><a id="calibre_link-660"></a></p>
<h3 class="calibre6">10.14 Cascaded Integrator-Comb Filters</h3>
<p class="calibre3">Cascaded integrator-comb (CIC) filters are computationally efficient implementations of narrowband lowpass filters and, as such, are used in hardware implementations of decimation and interpolation.</p>
<p class="calibre3">CIC filters are well suited to improve the efficiency of anti-aliasing filtering prior to decimation, as shown in <a href="#calibre_link-190">Figure 10-30(a)</a>, and for anti-imaging filtering for interpolating signals as in <a href="#calibre_link-190">Figure 10-30(b)</a>. Both applications are associated with very high-data-rate filtering such as hardware quadrature modulation and demodulation in modern wireless systems, and delta-sigma A/D and D/A converters.</p>
<p class="caption"><a id="calibre_link-190"></a><strong class="calibre9">Figure 10-30</strong> CIC filter applications: (a) decimation; (b) interpolation.</p>
<p class="image"><img src="images/001271.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Because their frequency magnitude response envelopes are sin(<em class="calibre7">x</em>)/<em class="calibre7">x</em>-like, CIC filters are typically followed, or preceded, by higher-performance linear-phase lowpass tapped-delay line FIR filters whose task is to compensate for the CIC filter’s non-flat passband as shown in <a href="#calibre_link-190">Figure 10-30</a>. That cascaded-filter architecture has valuable benefits. For example, with decimation, narrowband lowpass filtering can be attained at a greatly reduced computational complexity from that of a single lowpass FIR filter due to the initial CIC filtering. In addition, the follow-on FIR filter operates at reduced clock rates, minimizing power consumption in high-speed hardware applications. A crucial bonus in using CIC filters, the property that makes them popular in hardware devices, is that they require no multiplications. Their arithmetic is additions and subtractions only.</p>
<p class="calibre3">While CIC filters were introduced to the signal processing community over two decades ago, their application possibilities have grown in recent years<a href="#calibre_link-191">[10]</a>. That’s because improvements in VLSI integrated circuit technology, <a id="calibre_link-2057"></a>increased use of polyphase filtering techniques, advances in delta-sigma converter implementations, and the significant growth in wireless communications systems have spurred much interest in, and improvements upon, traditional CIC filters. Here we’ll introduce the structure and behavior of traditional CIC filters, present their frequency-domain performance, and discuss several important implementation issues.</p>
<p class="calibre3"><a id="calibre_link-3054"></a></p>
<h4 class="calibre13">10.14.1 Recursive Running Sum Filter</h4>
<p class="calibre3">CIC filters originate from the notion of a <em class="calibre7">recursive running sum</em> filter, which is itself an efficient version of the standard nonrecursive <em class="calibre7">moving averager</em>. Reviewing a <em class="calibre7">D</em>-point nonrecursive moving average process in <a href="#calibre_link-192">Figure 10-31(a)</a>, we see that <em class="calibre7">D</em>&ndash;1 summations (plus one multiply by 1/<em class="calibre7">D</em>) are necessary to compute each <em class="calibre7">y</em>(<em class="calibre7">n</em>) output sample.</p>
<p class="caption"><a id="calibre_link-192"></a><strong class="calibre9">Figure 10-31</strong> <em class="calibre7">D</em>-point averaging filters: (a) nonrecursive moving averager; (b) recursive moving averager; (c) recursive running sum filter; (d) CIC version of a recursive running sum filter.</p>
<p class="image"><img src="images/000309.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3055"></a>The <em class="calibre7">D</em>-point nonrecursive moving average filter’s <em class="calibre7">y</em>(<em class="calibre7">n</em>) time-domain output is expressed as</p>
<p class="caption"><a id="calibre_link-3056"></a>(10-22)</p>
<p class="image"><img src="images/001541.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The <em class="calibre7">z</em>-domain expression for this nonrecursive moving averager is</p>
<p class="caption"><a id="calibre_link-3057"></a>(10-23)</p>
<p class="image"><img src="images/000568.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">while its <em class="calibre7">z</em>-domain <em class="calibre7">H</em><sub class="calibre12">ma</sub>(<em class="calibre7">z</em>) transfer function is</p>
<p class="caption"><a id="calibre_link-3058"></a>(10-24)</p>
<p class="image"><img src="images/001429.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where the subscript “ma” means “moving average.”</p>
<p class="calibre3">An equivalent, but more computationally efficient, form of a moving averager is the recursive moving averager depicted in <a href="#calibre_link-192">Figure 10-31(b)</a>. The recursive moving averager has the sweet advantage that only two additions are required per output sample, regardless of the delay length <em class="calibre7">D</em>!</p>
<p class="calibre3">Notice that the delay line of the recursive moving averager has <em class="calibre7">D</em> delay elements, while the nonrecursive moving averager has <em class="calibre7">D</em>&ndash;1 delay elements. The recursive moving averager’s difference equation is</p>
<p class="caption"><a id="calibre_link-3059"></a>(10-25)</p>
<p class="image"><img src="images/000466.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">having a <em class="calibre7">z</em>-domain <em class="calibre7">H</em><sub class="calibre12">rma</sub>(<em class="calibre7">z</em>) transfer function of</p>
<p class="caption"><a id="calibre_link-3060"></a>(10-26)</p>
<p class="image"><img src="images/001322.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where the subscript “rma” means “recursive moving average.” What is interesting is that the nonrecursive moving averager and the recursive moving averager have identical behavior and, as such, <em class="calibre7">H</em><sub class="calibre12">ma</sub>(<em class="calibre7">z</em>) = <em class="calibre7">H</em><sub class="calibre12">rma</sub>(<em class="calibre7">z</em>). The transfer functions of the two averagers are equal to each other! (Actually, we saw the equivalence of nonrecursive FIR filters and special recursive structures once before&mdash;it was in regard to frequency sampling filters in <a href="#calibre_link-193">Section 7.1</a>.)</p>
<p class="calibre3">If we ignore the 1/<em class="calibre7">D</em> gain factor, we have a structure known as a <em class="calibre7">recursive running sum filter</em> shown in <a href="#calibre_link-192">Figure 10-31(c)</a>. Next we’ll see how a CIC filter is itself a recursive running sum filter.</p>
<p class="calibre3"><a id="calibre_link-1814"></a></p>
<h4 class="calibre13"><a id="calibre_link-2054"></a>10.14.2 CIC Filter Structures</h4>
<p class="calibre3">If we condense the delay line representation in <a href="#calibre_link-192">Figure 10-31(c)</a>, we obtain the classic representation of a single-stage (1st-order) CIC filter, whose cascade structure (block diagram) is shown in <a href="#calibre_link-192">Figure 10-31(d)</a>. The feedforward portion of the CIC filter is called the <em class="calibre7">comb</em> section, whose <em class="calibre7">differential delay</em> is <em class="calibre7">D</em>, and the feedback section is called an <em class="calibre7">integrator</em>. The comb stage subtracts a delayed input sample from the current input sample, and the integrator is simply an accumulator (performing summations). The CIC filter’s difference equation is</p>
<p class="caption"><a id="calibre_link-3061"></a>(10-27)</p>
<p class="image"><img src="images/000359.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">and its <em class="calibre7">z</em>-domain transfer function is</p>
<p class="caption"><a id="calibre_link-194"></a>(10-28)</p>
<p class="image"><img src="images/001206.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Looking at <a href="#calibre_link-194">Eq. (10-28)</a>, we see that the numerator is the transfer function of the comb filter and the denominator is the transfer function of the integrator.</p>
<p class="calibre3">To see why the CIC filter is of interest, first we examine its time-domain behavior, for <em class="calibre7">D</em> = 5, shown in <a href="#calibre_link-195">Figure 10-32</a>. If a unit impulse sequence, a unity-valued sample followed by many zero-valued samples, was applied to the comb stage, that stage’s output is as shown in <a href="#calibre_link-195">Figure 10-32(a)</a>. Think, now, what would be the output of the integrator if its input was the comb stage’s impulse response? The initial positive impulse from the comb filter starts the integrator’s all-ones output. Then, <em class="calibre7">D</em> samples later, the negative impulse from the comb stage arrives at the integrator to make all further CIC filter output samples equal to zero.</p>
<p class="caption"><a id="calibre_link-195"></a><strong class="calibre9">Figure 10-32</strong> Single-stage CIC filter time-domain responses when <em class="calibre7">D</em> = 5.</p>
<p class="image"><img src="images/001149.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The key issue is the combined unit impulse response of the CIC filter being a rectangular sequence, identical to the unit impulse response of the <a id="calibre_link-3062"></a>recursive running sum filter. (Moving averagers, recursive running sum filters, and CIC filters are close kin. They have the same <em class="calibre7">z</em>-domain pole/zero locations, their frequency magnitude responses have identical shapes, their phase responses are identical, and their transfer functions differ only by a constant scale factor.) The frequency magnitude (in dB) and linear-phase response of a <em class="calibre7">D</em> = 5 CIC filter are shown in <a href="#calibre_link-196">Figure 10-33(a)</a>.</p>
<p class="caption"><a id="calibre_link-196"></a><strong class="calibre9">Figure 10-33</strong> Characteristics of a single-stage CIC filter when <em class="calibre7">D</em> = 5: (a) magnitude response; (b) phase response; (c) pole/zero locations.</p>
<p class="image"><img src="images/000197.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">We can obtain an expression for the CIC filter’s frequency response by evaluating <a href="#calibre_link-194">Eq. (10-28)</a>’s <em class="calibre7">H</em><sub class="calibre12">cic</sub>(<em class="calibre7">z</em>) transfer function on the <em class="calibre7">z</em>-plane’s unit circle, by setting <em class="calibre7">z</em> = <em class="calibre7">e</em><sup class="calibre10"><em class="calibre7">j</em>ω</sup> = <em class="calibre7">e</em><sup class="calibre10"><em class="calibre7">j</em>2π<em class="calibre7">f</em></sup>, yielding</p>
<p class="caption"><a id="calibre_link-197"></a>(10-29)</p>
<p class="image"><img src="images/000244.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">In <a href="#calibre_link-197">Eq. 10-29</a> the frequency variable <em class="calibre7">f</em> is in the range of &ndash;0.5 to 0.5, corresponding to a continuous-time frequency range of &ndash;<em class="calibre7">f<sub class="calibre12">s</sub></em>/2 to <em class="calibre7">f<sub class="calibre12">s</sub></em>/2 Hz. Using Euler’s identity 2<em class="calibre7">j</em>sin(α) = <em class="calibre7">e</em><sup class="calibre10"><em class="calibre7">j</em>α</sup> &ndash; <em class="calibre7">e</em><sup class="calibre10">&ndash;<em class="calibre7">j</em>α</sup>, we can write</p>
<p class="caption"><a id="calibre_link-198"></a>(10-30)</p>
<p class="image"><img src="images/000377.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The first positive-frequency magnitude null in <a href="#calibre_link-196">Figure 10-33(a)</a>, when <em class="calibre7">D</em> = 5 for example, is located at a frequency of <em class="calibre7">f<sub class="calibre12">s</sub></em>/<em class="calibre7">D</em> = <em class="calibre7">f<sub class="calibre12">s</sub></em>/5 = 0.2<em class="calibre7">f<sub class="calibre12">s</sub></em> Hz (<em class="calibre7">f</em> = 0.2). <a href="#calibre_link-198">Equation (10-30)</a> is in the form of <a href="#calibre_link-199">Eq. (3-46)</a>. This means, ignoring the linear-phase factor, a 1st-order CIC filter’s frequency magnitude response is roughly equal to a sin(<em class="calibre7">x</em>)/<em class="calibre7">x</em> function centered at zero Hz as we see in <a href="#calibre_link-196">Figure 10-33(a)</a>. (This is why CIC filters are sometimes called <em class="calibre7">sinc</em> filters.)</p>
<p class="calibre3">Let’s stop here for a moment and mention a subtle characteristic of the phase of <em class="calibre7">H</em><sub class="calibre12">cic</sub>(<em class="calibre7">f</em>). The phase angle, the &ndash;π<em class="calibre7">f</em>(<em class="calibre7">D</em>&ndash;1) in <a href="#calibre_link-198">Eq. (10-30)</a>, is a linear function of frequency. Plotting that phase, over the frequency range of &ndash;0.5 ≤ <em class="calibre7">f</em> ≤ 0.5, would yield a straight line (with negative slope). However, the sin(π<em class="calibre7">fD</em>)/sin(π<em class="calibre7">f</em>) amplitude portion of <a href="#calibre_link-198">Eq. (10-30)</a> changes sign (polarity) between <a id="calibre_link-1982"></a>its amplitude nulls (zero amplitude). So those sign changes show up as phase discontinuities of π radians (180 degrees) in phase plots. For example, notice the phase discontinuity in <a href="#calibre_link-196">Figure 10-33(b)</a> at frequency <em class="calibre7">f</em> = 0.2. That discontinuity is π radians, because the sin(π<em class="calibre7">fD</em>)/sin(π<em class="calibre7">f</em>) amplitude term changed sign from positive to negative at <em class="calibre7">f</em> = 0.2.</p>
<p class="calibre3">The <em class="calibre7">z</em>-plane pole/zero characteristics of a <em class="calibre7">D</em> = 5 CIC filter are provided in <a href="#calibre_link-196">Figure 10-33(c)</a>, where the comb filter produces <em class="calibre7">D</em> zeros, equally spaced around the unit circle, and the integrator produces a single pole canceling the zero at <em class="calibre7">z</em> = 1. Each of the comb’s zeros, being a <em class="calibre7">D</em>th root of 1, are located at <em class="calibre7">z</em>(<em class="calibre7">k</em>) = <em class="calibre7">e</em><sup class="calibre10"><em class="calibre7">j</em>2π<em class="calibre7">k</em>/<em class="calibre7">D</em></sup>, where <em class="calibre7">k</em> = 0, 1, 2, ..., <em class="calibre7">D</em>&ndash;1.</p>
<p class="calibre3">The normally risky situation of having a filter pole directly on the unit circle need not trouble us here because there is no coefficient quantization error in our <em class="calibre7">H</em><sub class="calibre12">cic</sub>(<em class="calibre7">z</em>) transfer function. CIC filter coefficients are ones and can be implemented with perfect precision using binary numbers. Although recursive, CIC filters are guaranteed stable, linear phase as shown in <a href="#calibre_link-196">Figure 10-33(b)</a> and have finite-length impulse responses.</p>
<p class="calibre3">If we examine just the magnitude of <em class="calibre7">H</em><sub class="calibre12">cic</sub>(<em class="calibre7">f</em>) from <a href="#calibre_link-198">Eq. (10-30)</a>, we can determine the DC (zero Hz) gain of our single-stage <a href="#calibre_link-192">Figure 10-31(d)</a> CIC filter. However, setting <em class="calibre7">f</em> = 0 in <a href="#calibre_link-198">Eq. (10-30)</a>, we have</p>
<p class="caption"><a id="calibre_link-3063"></a>(10-31)</p>
<p class="image"><img src="images/000876.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">which is indeterminate. But don’t worry, we can apply the Marquis de L’Hopital’s rule to the magnitude-only portion of <a href="#calibre_link-198">Eq. (10-30)</a>, then set <em class="calibre7">f</em> = 0, to yield</p>
<p class="caption"><a id="calibre_link-3064"></a>(10-32)</p>
<p class="image"><img src="images/001732.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">So, the DC gain of a 1st-order CIC filter is equal to the comb filter delay <em class="calibre7">D</em>. This fact will be very important to us when we actually implement a CIC filter in hardware.</p>
<p class="calibre3">CIC filters are primarily used for anti-aliasing filtering prior to decimation and for anti-imaging filtering for interpolated signals. With those notions in mind, we swap the order of <a href="#calibre_link-192">Figure 10-31(c)</a>’s comb and integrator&mdash;we’re permitted to do so because those are linear time-invariant operations&mdash;and include downsampling by a sample rate conversion factor <em class="calibre7">R</em> in <a href="#calibre_link-200">Figure 10-34(a)</a>. (Readers should prove to themselves that the unit impulse response of the integrator/comb combination, prior to the sample rate conversion, in <a href="#calibre_link-200">Figure 10-34(a)</a> is equal to that in <a href="#calibre_link-195">Figure 10-32(c)</a>.) In most CIC filter <a id="calibre_link-3065"></a>applications the sample rate change factor <em class="calibre7">R</em> is equal to the comb’s differential delay <em class="calibre7">D</em>, but we’ll keep them as separate design parameters for now.</p>
<p class="caption"><a id="calibre_link-200"></a><strong class="calibre9">Figure 10-34</strong> Single-stage CIC filters, used in: (a) decimation; (b) interpolation.</p>
<p class="image"><img src="images/001039.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The downsampling operation in <a href="#calibre_link-200">Figure 10-34(a)</a> results in an output sample rate of <em class="calibre7">f</em><sub class="calibre12"><em class="calibre7">s</em>,out</sub> = <em class="calibre7">f</em><sub class="calibre12"><em class="calibre7">s</em>,in</sub>/<em class="calibre7">R</em>. To investigate a CIC filter’s frequency-domain behavior in more detail, <a href="#calibre_link-201">Figure 10-35(a)</a> shows the frequency magnitude response of a <em class="calibre7">D</em> = 8 CIC filter prior to downsampling. The spectral band, of width <em class="calibre7">B</em>, centered at zero Hz, is the desired passband of the filter. A key aspect of CIC filters is the spectral aliasing that takes place due to downsampling.</p>
<p class="caption"><a id="calibre_link-201"></a><strong class="calibre9">Figure 10-35</strong> Frequency magnitude response of a 1st-order, <em class="calibre7">D</em> = 8, decimating CIC filter: (a) response before decimation; (b) response and aliasing after <em class="calibre7">R</em> = 8 downsampling.</p>
<p class="image"><img src="images/000094.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Those <em class="calibre7">B</em>-width shaded spectral bands centered at multiples of <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,in</sub>/<em class="calibre7">R</em> in <a href="#calibre_link-201">Figure 10-35(a)</a> will alias directly into our desired passband after downsampling by <em class="calibre7">R</em> = 8 as shown in <a href="#calibre_link-201">Figure 10-35(b)</a>. Notice how the largest <em class="calibre7">aliased</em> spectral <a id="calibre_link-1987"></a>component, in this example, is approximately 16 dB below the peak of the band of interest. Of course, the aliased power levels depend on the bandwidth <em class="calibre7">B</em>&mdash;the smaller <em class="calibre7">B</em> is, the lower the aliased energy after downsampling.</p>
<p class="calibre3"><a href="#calibre_link-200">Figure 10-34(b)</a> shows a CIC filter used for interpolation where upsampling by <em class="calibre7">R</em> yields a <em class="calibre7">y</em>(<em class="calibre7">m</em>) output sample rate of <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,out</sub> = <em class="calibre7">Rf<sub class="calibre12">s</sub></em><sub class="calibre12">,in</sub>. (In this CIC filter discussion, interpolation is defined as zeros-insertion upsampling followed by filtering.) <a href="#calibre_link-202">Figure 10-36(a)</a> shows an arbitrary baseband spectrum, with its spectral replications, of a signal applied to the <em class="calibre7">D</em> = <em class="calibre7">R</em> = 8 interpolating CIC filter of <a href="#calibre_link-200">Figure 10-34(b)</a>. The filter’s output spectrum in <a href="#calibre_link-202">Figure 10-36(b)</a> shows how imperfect filtering gives rise to the undesired spectral images.</p>
<p class="caption"><a id="calibre_link-202"></a><strong class="calibre9">Figure 10-36</strong> Spectra of a 1st-order, <em class="calibre7">D</em> = <em class="calibre7">R</em> = 8, interpolating CIC filter: (a) input spectrum before interpolation; (b) output spectral images.</p>
<p class="image"><img src="images/000934.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">After interpolation, unwanted images of the <em class="calibre7">B</em>-width baseband spectrum reside at the null centers, located at integer multiples of <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,out</sub>/<em class="calibre7">D</em>. If we follow the CIC filter with a traditional lowpass tapped-delay line FIR filter, whose stopband includes the first image band, fairly high image rejection can be achieved.</p>
<p class="calibre3"><a id="calibre_link-3066"></a></p>
<h4 class="calibre13">10.14.3 Improving CIC Attenuation</h4>
<p class="calibre3">The most common method to improve CIC filter anti-aliasing and image attenuation is by increasing the order <em class="calibre7">Q</em> of the CIC filter using multiple stages. <a href="#calibre_link-203">Figure 10-37</a> shows the structure and frequency magnitude response of a 3rd-order (<em class="calibre7">Q</em> = 3) CIC decimation filter.</p>
<p class="caption"><a id="calibre_link-2055"></a><a id="calibre_link-203"></a><strong class="calibre9">Figure 10-37</strong> A 3rd-order (<em class="calibre7">Q</em> = 3), <em class="calibre7">D</em> = <em class="calibre7">R</em> = 8 CIC decimation filter: (a) structure; (b) frequency magnitude response before decimation.</p>
<p class="image"><img src="images/000209.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Notice the increased attenuation at multiples of <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,in</sub>/<em class="calibre7">D</em> in <a href="#calibre_link-203">Figure 10-37(b)</a> compared to the 1st-order CIC filter in <a href="#calibre_link-201">Figure 10-35(a)</a>. Because the <em class="calibre7">Q</em> = 3 CIC stages are in cascade, the overall before-decimation transfer function will be the product of their individual single-stage transfer functions, or</p>
<p class="caption"><a id="calibre_link-3067"></a>(10-33)</p>
<p class="image"><img src="images/000757.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">The overall frequency magnitude response of the <em class="calibre7">Q</em> = 3 cascaded stages, before decimation, will be</p>
<p class="caption"><a id="calibre_link-3068"></a>(10-34)</p>
<p class="image"><img src="images/001613.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where, again, the frequency variable <em class="calibre7">f</em> is in the range of &ndash;0.5 to 0.5 corresponding to a continuous-time frequency range of &ndash;<em class="calibre7">f<sub class="calibre12">s</sub></em>/2 to <em class="calibre7">f<sub class="calibre12">s</sub></em>/2 Hz. The price we pay for improved anti-alias attenuation is additional hardware adders and increased CIC filter passband droop. An additional penalty of increased orders comes from the DC (zero Hz) gain of the decimation filter, which is <em class="calibre7">D<sup class="calibre10">Q</sup></em>. That potentially large gain causes significant binary data word-width growth for higher-order filters. Even so, this multistage decimation implementation is common in commercial integrated circuits, where a <em class="calibre7">Q</em>th-order CIC filter is called a <em class="calibre7">sinc<sup class="calibre10">Q</sup></em> filter.</p>
<p class="calibre3"><a id="calibre_link-3069"></a></p>
<h4 class="calibre13">10.14.4 CIC Filter Implementation Issues</h4>
<p class="calibre3">With CIC filters, the comb section can precede, or follow, the integrator section. However, it’s sensible to put the comb section on the side of the filter operating <a id="calibre_link-2058"></a>at the lower sample rate to reduce the length of the delay line. Using the noble identities discussed earlier in this chapter, swapping the <a href="#calibre_link-200">Figure 10-34</a> comb filters with the rate conversion operations results in the most common implementation of CIC filters as shown in <a href="#calibre_link-204">Figure 10-38</a>. Notice that the decimation filter’s comb section now has a delay length (differential delay) of <em class="calibre7">N</em> = <em class="calibre7">D</em>/<em class="calibre7">R</em>. That’s because an <em class="calibre7">N</em>-sample delay after downsampling by <em class="calibre7">R</em> is equivalent to a <em class="calibre7">D</em>-sample delay before downsampling by <em class="calibre7">R</em>. Likewise for the interpolation filter; an <em class="calibre7">N</em>-sample delay before upsampling by <em class="calibre7">R</em> is equivalent to a <em class="calibre7">D</em>-sample delay after upsampling by <em class="calibre7">R</em>.</p>
<p class="caption"><a id="calibre_link-204"></a><strong class="calibre9">Figure 10-38</strong> Single-stage CIC filter implementations: (a) for decimation; (b) for interpolation.</p>
<p class="image"><img src="images/000822.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Those <a href="#calibre_link-204">Figure 10-38</a> configurations yield two major benefits: First, the comb section’s new differential delay is decreased to <em class="calibre7">N</em> = <em class="calibre7">D</em>/<em class="calibre7">R</em>, reducing data storage requirements; second, the comb section now operates at a reduced clock rate. Both of these effects reduce hardware power consumption.</p>
<p class="calibre3">The comb section’s differential delay design parameter <em class="calibre7">N</em> = <em class="calibre7">D</em>/<em class="calibre7">R</em> is typically 1 or 2 for high-sample-rate conversion ratios as is often done in commercial up/down-converter chips. Value <em class="calibre7">N</em> effectively sets the number of nulls in the frequency response of a decimation filter, as shown in <a href="#calibre_link-205">Figure 10-39(a)</a>.</p>
<p class="caption"><a id="calibre_link-205"></a><strong class="calibre9">Figure 10-39</strong> CIC decimation filter frequency responses: (a) for various values of differential delay <em class="calibre7">N,</em> when <em class="calibre7">R</em> = 8; (b) for two <em class="calibre7">R</em> downsampling factors when <em class="calibre7">N</em> = 2.</p>
<p class="image"><img src="images/001681.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">An important characteristic of a CIC decimator is that the shape of the filter response, relative to its <em class="calibre7">f</em><sub class="calibre12">s,out</sub> output sample rate, changes very little as a function of the downsampling factor <em class="calibre7">R</em>, as shown in <a href="#calibre_link-205">Figure 10-39(b)</a>. For <em class="calibre7">R</em> larger than roughly 16, the change in the filter shape is negligible. Fortunately, this allows the same compensation FIR filter to be used for variable-decimation ratio systems.</p>
<p class="calibre3">The gain of a <em class="calibre7">Q</em>th-order CIC decimation filter is <em class="calibre7">D<sup class="calibre10">Q</sup></em>, and individual integrators within the filter can experience overflow. (An integrator’s gain is infinite at DC!) As such, the use of two’s complement (non-saturating) arithmetic resolves this overflow situation just so long as the integrator word width accommodates the maximum value expected at the CIC filter output. Happily, using the two’s complement binary number format, with its modular wraparound property, the follow-on comb filter will properly compute the correct difference between two successive integrator output samples.</p>
<p class="calibre3">To show this behavior, assume we’re using a four-bit two’s complement number format, and a CIC decimation filter’s integrator must sum the values <a id="calibre_link-3070"></a>7 + 4 and the comb filter must subtract 6 from that sum. <a href="#calibre_link-206">Figure 10-40(a)</a> shows how a previous integrator output <em class="calibre7">x</em><sub class="calibre12">int</sub>(0) sample of decimal 6 can be subtracted by the comb filter from a later <em class="calibre7">x</em><sub class="calibre12">int</sub>(<em class="calibre7">D</em>) integrator output sample of decimal 11 (11 = 7 + 4, a temporary overflow condition), resulting in a correct difference of decimal plus 5 (+5<sub class="calibre12">dec</sub>).</p>
<p class="caption"><a id="calibre_link-3071"></a><a id="calibre_link-206"></a><strong class="calibre9">Figure 10-40</strong> Two’s complement overflow (numerical wraparound): (a) difference example; (b) <em class="calibre7">D</em> = 5 decimation example.</p>
<p class="image"><img src="images/000704.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">This two’s complement wraparound issue is so important that it deserves a second example. Think of the <em class="calibre7">D</em> = 5 decimation filter in <a href="#calibre_link-206">Figure 10-40(b)</a>. If we applied a unit step input (an all-ones <em class="calibre7">x</em>(<em class="calibre7">n</em>) sequence) at time <em class="calibre7">n</em> = 1, we expect the <em class="calibre7">v</em>(<em class="calibre7">n</em>) sequence to ramp up to a decimal value of 5 and remain at that value. Now if the integrator’s adder/accumulator register was only three bits wide, it will <em class="calibre7">not</em> accommodate the <em class="calibre7">v</em>(<em class="calibre7">n</em>) output of 5 because the most positive value of a three-bit word in two’s complement format is +3. That scenario is shown on the left side of <a href="#calibre_link-207">Table 10-2</a>, where all the values are shown in decimal format. There we see that the <em class="calibre7">v</em>(<em class="calibre7">n</em>) sequence goes to an incorrect value of &ndash;3.</p>
<p class="caption"><a id="calibre_link-207"></a><strong class="calibre9">Table 10-2</strong> Accumulator Example for <em class="calibre7">D</em> = 5 Decimation</p>
<p class="image"><img src="images/001797.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">If we increase the integrator’s accumulator width to four bits, the integrator accumulator experiences overflow but the comb filter compensates for that situation and provides the correct <em class="calibre7">v</em>(<em class="calibre7">n</em>) sequence as shown on the right side of <a href="#calibre_link-207">Table 10-2</a>.</p>
<p class="calibre3"><a id="calibre_link-3072"></a>So here’s the bottom line: When two’s complement fixed-point arithmetic is used, the number of bits in a <em class="calibre7">Q</em>th-order CIC decimation filter’s integrator and comb registers must accommodate the filter’s input signal times the filter’s total gain of <em class="calibre7">D<sup class="calibre10">Q</sup></em>. To be specific, overflow errors are avoided if the number of integrator and comb register bit widths is at least</p>
<p class="caption"><a id="calibre_link-3073"></a>(10-35)</p>
<p class="image"><img src="images/000637.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">where <em class="calibre7">x</em>(<em class="calibre7">n</em>) is the input to the CIC filter, and <img src="images/000613.jpg" alt="image" class="calibre2" /> means that if <em class="calibre7">k</em> is not an integer, round it up to the next larger integer. For example, if a <em class="calibre7">Q</em> = 3-stage CIC decimation filter accepts one-bit binary input words from a sigma-delta A/D converter and the decimation factor is <em class="calibre7">R</em> = <em class="calibre7">D</em> = 64, binary overflow errors are avoided if the three integrator and three comb registers’ bit widths are no less than</p>
<p class="caption"><a id="calibre_link-3074"></a>(10-36)</p>
<p class="image"><img src="images/001492.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Regarding a CIC decimation filter’s gain of <em class="calibre7">D<sup class="calibre10">Q</sup></em>, we often see a multistage CIC decimation filter implemented as shown in <a href="#calibre_link-208">Figure 10-41</a> where <em class="calibre7">R</em> = <em class="calibre7">D</em>, and a gain reduction (by 1/<em class="calibre7">D<sup class="calibre10">Q</sup></em>) stage is included as a final operation. If <em class="calibre7">D</em> is an integer power of two, the multiply operation can be performed with a binary right shift. That’s one of the computational benefits of decimating by an integer power of two. In the <a href="#calibre_link-208">Figure 10-41</a> scenario, the data words out of the final comb filter are shifted to the right by <em class="calibre7">Q</em>log<sub class="calibre12">2</sub>(<em class="calibre7">D</em>) bits to achieve an overall decimation filter gain of unity.</p>
<p class="caption"><a id="calibre_link-208"></a><strong class="calibre9">Figure 10-41</strong> Unity gain, <em class="calibre7">Q</em> = 3, <em class="calibre7">D</em> = <em class="calibre7">R,</em> CIC decimation filter.</p>
<p class="image"><img src="images/000743.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Interpolating CIC filters have zero-valued samples inserted after each original input sample reducing its gain by a factor of 1/<em class="calibre7">R</em>, so the net gain of a CIC interpolation filter is <em class="calibre7">D<sup class="calibre10">Q</sup></em>/<em class="calibre7">R</em>. For multistage interpolation CIC filters, the integrators’ register bit widths grow in size in successive integrator stages. This means that not all integrator accumulator registers need to have the same bit width, so there is some flexibility in discarding some of the least significant bits (lsbs) within the stages of a multistage CIC interpolation filter. The specific effects of this lsb removal are, however, a complicated issue, so we refer the reader to references [<a href="#calibre_link-154">9</a>,<a href="#calibre_link-191">10</a>] for more details.</p>
<p class="calibre3">While the preceding discussion focused on hardwired CIC filters, these filters can also be implemented with programmable fixed-point DSP chips. Although those chips have inflexible data paths and fixed word widths, their <a id="calibre_link-2044"></a>use of CIC filtering can be advantageous for high-sample-rate conversion. Large word widths can be accommodated with multiword additions at the expense of extra instructions. Even so, for large <em class="calibre7">R</em> the computational workload per output sample may be small compared to computations required using a more conventional tapped-delay line FIR filter approach in fixed-point DSP chips.</p>
<p class="calibre3">One further CIC filter implementation issue deserves mention. When we need to implement cascaded integrators, we showed those integrators as in <a href="#calibre_link-209">Figure 10-42(a)</a>. As it turns out, depending on the architecture of your hardware implementation, it may be advantageous to implement those cascaded integrators as shown in <a href="#calibre_link-209">Figure 10-42(b)</a>, where placing the unit-delay elements in the forward path reduces the pipelined critical-path delay from three adder delays to a single adder delay<a href="#calibre_link-210">[11]</a>. While the <a href="#calibre_link-209">Figure 10-42(b)</a> cascaded network adds additional time delay, the frequency magnitude responses are identical for the two networks in <a href="#calibre_link-209">Figure 10-42</a>.</p>
<p class="caption"><a id="calibre_link-209"></a><strong class="calibre9">Figure 10-42</strong> Cascaded integrator implementations: (a) traditional method; (b) reduced pipelined critical-path delay method.</p>
<p class="image"><img src="images/000586.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3"><a id="calibre_link-3075"></a></p>
<h4 class="calibre13">10.14.5 Compensation/Preconditioning FIR Filters</h4>
<p class="calibre3">In typical decimation/interpolation filtering applications we desire a reasonably flat passband and narrow transition region filter response. These desirable properties are not provided by CIC filters alone, with their drooping passband gains and wide transition regions. We alleviate this problem, in decimation for example, by following the CIC filter with a compensation nonrecursive FIR filter (often called an <em class="calibre7">inverse sinc filter</em>), as in <a href="#calibre_link-190">Figure 10-30(a)</a>, to narrow the output bandwidth and flatten the passband gain.</p>
<p class="calibre3">The compensation FIR filter’s frequency magnitude response is ideally an inverted version of the CIC filter passband response similar to that shown by the dashed curve in <a href="#calibre_link-211">Figure 10-43(a)</a> for a simple 3-tap FIR filter whose coefficients are [&ndash;1/16, 9/8, &ndash;1/16]. With the dotted curve representing the uncompensated passband droop of a 1st-order <em class="calibre7">R</em> = 8 CIC filter, the solid curve <a id="calibre_link-2467"></a>represents the compensated response of the cascaded filters. If either the CIC filter’s order or passband width increases, the correction becomes more demanding, requiring more compensation FIR filter taps. An example of this situation is shown in <a href="#calibre_link-211">Figure 10-43(b)</a> where the dotted curve represents the passband droop of a 3rd-order <em class="calibre7">R</em> = 8 CIC filter and the dashed curve, taking the form of [<em class="calibre7">x</em>/sin(<em class="calibre7">x</em>)]<sup class="calibre10">3</sup>, is the response of a 15-tap compensation FIR filter having the coefficients [&ndash;1, 4, &ndash;16, 32, &ndash;64, 136, &ndash;352, 1312, &ndash;352, 136, &ndash;64, 32, &ndash;16, 4, &ndash;1].</p>
<p class="caption"><a id="calibre_link-211"></a><strong class="calibre9">Figure 10-43</strong> Compensation FIR filter magnitude responses, dashed curves: (a) with a 1st-order decimation CIC filter; (b) with a 3rd-order decimation CIC filter.</p>
<p class="image"><img src="images/000795.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">Wideband compensation also means that signals near <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,out</sub>/2 are attenuated with the CIC filter and then must be amplified in the correction filter, which adds noise. As such, practitioners often limit the passband width of the compensation FIR filter to roughly one-fourth the frequency of the first null in the CIC filter response.<sup class="calibre10"><a id="calibre_link-213"></a><a href="#calibre_link-212">†</a></sup></p>
<p class="footnotes"><a id="calibre_link-212"></a><sup class="calibre11"><a href="#calibre_link-213">†</a></sup> I thank my DSP pal Ray Andraka, of Andraka Consulting Group Inc., for his guidance on these implementation issues.</p>
<p class="calibre3">Those dashed curves in <a href="#calibre_link-211">Figure 10-43</a> represent the frequency magnitude responses of compensating FIR filters within which no sample rate change takes place. (The FIR filters’ input and output sample rates are equal to the <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,out</sub> output rate of the decimating CIC filter.) If a compensating FIR filter were designed to provide an additional decimation by two, its frequency <a id="calibre_link-3076"></a>magnitude response would look similar to that in <a href="#calibre_link-214">Figure 10-44</a>, where <em class="calibre7">f</em><sub class="calibre12"><em class="calibre7">s</em>,in</sub> is the compensation filter’s input sample rate.</p>
<p class="caption"><a id="calibre_link-214"></a><strong class="calibre9">Figure 10-44</strong> Frequency magnitude response of a decimate-by-two compensation FIR filter.</p>
<p class="image"><img src="images/000484.jpg" alt="image" class="calibre2" /></p>
<p class="calibre3">After all of this discussion, just keep in mind that a decimating CIC filter is merely a very efficient recursive implementation of a moving average filter, having <em class="calibre7">D</em> = <em class="calibre7">NR</em> taps, whose output is decimated by <em class="calibre7">R</em>. Likewise, the interpolating CIC filter is insertion of <em class="calibre7">R</em>&ndash;1 zero-valued samples after each original input sample followed by a <em class="calibre7">D</em> = <em class="calibre7">NR</em>-tap moving average filter running at the output sample rate <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">,out</sub>. The cascade implementations in <a href="#calibre_link-190">Figure 10-30</a> result in total computational workloads far less than those when using a single tapped-delay line FIR filter alone for high-sample-rate conversion by decimation or interpolation. CIC filter structures are designed to maximize the amount of low-sample-rate processing to minimize power consumption in high-speed hardware applications. Again, CIC filters require no multiplications; their arithmetic is strictly additions and subtractions. Their performance allows us to state that, technically speaking, CIC filters are lean, mean, fat-free filtering machines.</p>
<p class="calibre3"><a href="#calibre_link-215">Section 13.24</a> provides a few advanced tricks allowing us to implement nonrecursive CIC filters, and this eases the word-width growth problem of the above traditional recursive CIC filters.</p>
<p class="calibre3">This chapter’s discussion of sample rate conversion has, by necessity, only touched the surface of this important signal processing technique. Fortunately for us, the excellent work of early signal processing engineers and mathematicians is well documented in the literature of DSP. Several standard DSP textbooks briefly discuss multirate filter design concepts[<a href="#calibre_link-216">12</a>&ndash;<a href="#calibre_link-217">14</a>], and other texts are devoted exclusively to polyphase filters and multirate processing[<a href="#calibre_link-152">6</a>&ndash;<a href="#calibre_link-154">9</a>]. The inquisitive reader can probe further to learn how to choose the number of stages in a multistage process[<a href="#calibre_link-120">1</a>,<a href="#calibre_link-131">3</a>], the interrelated considerations of designing optimum FIR filters[<a href="#calibre_link-120">1</a>,<a href="#calibre_link-218">15</a>], the benefits of half-band FIR filters[<a href="#calibre_link-147">5</a>,<a href="#calibre_link-219">16</a>], when IIR filter structures may be advantageous[<a href="#calibre_link-218">15</a>], what special <a id="calibre_link-3077"></a>considerations are applicable to sample rate conversion in image processing[<a href="#calibre_link-220">17</a>&ndash;<a href="#calibre_link-221">19</a>], guidance in developing the control logic necessary for hardware implementations of rate conversion algorithms<a href="#calibre_link-218">[15]</a>, how rate conversion improves the usefulness of commercial test equipment[<a href="#calibre_link-222">20</a>,<a href="#calibre_link-223">21</a>], and software development tools for designing multirate filters<a href="#calibre_link-224">[22]</a>.</p>
<p class="calibre3"><a id="calibre_link-661"></a></p>
<h3 class="calibre6">References</h3>
<p class="chapterendnote"><a id="calibre_link-120"></a>[1] Crochiere, R., and Rabiner, L. “Optimum FIR Digital Implementations for Decimation, Interpolation, and Narrow-band Filtering,” <em class="calibre7">IEEE Trans. on Acoust. Speech, and Signal Proc.,</em> Vol. ASSP-23, No. 5, October 1975.</p>
<p class="chapterendnote"><a id="calibre_link-128"></a>[2] Ballanger, M. “Computation Rate and Storage Estimation in Multirate Digital Filtering with Half-Band Filters,” <em class="calibre7">IEEE Trans. on Acoust. Speech, and Signal Proc.,</em> Vol. ASSP-25, No. 4, August 1977.</p>
<p class="chapterendnote"><a id="calibre_link-131"></a>[3] Crochiere, R., and Rabiner, L. “Interpolation and Decimation of Digital Signals&mdash;A Tutorial Review,” <em class="calibre7">Proceedings of the IEEE,</em> Vol. 69, No. 3, March 1981.</p>
<p class="chapterendnote"><a id="calibre_link-138"></a>[4] Neugebauer, O. <em class="calibre7">Astronomical Cuneiform Texts: Babylonian Ephemerides of the Seleucid Period for the Motion of the Sun, the Moon and the Planets</em>, Lund Humphries, London, 1955.</p>
<p class="chapterendnote"><a id="calibre_link-147"></a>[5] Schafer, R., and Rabiner, L. “A Digital Signal Processing Approach to Interpolation,” <em class="calibre7">Proceedings of the IEEE,</em> Vol. 61, No. 6, June 1973.</p>
<p class="chapterendnote"><a id="calibre_link-152"></a>[6] Fliege, N. <em class="calibre7">Multirate Digital Signal Processing: Multirate Systems, Filter Banks, Wavelets</em>, John Wiley and Sons, New York, 1995.</p>
<p class="chapterendnote"><a id="calibre_link-3078"></a>[7] Crochiere, R., and Rabiner, L. <em class="calibre7">Multirate Digital Signal Processing</em>, Prentice Hall, Upper Saddle River, New Jersey, 1983.</p>
<p class="chapterendnote"><a id="calibre_link-153"></a>[8] Vaidyanathan, P. <em class="calibre7">Multirate Systems and Filter Banks</em>, Prentice Hall, Upper Saddle River, New Jersey, 1992.</p>
<p class="chapterendnote"><a id="calibre_link-154"></a>[9] Harris, F. <em class="calibre7">Multirate Signal Processing for Communication Systems</em>, Prentice Hall, Upper Saddle River, New Jersey, 2004, <a href="#calibre_link-225">Chapter 11</a>.</p>
<p class="chapterendnote"><a id="calibre_link-191"></a>[10] Hogenauer, E. “An Economical Class of Digital Filters for Decimation and Interpolation,” <em class="calibre7">IEEE Trans. on Acoust. Speech, and Signal Proc.,</em> Vol. ASSP-29, April 1981, pp. 155&ndash;162.</p>
<p class="chapterendnote"><a id="calibre_link-210"></a>[11] Brandt, F. “Oversampled Analog-to-Digital Conversion, <em class="calibre7">Stanford Electronics Laboratories</em>, Technical Report No. ICL91-009, April 1991, p. 108.</p>
<p class="chapterendnote"><a id="calibre_link-216"></a>[12] Proakis, J., and Manolakis, D. <em class="calibre7">Digital Signal Processing: Principles, Algorithms and Applications</em>, Prentice Hall, Upper Saddle River, New Jersey, 1996.</p>
<p class="chapterendnote"><a id="calibre_link-3079"></a>[13] Oppenheim, A., and Schafer, R. <em class="calibre7">Discrete-Time Signal Processing</em>, Prentice Hall, Englewood Cliffs, New Jersey, 1st ed. 1989, 2nd ed. 1999.</p>
<p class="chapterendnote"><a id="calibre_link-217"></a>[14] Rorabaugh, C. <em class="calibre7">DSP Primer</em>, McGraw-Hill, New York, 1999.</p>
<p class="chapterendnote"><a id="calibre_link-3080"></a><a id="calibre_link-218"></a>[15] Crochiere, R., and Rabiner, L. “Further Considerations in the Design of Decimators and Interpolators,” <em class="calibre7">IEEE Trans. on Acoust. Speech, and Signal Proc.,</em> Vol. ASSP-24, No. 4, August 1976.</p>
<p class="chapterendnote"><a id="calibre_link-219"></a>[16] Ballanger, M., et al. “Interpolation, Extrapolation, and Reduction of Computational Speed in Digital Filters,” <em class="calibre7">IEEE Trans. on Acoust. Speech, and Signal Proc.,</em> Vol. ASSP-22, No. 4, August 1974.</p>
<p class="chapterendnote"><a id="calibre_link-220"></a>[17] Hou, H., and Andrews, H. “Cubic Splines for Image Interpolation and Digital Filtering,” <em class="calibre7">IEEE Trans. on Acoust. Speech, and Signal Proc.,</em> Vol. ASSP-26, No. 6, August 1978.</p>
<p class="chapterendnote"><a id="calibre_link-3081"></a>[18] Keys, R. “Cubic Convolution Interpolation for Digital Image Processing,” <em class="calibre7">IEEE Trans. on Acoust. Speech, and Signal Proc.,</em> Vol. ASSP-29, No. 6, August 1981.</p>
<p class="chapterendnote"><a id="calibre_link-221"></a>[19] Parker, J., et al. “Comparison of Interpolating Methods for Image Resampling,” <em class="calibre7">IEEE Trans. on Medical Imaging,</em> Vol. MI-2, No. 1, August 1983.</p>
<p class="chapterendnote"><a id="calibre_link-222"></a>[20] Blue, K., et al. “Vector Signal Analyzers for Difficult Measurements on Time-Varying and Complex Modulated Signals,” <em class="calibre7">Hewlett-Packard Journal</em>, December 1993.</p>
<p class="chapterendnote"><a id="calibre_link-223"></a>[21] Bartz, M., et al. “Baseband Vector Signal Analyzer Hardware Design,” <em class="calibre7">Hewlett-Packard Journal</em>, December 1993.</p>
<p class="chapterendnote"><a id="calibre_link-224"></a>[22] Mitchell, J. “Multirate Filters Alter Sampling Rates Even After You’ve Captured the Data,” <em class="calibre7">EDN</em>, August 20, 1992.</p>
<p class="calibre3"><a id="calibre_link-662"></a></p>
<h3 class="calibre6"><a id="calibre_link-3082" class="calibre5"></a>Chapter 10 Problems</h3>
<p class="indenthanging6"><strong class="calibre9">10.1</strong> Assume we want to decimate an <em class="calibre7">x</em>(<em class="calibre7">n</em>) time-domain sequence by four.</p>
<p class="indenthangingn2"><strong class="calibre9">(a)</strong> Should the <em class="calibre7">x</em>(<em class="calibre7">n</em>) sequence be lowpass filtered before or after we discard every fourth sample?</p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> Draw the frequency magnitude response of an ideal lowpass filter used in this decimation-by-four process. Label the frequency axis of your drawing in both Hz (in terms of the filter’s input data sampling rate <em class="calibre7">f<sub class="calibre12">s</sub></em> Hz) and our “discrete-system” frequency notation of radians/sample.</p>
<p class="indenthangingn2"><strong class="calibre9">(c)</strong> What should be the lowpass filter’s zero-Hz (DC) magnitude so that there is no time-domain amplitude gain or loss in our decimation process?</p>
<p class="indenthanging6"><strong class="calibre9">10.2</strong> Assume we have a 72-sample sinusoidal <em class="calibre7">x</em>(<em class="calibre7">n</em>) time-domain sequence, the first 36 samples of which are shown in <a href="#calibre_link-226">Figure P10-2(a)</a>. Next we decimate <em class="calibre7">x</em>(<em class="calibre7">n</em>) by two to generate 36 samples of the <em class="calibre7">y</em>(<em class="calibre7">m</em>) sequence shown in <a href="#calibre_link-226">Figure P10-2(b)</a>. Sequence <em class="calibre7">y</em>(<em class="calibre7">m</em>) is also sinusoidal, as we should expect, but its frequency appears to be double the frequency of <em class="calibre7">x</em>(<em class="calibre7">n</em>). Explain that apparent frequency difference.</p>
<p class="caption"><a id="calibre_link-226"></a><strong class="calibre9">Figure P10-2</strong></p>
<p class="image"><img src="images/000087.jpg" alt="image" class="calibre2" /></p>
<p class="indenthanging6"><strong class="calibre9">10.3</strong> Assume we collected 2048 samples of a sinewave whose frequency is 128 Hz using an <em class="calibre7">f<sub class="calibre12">s</sub></em> sample rate of 1024 Hz, and we call those samples <em class="calibre7">w</em>(<em class="calibre7">n</em>). The first 20 samples of <em class="calibre7">w</em>(<em class="calibre7">n</em>) are shown in <a href="#calibre_link-227">Figure P10-3</a>. Next we perform a 2048-point FFT on <em class="calibre7">w</em>(<em class="calibre7">n</em>) to produce a <em class="calibre7">W</em>(<em class="calibre7">m</em>) sequence.</p>
<p class="caption"><a id="calibre_link-3083"></a><a id="calibre_link-227"></a><strong class="calibre9">Figure P10-3</strong></p>
<p class="image"><img src="images/000931.jpg" alt="image" class="calibre2" /></p>
<p class="indenthangingn2"><strong class="calibre9">(a)</strong> What is the <em class="calibre7">m</em> frequency index value, <em class="calibre7">m</em><sub class="calibre12">max</sub>, of the FFT sample having the largest magnitude over the positive-frequency range of |<em class="calibre7">W</em>(<em class="calibre7">m</em>)|? Show how you arrived at your answer.</p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> Next, suppose we decimate <em class="calibre7">w</em>(<em class="calibre7">n</em>) by a factor of two to generate the 1024-point sequence <em class="calibre7">x</em>(<em class="calibre7">n</em>) defined by</p>
<p class="center"><em class="calibre7">x</em>(<em class="calibre7">n</em>) = <em class="calibre7">w</em>(2<em class="calibre7">n</em>).</p>
<p class="indentpara4">If we perform a 1024-point FFT of <em class="calibre7">x</em>(<em class="calibre7">n</em>), what is the <em class="calibre7">m</em> frequency index value, <em class="calibre7">m</em><sub class="calibre12">max,dec=2</sub>, of the FFT sample having the largest magnitude over the positive-frequency range of |<em class="calibre7">X</em>(<em class="calibre7">m</em>)|? Show how you arrived at your answer.</p>
<p class="indenthangingn2"><strong class="calibre9">(c)</strong> Finally, assume we decimate <em class="calibre7">x</em>(<em class="calibre7">n</em>) by a factor of two to generate the 512-point sequence <em class="calibre7">y</em>(<em class="calibre7">n</em>) defined by</p>
<p class="center"><em class="calibre7">y</em>(<em class="calibre7">n</em>) = <em class="calibre7">x</em>(2<em class="calibre7">n</em>).</p>
<p class="indentpara4">If we perform a 512-point FFT of <em class="calibre7">y</em>(<em class="calibre7">n</em>), what is the <em class="calibre7">m</em> frequency index value, <em class="calibre7">m</em><sub class="calibre12">max,dec=2</sub>, of the FFT sample having the largest magnitude over the positive-frequency range of |<em class="calibre7">Y</em>(<em class="calibre7">m</em>)|? Show how you arrived at your answer.</p>
<p class="indenthanging6"><strong class="calibre9">10.4</strong> In this chapter we’ve portrayed decimation by an integer factor <em class="calibre7">M</em> with the block diagram shown in <a href="#calibre_link-228">Figure P10-4</a>, that is, a lowpass decimation filter followed by a downsampler (the “↓<em class="calibre7">M</em>” symbol) that discards all but every <em class="calibre7">M</em>th filter output sample. In this problem we explore the changes in signal time-domain amplitude and frequency-domain magnitude caused by decimation.</p>
<p class="caption"><a id="calibre_link-228"></a><strong class="calibre9">Figure P10-4</strong></p>
<p class="image"><img src="images/001795.jpg" alt="image" class="calibre2" /></p>
<p class="indentpara5"><a id="calibre_link-3084"></a>For this problem, our assumptions are:</p>
<p class="indenthangingb1">• The lowpass filter in <a href="#calibre_link-228">Figure P10-4</a> has a passband gain of unity and passband width of 0 to 250 Hz.</p>
<p class="indenthangingb1">• The <em class="calibre7">x</em>(<em class="calibre7">n</em>) sequence contains a 100 Hz sinusoidal component whose time-domain peak amplitude is <em class="calibre7">P</em>.</p>
<p class="indenthangingb1">• In the frequency domain, the 100 Hz <em class="calibre7">x</em>(<em class="calibre7">n</em>) sinusoid is located exactly on a 4<em class="calibre7">N</em>-point discrete Fourier transform (DFT) bin center and its 4<em class="calibre7">N</em>-point DFT spectral magnitude is <em class="calibre7">K</em>.</p>
<p class="indenthangingb1">• Finally, we apply exactly 4<em class="calibre7">N</em> samples of <em class="calibre7">w</em>(<em class="calibre7">n</em>) to the <em class="calibre7">M</em> = 4 downsampler.</p>
<p class="indenthangingn2"><strong class="calibre9">(a)</strong> What is the <em class="calibre7">f<sub class="calibre12">s</sub></em><sub class="calibre12">2</sub> sample rate (in Hz) of the <em class="calibre7">y</em>(<em class="calibre7">m</em>) time-domain sequence?</p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> What is the peak time-domain amplitude of the 100 Hz sinusoid in the <em class="calibre7">w</em>(<em class="calibre7">n</em>) sequence?</p>
<p class="indenthangingn2"><strong class="calibre9">(c)</strong> What is the peak time-domain amplitude of the 100 Hz sinusoid in the <em class="calibre7">y</em>(<em class="calibre7">m</em>) sequence? Justify your answer.</p>
<p class="indenthangingn2"><strong class="calibre9">(d)</strong> What is the magnitude of the 100 Hz spectral component in an <em class="calibre7">N</em>-point DFT of <em class="calibre7">y</em>(<em class="calibre7">m</em>)? Justify your answer.</p>
<p class="indenthangingn2"><strong class="calibre9">(e)</strong> What is the equation that defines <a href="#calibre_link-228">Figure P10-4</a>’s downsampled <em class="calibre7">y</em>(<em class="calibre7">m</em>) sequence in terms of the <em class="calibre7">w</em>(<em class="calibre7">n</em>) sequence?</p>
<p class="indentpara5"><strong class="calibre9">Hint:</strong> Your solution to this part of the problem will take the form</p>
<p class="center"><em class="calibre7">y</em>(<em class="calibre7">m</em>) = <em class="calibre7">w</em>(?).</p>
<p class="indenthanging6"><strong class="calibre9">10.5</strong> Given the <em class="calibre7">x</em><sub class="calibre12">r</sub>(<em class="calibre7">n</em>) input signal in <a href="#calibre_link-229">Figure P10-5(a)</a>, whose |<em class="calibre7">X</em><sub class="calibre12">r</sub>(<em class="calibre7">f</em>)| magnitude spectrum is shown in <a href="#calibre_link-229">Figure P10-5(b)</a>, draw a rough sketch of the |<em class="calibre7">X</em><sub class="calibre12">c</sub>(<em class="calibre7">f</em>)| spectrum of the system’s complex <em class="calibre7">x</em><sub class="calibre12">c</sub>(<em class="calibre7">m</em>) = <em class="calibre7">x</em><sub class="calibre12">I</sub>(<em class="calibre7">m</em>) + <em class="calibre7">jx</em><sub class="calibre12">Q</sub>(<em class="calibre7">m</em>) output sequence. The frequency magnitude responses of the complex bandpass <em class="calibre7">h</em><sub class="calibre12">BP</sub>(<em class="calibre7">k</em>) filter and the real-valued highpass <em class="calibre7">h</em><sub class="calibre12">HP</sub>(<em class="calibre7">k</em>) filters are provided in <a href="#calibre_link-229">Figures P10-5(c)</a> and <a href="#calibre_link-229">P10-5(d)</a>.</p>
<p class="caption"><a id="calibre_link-229"></a><strong class="calibre9">Figure P10-5</strong></p>
<p class="image"><img src="images/000819.jpg" alt="image" class="calibre2" /></p>
<p class="indenthanging6"><strong class="calibre9">10.6</strong> Assume we want to design the decimation by <em class="calibre7">M</em> = 30 system shown in <a href="#calibre_link-230">Figure P10-6(a)</a>. The desired LPF<sub class="calibre12">0</sub> lowpass filter’s frequency magnitude response is the solid lines shown in <a href="#calibre_link-230">Figure P10-6(b)</a>. The filter’s stopband attenuation is 50 dB. (The dashed lines are the spectral replication of the lowpass filter’s frequency response.) The one-sided passband width of the lowpass filter is <em class="calibre7">B</em>′ = 1.7 kHz.</p>
<p class="indenthangingn2"><strong class="calibre9">(a)</strong> Using the text’s <a href="#calibre_link-127">Eq. (10-3)</a>, estimate the number of taps in the LPF<sub class="calibre12">0</sub> lowpass filter.</p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> Assuming we decide to implement our decimation by <em class="calibre7">M</em> = 30 system using two-stage decimation as shown in <a href="#calibre_link-230">Figure P10-6(c)</a>, what are the optimum <em class="calibre7">M</em><sub class="calibre12">1</sub> and <em class="calibre7">M</em><sub class="calibre12">2</sub> decimation factors?</p>
<p class="caption"><a id="calibre_link-3085"></a><a id="calibre_link-230"></a><strong class="calibre9">Figure P10-6</strong></p>
<p class="image"><img src="images/001678.jpg" alt="image" class="calibre2" /></p>
<p class="indenthangingn2"><a id="calibre_link-3086"></a><strong class="calibre9">(c)</strong> Using the text’s <a href="#calibre_link-127">Eq. (10-3)</a>, estimate the number of taps in the LPF<sub class="calibre12">1</sub> and LPF<sub class="calibre12">1</sub> lowpass filters in <a href="#calibre_link-230">Figure P10-6(c)</a>.</p>
<p class="indenthangingn2"><strong class="calibre9">(d)</strong> What is the reduction in number of filter taps using the system in <a href="#calibre_link-230">Figure P10-6(c)</a> compared to the number of filter taps needed by the system in <a href="#calibre_link-230">Figure P10-6(a)</a>?</p>
<p class="indenthanging6"><strong class="calibre9">10.7</strong> Here is a interesting problem. In <a href="#calibre_link-79">Chapter 5</a> we discussed the <em class="calibre7">transient response</em> of tapped-delay line FIR filters and stated that an FIR filter’s output samples are not valid until the filter’s delay line is filled with input data samples. Assuming that the 23rd output sample of LPF<sub class="calibre12">1</sub> is the first sample applied to LPF<sub class="calibre12">2</sub>, how many <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) input samples must be applied to the two-stage decimation filter shown in <a href="#calibre_link-231">Figure P10-7</a> to fill the LPF<sub class="calibre12">1</sub> and LPF<sub class="calibre12">2</sub> lowpass filters with input data?</p>
<p class="caption"><a id="calibre_link-231"></a><strong class="calibre9">Figure P10-7</strong></p>
<p class="image"><img src="images/000699.jpg" alt="image" class="calibre2" /></p>
<p class="indenthanging6"><strong class="calibre9">10.8</strong> Assume we want to interpolate an <em class="calibre7">x</em>(<em class="calibre7">n</em>) time-domain sequence by three.</p>
<p class="indenthangingn2"><strong class="calibre9">(a)</strong> Should we perform upsampling (insertion of zero-valued samples) on the <em class="calibre7">x</em>(<em class="calibre7">n</em>) sequence before or after implementing lowpass filtering?</p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> Draw the frequency magnitude response of an ideal lowpass filter used in this interpolation-by-three process. Label the frequency axis of your drawing in both Hz (in terms of the filter’s input data sampling rate <em class="calibre7">f<sub class="calibre12">s</sub></em> Hz) and our “discrete-system” frequency notation of radians/sample.</p>
<p class="indenthangingn2"><strong class="calibre9">(c)</strong> What should be the lowpass filter’s zero-Hz (DC) magnitude so that there is no time-domain amplitude gain or loss in our interpolation process?</p>
<p class="indenthanging6"><strong class="calibre9">10.9</strong> Let’s make sure we fully understand the spectral effects of interpolation by considering the 8-sample, single-cycle, <em class="calibre7">x</em>(<em class="calibre7">n</em>) sinewave sequence in <a href="#calibre_link-232">Figure P10-9(a)</a>. That sequence’s <em class="calibre7">X</em>(<em class="calibre7">m</em>) DFT spectral magnitude samples are shown in <a href="#calibre_link-232">Figure P10-9(b)</a>. If we upsample <em class="calibre7">x</em>(<em class="calibre7">n</em>) by a factor of three, by inserting two zero-valued samples between each <em class="calibre7">x</em>(<em class="calibre7">n</em>) sample, we produce the 24-sample <em class="calibre7">y</em>(<em class="calibre7">p</em>) time sequence shown in <a href="#calibre_link-232">Figure P10-9(c)</a>.</p>
<p class="indenthangingn2"><strong class="calibre9">(a)</strong> What is the time-domain equation that defines the upsampled <em class="calibre7">y</em>(<em class="calibre7">p</em>) sequence in terms of the <em class="calibre7">x</em>(<em class="calibre7">n</em>) sequence?</p>
<p class="caption"><a id="calibre_link-3087"></a><a id="calibre_link-232"></a><strong class="calibre9">Figure P10-9</strong></p>
<p class="image"><img src="images/001559.jpg" alt="image" class="calibre2" /></p>
<p class="indentpara4"><strong class="calibre9">Hint:</strong> Your solution to this part of the problem will have two parts and look like</p>
<p class="image"><img src="images/000794.jpg" alt="image" class="calibre2" /></p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> Draw the spectral magnitude samples of the 24-point <em class="calibre7">Y</em>(<em class="calibre7">m</em>) DFT of <em class="calibre7">y</em>(<em class="calibre7">p</em>).</p>
<p class="indenthanging6"><strong class="calibre9">10.10</strong> Assume we have a time-domain sequence of real-valued samples, <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>), whose spectral magnitude is shown in <a href="#calibre_link-233">Figure P10-10</a>. (We represent spectral replications by the dashed lines.) There we see that the frequency points of spectral symmetry of |<em class="calibre7">X</em><sub class="calibre12">old</sub>(<em class="calibre7">f</em>)|, represented by the bold down arrows, can be described by</p>
<p class="image"><img src="images/001101.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-233"></a><strong class="calibre9">Figure P10-10</strong></p>
<p class="image"><img src="images/000614.jpg" alt="image" class="calibre2" /></p>
<p class="indentpara">where <em class="calibre7">k</em> is an integer. If we upsample <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) by two, by inserting a zero-valued sample between each <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) sample, to generate a new time sequence <em class="calibre7">x</em><sub class="calibre12">new</sub>(<em class="calibre7">m</em>), what is the expression for the frequency points of spectral symmetry of |<em class="calibre7">X</em><sub class="calibre12">new</sub>(<em class="calibre7">f</em>)|?</p>
<p class="indenthanging6"><a id="calibre_link-3088"></a><strong class="calibre9">10.11</strong> Texas Instruments Inc. produces a digital filter chip, Part #GC2011A, used in cell phones for frequency up-conversion. The process, described in their AN9804 application note document, is depicted in <a href="#calibre_link-234">Figure P10-11(a)</a>. The lowpass filter’s 1 MHz-wide passband covers the frequency range shown in <a href="#calibre_link-234">Figure P10-11(b)</a>. (The lowpass filter block comprises two separate real-valued 1 MHz-wide filters, filtering the real and imaginary parts of the complex signal at node B.) If the spectral magnitude of the <em class="calibre7">x</em>(<em class="calibre7">n</em>) input is that shown by the solid curves in <a href="#calibre_link-234">Figure P10-11(c)</a>, where we represent spectral replications by the dashed curves, draw the spectral magnitudes of the complex sequences at nodes A, B, C, and the real part of the <em class="calibre7">y</em>(<em class="calibre7">m</em>) output sequence.</p>
<p class="caption"><a id="calibre_link-234"></a><strong class="calibre9">Figure P10-11</strong></p>
<p class="image"><img src="images/001444.jpg" alt="image" class="calibre2" /></p>
<p class="indentpara5"><strong class="calibre9">Hint:</strong> In <a href="#calibre_link-235">Chapter 8</a> we learned that multiplying a time sequence by <em class="calibre7">e</em><sup class="calibre10">&ndash;<em class="calibre7">j</em>2<em class="calibre7">n</em>/4</sup> = 1, &ndash;<em class="calibre7">j</em>, &ndash;1, <em class="calibre7">j</em>, ..., translates the signal’s spectrum down in frequency.</p>
<p class="indenthanging6"><a id="calibre_link-3089"></a><strong class="calibre9">10.12</strong> Here is a fun interpolation problem. <a href="#calibre_link-236">Figure P10-12(a)</a> shows a simple digital filtering system. Assume that the analog <em class="calibre7">x</em>(<em class="calibre7">t</em>) signal applied to the analog-digital (A/D) converter contains a 9 kHz sinusoid and an 11 kHz sinusoid. The spectral magnitude of the sampled <em class="calibre7">x</em>(<em class="calibre7">n</em>) sequence is given in <a href="#calibre_link-236">Figure P10-12(b)</a>. The system’s function is to filter out the 11 kHz tone and provide a <em class="calibre7">y</em>(<em class="calibre7">m</em>) output sequence that is a 9 kHz sinusoid at a sample rate of <em class="calibre7">f<sub class="calibre12">s</sub></em> = 32 kHz. The dashed curve in <a href="#calibre_link-236">Figure P10-12(b)</a> indicates the unity-gain bandpass filter’s frequency magnitude response, while the spectrum of our desired filter output, whose magnitude is <em class="calibre7">K</em>, is given in <a href="#calibre_link-236">Figure P10-12(c)</a>.</p>
<p class="caption"><a id="calibre_link-236"></a><strong class="calibre9">Figure P10-12</strong></p>
<p class="image"><img src="images/000480.jpg" alt="image" class="calibre2" /></p>
<p class="indentpara5">Now, assume that the system is constrained to use an A/D converter whose clock rate is 8 kHz (instead of 32 kHz), as shown in <a href="#calibre_link-236">Figure P10-12(d)</a>.</p>
<p class="indenthangingn2"><strong class="calibre9">(a)</strong> Draw the block diagram of the <em class="calibre7">processing system</em> that provides the desired <em class="calibre7">y</em>(<em class="calibre7">m</em>) output sequence at a sample rate of <em class="calibre7">f<sub class="calibre12">s</sub></em> = 32 kHz which is four times the <em class="calibre7">u</em>(<em class="calibre7">n</em>) sample rate.</p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> Draw spectral diagrams that justify your solution.</p>
<p class="indenthanging6"><strong class="calibre9">10.13</strong> In this chapter we discussed various forms of interpolation. There is a well-known interpolation process called <em class="calibre7">linear interpolation.</em> It’s an interpolation-by-two method for estimating sample values of a continuous function <a id="calibre_link-3090"></a>between some given <em class="calibre7">x</em>(<em class="calibre7">n</em>) sample values of that function. For the <em class="calibre7">x</em>(<em class="calibre7">n</em>) time samples in <a href="#calibre_link-237">Figure P10-13(a)</a>, linear interpolation is the process of computing the intermediate <em class="calibre7">y</em>(<em class="calibre7">n</em>) samples shown as the black squares in <a href="#calibre_link-237">Figure P10-13(b)</a>. That is, the interpolated sample <em class="calibre7">y</em>(1) is the value lying at the center of the straight line connecting <em class="calibre7">x</em>(0) and <em class="calibre7">x</em>(1), the interpolated sample <em class="calibre7">y</em>(2) is the value lying at the center of the straight line connecting <em class="calibre7">x</em>(1) and <em class="calibre7">x</em>(2), and so on. Given this process of linear interpolation:</p>
<p class="indenthangingn2"><strong class="calibre9">(a)</strong> What is the <em class="calibre7">z</em>-domain expression for the <em class="calibre7">H</em>(<em class="calibre7">z</em>) = <em class="calibre7">Y</em>(<em class="calibre7">z</em>)/<em class="calibre7">X</em>(<em class="calibre7">z</em>) transfer function of the linear interpolation process?</p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> Draw a rough sketch of the frequency magnitude response of a linear interpolation filter over the frequency range of ω = ±π radians/sample (±<em class="calibre7">f<sub class="calibre12">s</sub></em>/2 Hz).</p>
<p class="indenthangingn2"><strong class="calibre9">(c)</strong> Comment on the advantage of, and the disadvantage of, using linear interpolation to perform interpolation by a factor of two.</p>
<p class="caption"><a id="calibre_link-237"></a><strong class="calibre9">Figure P10-13</strong></p>
<p class="image"><img src="images/001341.jpg" alt="image" class="calibre2" /></p>
<p class="indenthanging6"><strong class="calibre9">10.14</strong> Assume we must convert a compact disc (CD) audio signal, whose sample rate is <em class="calibre7">f</em><sub class="calibre12"><em class="calibre7">s</em>,CD</sub> = 44.1 kHz, to a digital audio tape (DAT) signal whose sample rate is <em class="calibre7">f</em><sub class="calibre12"><em class="calibre7">s</em>,DAT</sub> = 48 kHz. If we interpolate that CD signal by a factor of <em class="calibre7">L</em> = 160, by what factor <em class="calibre7">M</em> must we decimate the interpolated signal to obtain a final sample rate of 48 kHz?</p>
<p class="indenthanging6"><strong class="calibre9">10.15</strong> Consider the <em class="calibre7">x</em><sub class="calibre12">o</sub>(<em class="calibre7">n</em>) time sequence in <a href="#calibre_link-238">Figure P10-15(a)</a>, whose sample rate is <em class="calibre7">f<sub class="calibre12">s</sub></em> = 1 kHz. If we decimate <em class="calibre7">x</em><sub class="calibre12">o</sub>(<em class="calibre7">n</em>) by two, we obtain the <em class="calibre7">x</em><sub class="calibre12">D</sub>(<em class="calibre7">m</em><sub class="calibre12">D</sub>) sequence shown in <a href="#calibre_link-238">Figure P10-15(b)</a>, where the odd-<em class="calibre7">n</em> samples of <em class="calibre7">x</em><sub class="calibre12">o</sub>(<em class="calibre7">n</em>) have been discarded. Next, if we interpolate <em class="calibre7">x</em><sub class="calibre12">o</sub>(<em class="calibre7">n</em>) by two, we obtain the <em class="calibre7">x</em><sub class="calibre12">I</sub>(<em class="calibre7">m</em><sub class="calibre12">I</sub>) sequence shown in <a id="calibre_link-3091"></a><a href="#calibre_link-238">Figure P10-15(c)</a>, where the interpolated samples are shown as white dots. Comment on how decimation and interpolation affect the time duration of the decimated and interpolated sequences relative to the time duration of the original <em class="calibre7">x</em><sub class="calibre12">o</sub>(<em class="calibre7">n</em>) sequence.</p>
<p class="caption"><a id="calibre_link-238"></a><strong class="calibre9">Figure P10-15</strong></p>
<p class="image"><img src="images/000261.jpg" alt="image" class="calibre2" /></p>
<p class="indenthanging6"><strong class="calibre9">10.16</strong> Fill in the following table. When complete and correct, the table shows the time-domain and frequency-domain gain of the two processes: decimation by <em class="calibre7">M</em>, and interpolation by <em class="calibre7">L</em>.</p>
<p class="indentpara">Here, decimation means lowpass filtering (by a unity-gain filter) <em class="calibre7">NM</em> time samples followed by the discarding of every <em class="calibre7">M</em>th filter output sample to obtain <em class="calibre7">N</em> time samples. By “interpolation” we mean upsampling by inserting <em class="calibre7">L</em>&ndash;1 zero-valued samples between adjacent samples of an <em class="calibre7">N</em>-length time-domain sequence followed by lowpass filtering using a unity-gain lowpass filter to obtain <em class="calibre7">NL</em> time samples. Assume the sample rate change factors <em class="calibre7">M</em> and <em class="calibre7">L</em> are integers.</p>
<p class="title">Sample Rate Conversion Gain</p>
<p class="image"><img src="images/000821.jpg" alt="image" class="calibre2" /></p>
<p class="indenthanging6"><a id="calibre_link-3092"></a><strong class="calibre9">10.17</strong> Here is an interesting, and educational, problem because it shows the spectral effects of upsampling a downsampled sequence. Think about the sample rate change process in <a href="#calibre_link-239">Figure P10-17(a)</a>. The upsampling operation “↑4” means insert three zero-valued samples between each <em class="calibre7">q</em>(<em class="calibre7">m</em>) sample. Assume the spectral magnitude of the <em class="calibre7">x</em>(<em class="calibre7">n</em>) sequence is the |<em class="calibre7">X</em>(<em class="calibre7">f</em>)| shown in <a href="#calibre_link-239">Figure P10-17(b)</a>.</p>
<p class="caption"><a id="calibre_link-239"></a><strong class="calibre9">Figure P10-17</strong></p>
<p class="image"><img src="images/001224.jpg" alt="image" class="calibre2" /></p>
<p class="indenthangingn2"><strong class="calibre9">(a)</strong> Draw the |<em class="calibre7">Q</em>(<em class="calibre7">f</em>)| spectrum of sequence <em class="calibre7">q</em>(<em class="calibre7">m</em>) including the peak spectral magnitude levels in terms of <em class="calibre7">K</em>. Show spectral replications (located at multiples of the <em class="calibre7">q</em>(<em class="calibre7">m</em>) sample rate) as dashed curves as was done in <a href="#calibre_link-239">Figure P10-17(b)</a>.</p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> Draw the |<em class="calibre7">W</em>(<em class="calibre7">f</em>)| spectrum of sequence <em class="calibre7">w</em>(<em class="calibre7">p</em>) including the peak spectral magnitude levels in terms of <em class="calibre7">K</em>. Show spectral replications as dashed curves.</p>
<p class="indenthangingn2"><strong class="calibre9">(c)</strong> Draw the frequency magnitude response of the lowpass filter, including its passband gain value, that would produce a <em class="calibre7">y</em>(<em class="calibre7">p</em>) output sequence whose <em class="calibre7">Y</em>(<em class="calibre7">f</em>) spectral magnitude is equal to |<em class="calibre7">X</em>(<em class="calibre7">f</em>)|.</p>
<p class="indenthangingn2"><strong class="calibre9">(d)</strong> When first learning the principles of sample rate change (multirate systems), it is easy to believe that following a “↓4” decimation process with an “↑4” upsampling process would mean the two processes cancel each other such that the overall cascaded effect would be <em class="calibre7">no change</em>. Is this correct?</p>
<p class="indenthanging6"><strong class="calibre9">10.18</strong> One way to implement a secure telephone communications channel is shown in <a href="#calibre_link-240">Figure P10-18(a)</a>. Anyone monitoring the telephone line will not be able to understand the audio speech signal on that line. The scrambling network is shown in <a href="#calibre_link-240">Figure P10-18(b)</a>, where the two identical <em class="calibre7">L</em>(<em class="calibre7">f</em>) digital lowpass filters have passbands that extend from &ndash;2 kHz to +2 kHz. The two identical <em class="calibre7">H</em>(<em class="calibre7">f</em>) digital highpass filters have passbands that extend from &ndash;6 kHz to &ndash;2 kHz, and 2 kHz to 6 kHz.</p>
<p class="indenthangingn2"><strong class="calibre9">(a)</strong> If the <em class="calibre7">x</em>(<em class="calibre7">n</em>) input to the first scrambling network has the spectrum shown in <a href="#calibre_link-240">Figure P10-18(c)</a>, draw the spectrum, over the frequency range of ±<em class="calibre7">f<sub class="calibre12">s</sub></em>, of the output sequence from the first scrambling network in <a href="#calibre_link-240">Figure P10-18(a)</a>.</p>
<p class="caption"><a id="calibre_link-3093"></a><a id="calibre_link-240"></a><strong class="calibre9">Figure P10-18</strong></p>
<p class="image"><img src="images/000264.jpg" alt="image" class="calibre2" /></p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> Draw the spectrum, over the frequency range of ±<em class="calibre7">f<sub class="calibre12">s</sub></em>, of the output sequence from the second scrambling network in <a href="#calibre_link-240">Figure P10-18(a)</a>.</p>
<p class="indenthanging6"><strong class="calibre9">10.19</strong> In <a href="#calibre_link-121">Section 10.7</a> we depicted a polyphase filter, used in an interpolation-by-four process, with the structure shown in <a href="#calibre_link-241">Figure P10-19-I</a>. The <em class="calibre7">H<sub class="calibre12">k</sub></em>(<em class="calibre7">z</em>) blocks represent tapped-delay line FIR polyphase subfilters containing unit-delay elements, multipliers, and adders.</p>
<p class="indenthangingn2"><strong class="calibre9">(a)</strong> Why are the polyphase subfilters useful when used in an interpolation process?</p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> Determine how to replace the commutating (rotating) switch in <a href="#calibre_link-241">Figure P10-19-I</a> using only the delay and upsampler elements shown in <a href="#calibre_link-242">Figure P10-19-II(a)</a>. That is, determine what’s inside the mysterious block in <a href="#calibre_link-242">Figure P10-19-II(b)</a> to make that figure equivalent to <a href="#calibre_link-241">Figure P10-19-I</a>.</p>
<p class="caption"><a id="calibre_link-241"></a><strong class="calibre9">Figure P10-19-I</strong></p>
<p class="image"><img src="images/001106.jpg" alt="image" class="calibre2" /></p>
<p class="caption"><a id="calibre_link-242"></a><strong class="calibre9">Figure P10-19-II</strong></p>
<p class="image"><img src="images/000858.jpg" alt="image" class="calibre2" /></p>
<p class="indentpara4">The correct solution to this problem will show a polyphase structure with which you should become familiar. That structure is often used in the DSP literature of multirate systems to depict polyphase interpolation filters.</p>
<p class="indentpara4"><a id="calibre_link-3094"></a><strong class="calibre9">Hint:</strong> Given some <em class="calibre7">x</em>(<em class="calibre7">n</em>) sequence, write the sample sequences on the four output lines of the <em class="calibre7">H<sub class="calibre12">k</sub></em>(<em class="calibre7">z</em>) subfilters, and <em class="calibre7">y</em>(<em class="calibre7">n</em>) in <a href="#calibre_link-241">Figure P10-19-I</a>. Then determine how to obtain that same <em class="calibre7">y</em>(<em class="calibre7">m</em>) output sequence in <a href="#calibre_link-242">Figure P10-19-II(b)</a>. The coefficients of polynomial <em class="calibre7">H<sub class="calibre12">k</sub></em>(<em class="calibre7">z</em>) are not important to this problem. Assume the subfilters have no delay elements, a single multiplier, and a coefficient of one, if you wish.</p>
<p class="indenthanging6"><strong class="calibre9">10.20</strong> Occasionally in the literature of DSP you’ll encounter documentation that uses a drawing like that in <a href="#calibre_link-243">Figure P10-20</a> to illustrate some concept, or principle, regarding multirate systems. Notice that the cascaded elements are <em class="calibre7">not</em> our standard “<em class="calibre7">z</em><sup class="calibre10">&ndash;1</sup>” delay-by-one-sample elements but, instead, are <em class="calibre7">advance-by-one-sample</em> elements indicated by a “<em class="calibre7">z</em>” (<em class="calibre7">z</em><sup class="calibre10">+1</sup>).</p>
<p class="caption"><a id="calibre_link-243"></a><strong class="calibre9">Figure P10-20</strong></p>
<p class="image"><img src="images/001000.jpg" alt="image" class="calibre2" /></p>
<p class="indentpara">Show how you would implement the system in <a href="#calibre_link-243">Figure P10-20</a>, in our universe where we cannot look forward in time, to provide the appropriate four time-domain sequences to the “Some useful processing” subsystem’s input ports?</p>
<p class="indenthanging6"><a id="calibre_link-3095"></a><strong class="calibre9">10.21</strong> In the text we discussed decimation by <em class="calibre7">M</em> = 3 and showed two equivalent realizations of such a decimation process as those in <a href="#calibre_link-244">Figures P10-21(a)</a> and <a href="#calibre_link-244">P10-21(b)</a>. Assume that all six subfilters in <a href="#calibre_link-244">Figure P10-21</a> are tapped-delay lines containing four multipliers, and that <em class="calibre7">f<sub class="calibre12">s</sub></em> = 30 samples/second.</p>
<p class="indenthangingn2"><strong class="calibre9">(a)</strong> How many multiplications per second are performed in <a href="#calibre_link-244">Figure P10-21(a)</a>?</p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> How many multiplications per second are performed in <a href="#calibre_link-244">Figure P10-21(b)</a>?</p>
<p class="caption"><a id="calibre_link-244"></a><strong class="calibre9">Figure P10-21</strong></p>
<p class="image"><img src="images/000565.jpg" alt="image" class="calibre2" /></p>
<p class="indenthanging6"><strong class="calibre9">10.22</strong> The decimation-by-four (lowpass filtering followed by downsampling) process shown in <a href="#calibre_link-245">Figure P10-22(a)</a> is inefficient because three out of every four computational results are discarded. A more efficient decimation process is shown in <a href="#calibre_link-245">Figure P10-22(b)</a>, where the switches driving the multipliers <a id="calibre_link-3096"></a>close once, for one sample time period only, upon the arrival of every fourth <em class="calibre7">x</em><sub class="calibre12">old</sub>(<em class="calibre7">n</em>) sample. This way, no unnecessary computations are performed. Likewise, in polyphase decimation filtering no unnecessary computations are performed. In real-time hardware implementations, explain the fundamental difference between the computations performed, from a time-domain standpoint, in the <a href="#calibre_link-245">Figure P10-22(b)</a> decimation filter and a polyphase decimation-by-four filter having 12 multipliers?</p>
<p class="caption"><a id="calibre_link-245"></a><strong class="calibre9">Figure P10-22</strong></p>
<p class="image"><img src="images/001426.jpg" alt="image" class="calibre2" /></p>
<p class="indenthanging6"><strong class="calibre9">10.23</strong> In <a href="#calibre_link-121">Section 10.7</a> we depicted a polyphase filter, used in a decimation-by-four process, with the structure shown in <a href="#calibre_link-246">Figure P10-23-I</a>. The <em class="calibre7">H<sub class="calibre12">k</sub></em>(<em class="calibre7">z</em>) blocks represent tapped-delay line FIR polyphase subfilters containing unit-delay elements, multipliers, and adders.</p>
<p class="caption"><a id="calibre_link-246"></a><strong class="calibre9">Figure P10-23-I</strong></p>
<p class="image"><img src="images/000977.jpg" alt="image" class="calibre2" /></p>
<p class="indenthangingn2"><a id="calibre_link-3097"></a><strong class="calibre9">(a)</strong> Why are polyphase subfilters useful when used in a decimation process?</p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> Determine how to replace the commutating (rotating) input switch in <a href="#calibre_link-246">Figure P10-23-I</a> using only the delay and downsampler elements shown in <a href="#calibre_link-247">Figure P10-23-II(a)</a>. That is, determine what interconnection of delay and downsampler elements must be inside the mysterious block in <a href="#calibre_link-247">Figure P10-23-II(b)</a> to make that figure equivalent to <a href="#calibre_link-246">Figure P10-23-I</a>.</p>
<p class="caption"><a id="calibre_link-247"></a><strong class="calibre9">Figure P10-23-II</strong></p>
<p class="image"><img src="images/001008.jpg" alt="image" class="calibre2" /></p>
<p class="indentpara4">The correct solution to this problem will show a polyphase structure with which you should become familiar. That structure is often used in the DSP literature of multirate systems to depict polyphase decimation filters.</p>
<p class="indentpara4"><strong class="calibre9">Hint:</strong> Given some <em class="calibre7">x</em>(<em class="calibre7">n</em>) sequence, write the <em class="calibre7">x</em>(<em class="calibre7">n</em>), <em class="calibre7">x</em>(<em class="calibre7">n</em>&ndash;1), <em class="calibre7">x</em>(<em class="calibre7">n</em>&ndash;2), etc., sample sequences on the four lines driving the <em class="calibre7">H<sub class="calibre12">k</sub></em>(<em class="calibre7">z</em>) subfilters in <a href="#calibre_link-246">Figure P10-23-I</a>. Then determine how to obtain those same sample sequences for routing to the subfilters in <a href="#calibre_link-247">Figure P10-23-II(b)</a>.</p>
<p class="indenthanging6"><strong class="calibre9">10.24</strong> This problem is related to the material in the text’s <a href="#calibre_link-248">Section 10.10</a>. Assume we are resampling a time sequence by the rational factor 5/4 using a five-position commutating filter output switch as shown in <a href="#calibre_link-249">Figure P10-24</a>.</p>
<p class="indenthangingn2"><strong class="calibre9">(a)</strong> Determine the commutating switch’s port position value (index) <em class="calibre7">k</em>, and the index <em class="calibre7">n</em> of the most recent input <em class="calibre7">x</em>(<em class="calibre7">n</em>) sample applied to the subfilters, used to compute the resampler’s <em class="calibre7">y</em>(<em class="calibre7">m</em>) sample when output index <em class="calibre7">m</em> = 7. Show your work.</p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> For the resampler in <a href="#calibre_link-249">Figure P10-24</a> to have a DC (zero Hz) gain of unity, what must be the DC gain of the original prototype lowpass FIR filter from which the five <em class="calibre7">H<sub class="calibre12">k</sub></em>(<em class="calibre7">z</em>) subfilters were obtained?</p>
<p class="caption"><a id="calibre_link-3098"></a><a id="calibre_link-249"></a><strong class="calibre9">Figure P10-24</strong></p>
<p class="image"><img src="images/000356.jpg" alt="image" class="calibre2" /></p>
<p class="indenthanging6"><strong class="calibre9">10.25</strong> Think about the multirate decimation system, employing lowpass half-band filters, in <a href="#calibre_link-250">Figure P10-25(a)</a>. If the spectrum of the wideband <em class="calibre7">x</em>(<em class="calibre7">n</em>) noise sequence is that shown in <a href="#calibre_link-250">Figure P10-25(b)</a>, the spectrum of the <em class="calibre7">a</em>(<em class="calibre7">n</em>) noise sequence is as shown in <a href="#calibre_link-250">Figure P10-25(c)</a>. Draw the spectra, with appropriate frequency-axis labeling in Hz, of the <em class="calibre7">b</em>(<em class="calibre7">n</em>), <em class="calibre7">c</em>(<em class="calibre7">m</em>), and <em class="calibre7">y</em>(<em class="calibre7">p</em>) sequences.</p>
<p class="caption"><a id="calibre_link-250"></a><strong class="calibre9">Figure P10-25</strong></p>
<p class="image"><img src="images/001203.jpg" alt="image" class="calibre2" /></p>
<p class="indenthanging6"><strong class="calibre9">10.26</strong> The <em class="calibre7">z</em>-domain transfer function of a CIC filter’s comb subfilter having a delay line length of <em class="calibre7">N</em> = 8, shown in <a href="#calibre_link-251">Figure P10-26(a)</a>, is</p>
<p class="center"><em class="calibre7">H</em><sub class="calibre12">comb</sub>(<em class="calibre7">z</em>) = 1 −<em class="calibre7">z</em><sup class="calibre10">&ndash;8</sup>,</p>
<p class="indentpara">and its frequency magnitude response is shown on a linear scale in <a href="#calibre_link-251">Figure P10-26(b)</a>.</p>
<p class="caption"><a id="calibre_link-3099"></a><a id="calibre_link-251"></a><strong class="calibre9">Figure P10-26</strong></p>
<p class="image"><img src="images/000241.jpg" alt="image" class="calibre2" /></p>
<p class="indenthangingn2"><strong class="calibre9">(a)</strong> Each of those multiple frequency magnitude passband curves in <a href="#calibre_link-251">Figure P10-26(b)</a> looks parabolic in shape. In terms of the frequency variable <em class="calibre7">f</em>, a single ideal downward-opening parabola is described by the expression</p>
<p class="center">|<em class="calibre7">H</em><sub class="calibre12">comb</sub>(<em class="calibre7">f</em>)| = &ndash;<em class="calibre7">Kf</em><sup class="calibre10">2</sup></p>
<p class="indentpara4">where <em class="calibre7">K</em> is some constant. Are the shapes of those passband curves in <a href="#calibre_link-251">Figure P10-26(b)</a> indeed a function of <em class="calibre7">f</em><sup class="calibre10">2</sup>, making them parabolic? Show your work.</p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> What is the peak value, <em class="calibre7">P</em>, of the |<em class="calibre7">H</em>(<em class="calibre7">f</em>)| frequency magnitude curve in P10&ndash;26(b)? Show your work. (The <em class="calibre7">P</em> value is important. It tells us what is the maximum gain of a comb subfilter.)</p>
<p class="indentpara4"><strong class="calibre9">Hint:</strong> Deriving an equation for the |<em class="calibre7">H</em><sub class="calibre12">comb</sub>(<em class="calibre7">f</em>)| frequency magnitude response will provide the solutions to Part (a) and Part (b) of this problem.</p>
<p class="indenthanging6"><strong class="calibre9">10.27</strong> In the text we stated that the interpolation CIC filter in <a href="#calibre_link-252">Figure P10-27(a)</a> has an impulse response, when its differential delay <em class="calibre7">D</em> = 5, equal to that shown in <a id="calibre_link-3100"></a><a href="#calibre_link-252">Figure P10-27(c)</a>. We also stated that swapping <a href="#calibre_link-252">Figure P10-27(a)</a>’s comb and integrator resulted in a decimation CIC filter as shown in <a href="#calibre_link-252">Figure P10-27(b)</a>. Prove that the decimation CIC filter in <a href="#calibre_link-252">Figure P10-27(b)</a> also has an impulse response equal to that shown in <a href="#calibre_link-252">Figure P10-27(c)</a>.</p>
<p class="caption"><a id="calibre_link-252"></a><strong class="calibre9">Figure P10-27</strong></p>
<p class="image"><img src="images/001084.jpg" alt="image" class="calibre2" /></p>
<p class="indenthanging6"><strong class="calibre9">10.28</strong> Here is an important problem with regard to implementing two theoretically equivalent digital filters. We illustrate our point using the CIC filters shown in <a href="#calibre_link-253">Figures P10-28(a)</a> and <a href="#calibre_link-253">P10-28(b)</a>. Because they are linear, we can swap the comb and integrator stages of the CIC filter used for interpolation to obtain a CIC filter used for decimation. The two CIC filters have identical time-domain impulse responses.</p>
<p class="caption"><a id="calibre_link-253"></a><strong class="calibre9">Figure P10-28</strong></p>
<p class="image"><img src="images/001144.jpg" alt="image" class="calibre2" /></p>
<p class="indenthangingn2"><strong class="calibre9">(a)</strong> However, to understand an important fundamental difference in the hardware implementation of the two filters, draw the <em class="calibre7">u</em>(<em class="calibre7">n</em>) and <em class="calibre7">y</em>(<em class="calibre7">n</em>) sequences for both filters when the <em class="calibre7">x</em>(<em class="calibre7">n</em>) input to the filters is the <em class="calibre7">step</em> sequence shown in <a href="#calibre_link-253">Figure P10-28(c)</a>. Assume a comb delay of <em class="calibre7">D</em> = 4 for both CIC filters. Your solution should comprise four separate drawings. (Also, assume that the <em class="calibre7">u</em>(<em class="calibre7">n</em>) and <em class="calibre7">y</em>(<em class="calibre7">n</em>) values are zero, for both CIC filters, at time index <em class="calibre7">n</em> &lt; 0.)</p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> To appreciate the implementation difference between interpolation and decimation CIC filters, we need to determine the growth of the binary word width of the memory location, or hardware register, containing the <em class="calibre7">u</em>(<em class="calibre7">n</em>) samples. To do so, fill in the following table, indicating how many binary bits are needed to accommodate the <em class="calibre7">u</em>(<em class="calibre7">n</em>) and <em class="calibre7">y</em>(<em class="calibre7">n</em>) samples for each CIC filter up to time index <em class="calibre7">n</em> = 500.</p>
<p class="indentpara4"><a id="calibre_link-3101"></a><strong class="calibre9">Hint:</strong> The number of binary bits needed to store <em class="calibre7">u</em>(<em class="calibre7">n</em>) is the next integer greater than log<sub class="calibre12">2</sub>[<em class="calibre7">u</em>(<em class="calibre7">n</em>)].</p>
<p class="title">Memory, or Hardware Register, Bit-Width Requirements</p>
<p class="image"><img src="images/001680.jpg" alt="image" class="calibre2" /></p>
<p class="indenthangingn2"><strong class="calibre9">(c)</strong> This question has great practical importance. What does your solution to Part (b) tell us about the binary-word-width requirements of the memory locations, or hardware registers, containing the integrators’ <em class="calibre7">u</em>(<em class="calibre7">n</em>) samples in CIC decimation and CIC interpolation filters?</p>
<p class="indenthanging6"><strong class="calibre9">10.29</strong> Here is a typical problem faced by engineers who use CIC filters. As of this writing, Intersil Corp. makes a decimating digital filter chip (Part #HSP43220) that contains a 5th-order CIC filter. When used for decimation by a factor of <em class="calibre7">R</em> = 6, and the internal comb filters have a differential delay of <em class="calibre7">D</em> = 6, the CIC filter’s frequency magnitude response is shown in <a href="#calibre_link-254">Figure P10-29(a)</a>.</p>
<p class="caption"><a id="calibre_link-254"></a><strong class="calibre9">Figure P10-29</strong></p>
<p class="image"><img src="images/000976.jpg" alt="image" class="calibre2" /></p>
<p class="indenthangingn2"><a id="calibre_link-3102"></a><strong class="calibre9">(a)</strong> After the decimation by 6, any spectral energy in the shaded area of the filter’s response will alias into the <em class="calibre7">B</em>-width signal-of-interest passband centered at 0 Hz as was described in the text. For this commercial 5th-order CIC filter, what is the maximum level of the aliased spectral energy after the decimation by 6? (Stated in different words, what is the value of <em class="calibre7">Atten</em> measured in dB for the HSP43220 CIC filter?) Assume <em class="calibre7">B</em> = 0.04<em class="calibre7">f</em><sub class="calibre12"><em class="calibre7">s</em>,in</sub>.</p>
<p class="indenthangingn2"><strong class="calibre9">(b)</strong> Zooming in on the top portion of the CIC filter’s passband, we show the droop in the passband gain in <a href="#calibre_link-254">Figure P10-29(b)</a>. Measured in dB, what is the HSP43220’s maximum passband gain loss at <em class="calibre7">B</em>/2 Hz?</p>
<p class="indenthanging6"><strong class="calibre9">10.30</strong> There are digital filtering schemes that use the process conceptually shown in <a href="#calibre_link-255">Figure P10-30(a)</a>. In that network the input is lowpass filtered to generate the sequence <em class="calibre7">w</em>(<em class="calibre7">n</em>). The network’s <em class="calibre7">y</em>(<em class="calibre7">n</em>) output is the <em class="calibre7">x</em>(<em class="calibre7">n</em>) input sequence minus the lowpass-filtered <em class="calibre7">w</em>(<em class="calibre7">n</em>) sequence. The actual implementation of such a process is shown in <a href="#calibre_link-255">Figure P10-30(b)</a> where the multi-element delay line in the upper path of <a href="#calibre_link-255">Figure P10-30(b)</a> is needed for time alignment to compensate for the time (group) delay of the CIC filter. If we had to implement this parallel-path filter with a CIC filter whose differential delay is <em class="calibre7">D</em> = 9, how many unit-delay elements would we use in the upper path of <a href="#calibre_link-255">Figure P10-30(b)</a>? Show how you obtained your solution.</p>
<p class="caption"><a id="calibre_link-255"></a><strong class="calibre9">Figure P10-30</strong></p>
<p class="image"><img src="images/001207.jpg" alt="image" class="calibre2" /></p>
</div>


</body></html>
